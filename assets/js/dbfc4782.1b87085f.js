"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[749],{1895:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"calculating-compilers","metadata":{"permalink":"/blog/calculating-compilers","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09--10-hs-ch17/index.md","source":"@site/blog/2025-09--10-hs-ch17/index.md","title":"Calculating compilers","description":"In this final chapter we show how the reasoning techniques introduced in the previous chapter can be used to calculate compilers. We start by showing how a semantics for a language can be transformed into a compiler in a series of steps, and then show how the steps can be combined to allow a compiler to be calculated directly from a statement of its correctness.","date":"2025-09-10T05:57:06.916Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":11.55,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"calculating-compilers","title":"Calculating compilers","authors":["dream2405"],"tags":["haskell","functional_programming"]},"unlisted":false,"nextItem":{"title":"Reasoning about programs","permalink":"/blog/reasoning-about-programs"}},"content":"In this final chapter we show how the reasoning techniques introduced in the previous chapter can be used to calculate compilers. We start by showing how a semantics for a language can be transformed into a compiler in a series of steps, and then show how the steps can be combined to allow a compiler to be calculated directly from a statement of its correctness.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Introduction\\n\\nThe ability to calculate compilers has been a key objective in the field of program transformation since its earliest days. Starting from a high-level semantics for a source language, the aim is to transform the semantics into a compiler that translates source programs into a lower-level target language, together with a virtual machine that executes the resulting target programs.\\n\\nThere are two main advantages of such an approach. Firstly, the compiler, target language and virtual machine are **systematically derived** during the transformation process, rather than having to be manually defined by the user. And secondly, the resulting compiler and virtual machine do not usually require subsequent proofs of correctness, as they are **correct by construction**.\\n\\nIn chapter 16 we presented a compiler for arithmetic expressions, and proved its correctness. In this chapter we show how the compiler can be calculated directly from a statement of its correctness. We develop our approach in two stages, first introducing the basic ideas using a series of transformation steps, and then showing how the separate steps can be combined into a single step. For simplicity, we restrict our attention to arithmetic expressions, but the same techniques can also be used to calculate compilers for more sophisticated languages.\\n\\n## Syntax and semantics\\n\\nWe start in the same manner as the compiler correctness example from the previous chapter, with two definitions that respectively capture the syntax (form) and semantics (meaning) of a simple language of arithmetic expressions built up from integer values using an addition operator:\\n\\n```haskell\\ndata Expr = Val Int | Add Expr Expr\\n\\neval :: Expr -> Int\\neval (Val n) = n\\neval (Add x y) = eval x + eval y\\n```\\n\\nFor example, the expression $1 + 2$ can be evaluated as follows:\\n\\n```haskell\\n  eval (Add (Val 1) (Val 2))\\n= { applying eval }\\n  eval (Val 1) + eval (Val 2)\\n= { applying the first eval }\\n  1 + eval (Val 2)\\n= { applying eval }\\n  1 + 2\\n= { applying + }\\n  3\\n```\\n\\nWe now show how to calculate a compiler based on this semantics using a series of three transformation steps. The first two steps generalise the evaluation function, and the final step simplifies the resulting definitions.\\n\\n## Adding a stack\\n\\nThe first step is to transform the evaluation function `eval` into a version that utilises a stack, in order to make the manipulation of argument values explicit. In particular, rather than returning a single value of type `Int`, we seek to define a more general evaluation function, `eval\'`, that takes a stack of integers as an additional argument, and returns a modified stack given by pushing the value of the expression onto the top of the stack. More precisely, if we represent a stack as a list of integers (where the head is the top element)\\n\\n```haskell\\ntype Stack = [Int]\\n```\\n\\nthen we seek to define a function\\n\\n```haskell\\neval\' :: Expr -> Stack -> Stack\\n```\\n\\nwith the following property:\\n\\n```haskell\\neval\' e s = eval e : s\\n```\\n\\nRather than first defining `eval\'` and then proving by induction on the expression `e` that it satisfies the above equation, we use the technique introduced in the previous chapter and calculate a definition for `eval\'` that satisfies this equation, using the desire to apply the induction hypotheses as the driving force for the calculation process. In the base case, `Val n`, the calculation is easy:\\n\\n```haskell\\n  eval\' (Val n) s\\n= { specification of eval\' }\\n  eval (Val n) : s\\n= { applying eval }\\n  n : s\\n= { define: push n s = n : s }\\n  push n s\\n```\\n\\nNote that in the final step we defined an auxiliary function, `push`, that captures the idea of pushing a number onto the stack. With the above calculation, we have discovered the definition of `eval\'` for expressions of the form `Val n`:\\n\\n```haskell\\neval\' (Val n) s = push n s\\n```\\n\\nIn the inductive case, `Add x y`, we proceed as follows:\\n\\n```haskell\\n  eval\' (Add x y) s\\n= { specification of eval\' }\\n  eval (Add x y) : s\\n= { applying eval }\\n  (eval x + eval y) : s\\n```\\n\\nNow we appear to be stuck, as no further definitions can be applied. However, as we are performing an inductive calculation, we can make use of the induction hypotheses for the two argument expressions `x` and `y`, namely:\\n\\n- `eval\' x s\'` $=$ `eval x : s\'`\\n- `eval\' y s\'` $=$ `eval y : s\'`\\n\\nIn order to use these hypotheses, it is clear that we must push the values `eval x` and `eval y` onto the stack, which can readily be achieved by introducing another auxiliary function, `add`, that captures the idea of adding the top two numbers on the stack. The remainder of the calculation is then straightforward:\\n\\n```haskell\\n  (eval x + eval y) : s\\n= { define: add (m : n : s) = n+m : s }\\n  add (eval y : eval x : s)\\n= { induction hypothesis for x }\\n  add (eval y : eval\' x s)\\n= { induction hypothesis for y }\\n  add (eval\' y (eval\' x s))\\n```\\n\u25a1\\n\\nNote that pushing `eval x` onto the stack before `eval y` above corresponds to addition evaluating its arguments from left-to-right. It would be perfectly valid to push the values in the opposite order, which would correspond to right-to-left evaluation. \\n\\nIn conclusion, we have calculated the following definition\\n\\n```haskell\\neval\' :: Expr -> Stack -> Stack\\neval\' (Val n)   s = push n s\\neval\' (Add x y) s = add (eval\' y (eval\' x s))\\n```\\n\\nwhere:\\n\\n```haskell\\npush :: Int -> Stack -> Stack\\npush n s = n : s\\n\\nadd :: Stack -> Stack\\nadd (m : n : s) = n+m : s\\n```\\n\\nFinally, our original evaluation function `eval` can now be recovered from our new function by substituting the empty stack `s` $=$ `[]` into the equation `eval\' e s` $=$ `eval e : s` from which `eval\'` was constructed, and selecting the unique value in the resulting singleton stack using the function `head`:\\n\\n```haskell\\neval :: Expr -> Int\\neval e = head (eval\' e [])\\n```\\n\\nFor example, using this new definition evaluation of $1+2$ now proceeds by pushing the two values onto the stack prior adding them together:\\n\\n```haskell\\n  eval (Add (Val 1) (Val 2))\\n= { applying eval }\\n  head (eval\' (Add (Val 1) (Val 2)) [])\\n= { applying eval\' }\\n  head (add (eval\' (Val 2) (eval\' (Val 1) [])))\\n= { applying the inner eval\' }\\n  head (add (eval\' (Val 2) (push 1 [])))\\n= { applying eval\' }\\n  head (add (push 2 (push 1 [])))\\n= { applying push }\\n  head (add (2 : 1 : []))\\n= { applying add }\\n  head (3 : [])\\n= { applying head }\\n  3\\n```\\n\\n## Adding a continuation\\n\\nThe next step is to transform the stack-based evaluation function `eval\'` into **continuation-passing style**, in order to make the flow of control explicit. In particular, we seek to define a more general evaluation function, `eval\'\'`, that takes a function from stacks to stacks (the continuation) as an additional argument, which is used to process the stack that results from evaluating the expression. \\n\\nMore precisely, if we define a type for continuations\\n\\n```haskell\\ntype Cont = Stack -> Stack\\n```\\n\\nthen we seek to define a function\\n\\n```haskell\\neval\'\' :: Expr -> Cont -> Cont\\n```\\n\\nsuch that:\\n\\n```haskell\\neval\'\' e c s = c (eval\' e s)\\n```\\n\\nWe calculate the definition for `eval\'\'` directly from this equation by induction on the expression `e`. The base case is once again easy,\\n\\n```haskell\\n  eval\'\' (Val n) c s\\n= { specification of eval\'\' }\\n  c (eval\' (Val n) s)\\n= { applying eval\' }\\n  c (push n s)\\n```\\n\\nwhile for the inductive case we calculate as follows:\\n\\n```haskell\\n  eval\'\' (Add x y) c s\\n= { specification of eval\'\' }\\n  c (eval\' (Add x y) s)\\n= { applying eval\' }\\n  c (add (eval\' y (eval\' x s)))\\n= { unapplying . }\\n  (c . add) (eval\' y (eval\' x s))\\n= { induction hypothesis for y }\\n  eval\'\' y (c . add) (eval\' x s)\\n= { induction hypothesis for x }\\n  eval\'\' x (eval\'\' y (c . add)) s\\n```\\n\\nIn conclusion, we have calculated the following definition:\\n\\n```haskell\\neval\'\' :: Expr -> Cont -> Cont\\neval\'\' (Val n)   c s = c (push n s)\\neval\'\' (Add x y) c s = eval\'\' x (eval\'\' y (c . add)) s\\n```\\n\\nOur previous evaluation function `eval\'` can now be recovered by substituting the identity continuation `c` $=$ `id` into the equation `eval\'\' e c s` $=$ `c (eval\' e s)` from which the function `eval\'\'` was constructed:\\n\\n```haskell\\neval\' :: Expr -> Cont\\neval\' e s = eval\'\' e id s\\n```\\n\\nFor example, evaluation of $1 + 2$ now proceeds by transferring control to evaluation of the second argument once evaluation of the first has completed:\\n\\n```haskell\\n  eval\' (Add (Val 1) (Val 2)) []\\n= { applying eval\' }\\n  eval\'\' (Add (Val 1) (Val 2)) id []\\n= { applying eval\'\' }\\n  eval\'\' (Val 1) (eval\'\' (Val 2) (id . add)) []\\n= { applying the outer eval\'\' }\\n  eval\'\' (Val 2) (id . add) (push 1 [])\\n= { applying eval\'\' }\\n  (id . add) (push 2 (push 1 []))\\n= { applying . }\\n  id (add (push 2 (push 1 [])))\\n= { applying push }\\n  id (add (2 : 1 : []))\\n= { applying add }\\n  id [3]\\n= { applying id }\\n  [3]\\n```\\n\\n## Defunctionalising\\n\\nThe third and final step is to transform the evaluation function back into first-order style, using **defunctionalisation**. In particular, rather than using functions of type `Cont` $=$ `Stack -> Stack` for continuations passed as arguments and returned as results, we define a new type that represents the specific forms of continuations that we actually need for our evaluation function.\\n\\nWithin the definitions for `eval\'` and `eval\'\'`, there are only three forms of continuations that are used, namely one to halt the evaluation process, one to push a number onto the top of the stack, and one to add the top two numbers on the stack. We begin by separating out these three forms, by giving them names and passing their variables as parameters. That is, we define three **combinators** for constructing the required forms of continuations:\\n\\n```haskell\\nhaltC :: Cont\\nhaltC = id\\n\\npushC :: Int -> Cont -> Cont\\npushC n c = c . push n\\n\\naddC :: Cont -> Cont\\naddC c = c . add\\n```\\n\\nUsing these combinators, our evaluators can now be rewritten as follows:\\n\\n```haskell\\neval\' :: Expr -> Cont\\neval\' e = eval\'\' e haltC\\n\\neval\'\' :: Expr -> Cont -> Cont\\neval\'\' (Val n)   c = pushC n c\\neval\'\' (Add x y) c = eval\'\' x (eval\'\' y (addC c))\\n```\\n\\nIt is easy to check by expanding definitions that these are equivalent to the previous versions. The next stage in applying defunctionalisation is to define a new type, `Code`, whose constructors represent the three combinators:\\n\\n```haskell\\ndata Code = HALT | PUSH Int Code | ADD Code\\n    deriving Show\\n```\\n\\nThe constructors of this type have the same types as the corresponding combinators, except that the new type `Code` now plays the role of `Cont`:\\n\\n```haskell\\nHALT :: Code\\nPUSH :: Int -> Code -> Code\\nADD  :: Code -> Code\\n```\\n\\nThe name `Code` for the type reflects the fact that its values represent code for a virtual machine that evaluates expressions using a stack. For example, the code `PUSH 1 (PUSH 2 (ADD HALT))` corresponds to the expression $1 + 2$. The fact that values of type `Code` represent continuations of type `Cont` is formalised by defining a function that maps from one to the other:\\n\\n```haskell\\nexec :: Code -> Cont\\nexec HALT       = haltC\\nexec (PUSH n c) = pushC n (exec c)\\nexec (ADD c)    = addC (exec c)\\n```\\n\\nIn turn, we then simplify the definition for `exec` by expanding out the definitions for the type `Cont` and its three combinators.\\n\\n`HALT` case:\\n```haskell\\n  exec HALT s\\n= { applying exec }\\n  haltC s\\n= { applying haltC }\\n  id s\\n= { applying id }\\n  s\\n```\\n\\n`PUSH` case:\\n```haskell\\n  exec (PUSH n c) s\\n= { applying exec }\\n  pushC n (exec c) s\\n= { applying pushC }\\n  (exec c . push n) s\\n= { applying . }\\n  exec c (push n s)\\n= { applying push }\\n  exec c (n : s)\\n```\\n\\n`ADD` case:\\n```haskell\\n  exec (ADD c) s\\n= { applying exec }\\n  addC (exec c) s\\n= { applying addC }\\n  (exec c . add) s\\n= { applying . }\\n  exec c (add s)\\n= { assume s of the form m : n : s\' }\\n  exec c (add (m : n : s\'))\\n= { applying add }\\n  exec c (n+m : s\')\\n```\\n\\nIn conclusion, we have calculated the following definition:\\n\\n```haskell\\nexec :: Code -> Stack -> Stack\\nexec HALT s = s\\nexec (PUSH n c) s = exec c (n : s)\\nexec (ADD c) (m : n : s) = exec c (n+m : s)\\n```\\n\\nThat is, `exec` is a function that executes code using an initial stack to give a final stack. In other words, `exec` is a virtual machine for executing code. \\n\\nFinally, defunctionalisation itself now proceeds by simply replacing occurrences of the combinations `haltC`, `pushC` and `addC` in the evaluation functions `eval\'` and `eval\'\'` by their respective counterparts `HALT`, `PUSH` and `ADD` from the type `Code`, which results in the following two new definitions:\\n\\n```haskell\\ncomp :: Expr -> Code\\ncomp e = comp\' e HALT\\n\\ncomp\' :: Expr -> Code -> Code\\ncomp\' (Val n)   c = PUSH n c\\ncomp\' (Add x y) c = comp\' x (comp\' y (ADD c))\\n```\\n\\nThat is, we have now derived a function `comp` that compiles an expression to code, which is itself defined in terms of an auxiliary function `comp\'` that takes additional code as an extra argument. This is essentially the same compiler that we developed in the previous chapter, except that all the required compilation machinery \u2014 compiler, target language and virtual machine \u2014 has now been systematically derived from a semantics for the source language using equational reasoning. \\n\\nThe only difference is that rather than representing code as a list, we now have a dedicated recursive type for code. For example, `[PUSH 1, PUSH 2, ADD]` is now written as `PUSH 1 (PUSH 2 (ADD HALT))`.\\n\\nThe correctness of the compilation functions `comp` and `comp\'` is captured by the following two equations, which are consequences of defunctionalisation, or can be verified by simple inductive proofs on the expression argument:\\n\\n- `exec (comp e) s` $=$ `eval\' e s`\\n- `exec (comp\' e c) s` $=$ `eval\'\' e (exec c) s`\\n\\nExpanding the right-hand sides of these equations using the original specifications for the functions `eval\'` and `eval\'\'`, we obtain the same compiler correctness equations that were used in the previous chapter:\\n\\n- `exec (comp e) s` $=$ `eval e : s`\\n- `exec (comp\' e c) s` $=$ `exec c (eval e : s)`"},{"id":"reasoning-about-programs","metadata":{"permalink":"/blog/reasoning-about-programs","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09-08-hs-ch16/index.md","source":"@site/blog/2025-09-08-hs-ch16/index.md","title":"Reasoning about programs","description":"In this chapter we introduce the idea of reasoning about Haskell programs. We start by reviewing the notion of equational reasoning, then consider how it can be applied in Haskell, introduce the important technique of induction, show how induction can be used to eliminate uses of the append operator, and conclude by proving the correctness of a simple compiler.","date":"2025-09-08T00:00:00.000Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":27.98,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"reasoning-about-programs","title":"Reasoning about programs","authors":["dream2405"],"tags":["haskell","functional_programming"],"image":"./image.png"},"unlisted":false,"prevItem":{"title":"Calculating compilers","permalink":"/blog/calculating-compilers"},"nextItem":{"title":"Lazy evaluation","permalink":"/blog/lazy-evaluation"}},"content":"In this chapter we introduce the idea of reasoning about Haskell programs. We start by reviewing the notion of equational reasoning, then consider how it can be applied in Haskell, introduce the important technique of induction, show how induction can be used to eliminate uses of the append operator, and conclude by proving the correctness of a simple compiler.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Equational reasoning\\n\\nAt school we learn basic algebraic properties of numbers, such as the fact that multiplication is commutative, addition is associative, and multiplication distributes over addition on both the left- and right-hand sides:\\n\\n$$\\nxy          = yx \\\\\\\\\\nx + (y + z) = (x + y) + z \\\\\\\\\\nx(y + z)    = xy + xz \\\\\\\\\\n(x + y)z    = xz + yz \\\\\\\\\\n$$\\n\\nFor example, using these properties we can show that a product of the form $(x+a)(x+b)$ can be expanded to a summation $x^2+(a+b)x+ab$:\\n\\n$$\\n\\\\begin{aligned}\\n   &(x + a)(x + b) \\\\\\\\\\n=~&\\\\{~left~distributivity~\\\\} \\\\\\\\\\n   &(x + a)x + (x + a)b \\\\\\\\\\n=~&\\\\{~right~distributivity~\\\\} \\\\\\\\\\n   &xx + ax + xb + ab \\\\\\\\\\n=~&\\\\{~squaring~\\\\} \\\\\\\\\\n   &x\xb2 + ax + xb + ab \\\\\\\\\\n=~&\\\\{~commutativity~\\\\} \\\\\\\\\\n   &x\xb2 + ax + bx + ab \\\\\\\\\\n=~&\\\\{~right~distributivity~\\\\} \\\\\\\\\\n   &x\xb2 + (a + b)x + ab\\n\\\\end{aligned}\\n$$\\n\\nNote that in this calculation we follow the common practice of implicitly exploiting associativity properties, in this case the associativity of addition by omitting parentheses when more than one addition is used in sequence.\\n\\nAs well as being interesting in their own right, algebraic properties can also have a computational significance. For example, the expression $x(y+z)$ requires two operations (one multiplication and one addition), whereas the equivalent expression $xy + xz$ requires three operations (two multiplications and one addition). Hence even though these two expressions are algebraically equal, in terms of efficiency the former is preferable to the latter.\\n\\n## Reasoning about Haskell\\n\\nThe same style of equational reasoning can also be used in Haskell. For example, in this context the equation `x * y` $=$ `y * x` means that for any expressions `x` and `y` of the same numeric types, evaluation of `x * y` and `y * x` will always produce the same numeric value. Note that we use the mathematical equality operator $=$ when stating such properties, rather than the equality operator `==` provided within Haskell itself, because we are aiming to use mathematics as a language to reason about Haskell, rather than using Haskell as a language to reason about itself, which would be somewhat circular.\\n\\nWhen reasoning about Haskell, we do not just use properties of built-in operations of the language such as addition and multiplication, but also use the equations from which user-defined functions are constructed. For example, consider the following function that doubles an integer:\\n\\n```haskell\\ndouble :: Int -> Int\\ndouble x = x + x\\n```\\n\\nAs well as being viewed as the **definition** of a function, this equation can also be viewed as a **property** that can be used when reasoning about this function. In particular, as a logical property the above equation states that for any integer expression `x`, the expression `double x` can freely be replaced by `x + x`, and, conversely, that the expression `x + x` can freely be replaced by `double x`. In this manner, when reasoning about programs, function definitions can be both **applied** from left-to-right and **unapplied** from right-to-left.\\n\\nHowever, some care is required when reasoning about functions that are defined using multiple equations. For example, consider a function that decides if an integer is zero, defined using two equations:\\n\\n```haskell\\nisZero :: Int -> Bool\\nisZero 0 = True\\nisZero n = False\\n```\\n\\nThe first equation, `isZero 0 = True`, can freely be viewed as a logical property that can be applied in both directions. However, this is not the case for the second equation, `isZero n = False`. In particular, because the order in which the equations are written is significant in Haskell, an expression of the form `isZero n` can only be replaced by `False` provided that `n` $\u2260$ `0`, as in the case when `n` $=$ `0` the first equation applies. Dually, it is only valid to unapply the equation `isZero n = False` and replace `False` by an expression of the form `isZero n` in the case when `n` $\u2260$ `0`, for the same reason.\\n\\nMore generally, when a function is defined using multiple equations, the equations cannot be viewed as logical properties in isolation from one another, but need to be interpreted in light of the order in which patterns are matched within the equations. For this reason, it is preferable to define functions in a manner that does not rely on the order in which their equations are written. For example, if we rewrite the above definition using a guard\\n\\n```haskell\\nisZero 0          = True\\nisZero n | n /= 0 = False\\n```\\n\\nthen it is now made explicit that `isZero n` can only be replaced by `False`, and conversely that `False` can only be replaced by `isZero n`, when the guard `n /= 0` is satisfied. Patterns that do not rely on the order in which they are matched are called **non-overlapping**. In order to simplify the process of reasoning about programs, it is good practice to use non-overlapping patterns whenever possible when defining functions. For example, most of the functions in the standard prelude given in appendix B are defined in this manner.\\n\\n## Simple examples\\n\\nAs a simple first example of equational reasoning in Haskell, recall the following definition of the library function that reverses a list:\\n\\n```haskell\\nreverse :: [a] -> [a]\\nreverse []      = []\\nreverse (x:xs)  = reverse xs ++ [x]\\n```\\n\\nUsing this definition, we can show that `reverse` has no effect on singleton lists, in the sense that `reverse [x]` $=$ `[x]` for any value `x`:\\n\\n```haskell\\n  reverse [x]\\n= { list notation }\\n  reverse (x : [])\\n= { applying reverse }\\n  reverse [] ++ [x]\\n= { applying reverse }\\n  [] ++ [x]\\n= { applying ++ }\\n  [x]\\n```\\n\\nHence any expression of the form `reverse [x]` in a program can freely be replaced by `[x]` without change in meaning, but with a change in efficiency by avoiding the need to apply the `reverse` function.\\n\\nEquational reasoning is often combined with some form of case analysis. For example, consider the logical negation function:\\n\\n```haskell\\nnot :: Bool -> Bool\\nnot False = True\\nnot True  = False\\n```\\n\\nBecause this function is defined by pattern matching, properties of `not` are normally proved by case analysis on its argument. For example, the fact that `not` is its own inverse, `not (not b)` $=$ `b` for all logical values `b`, can be shown by case analysis on the two possible values for `b`. For example, the case when `b` $=$ `False` is verified below, and `b` $=$ `True` follows similarly:\\n\\n```haskell\\n  not (not False)\\n= { applying the inner not }\\n  not True\\n= { applying not }\\n  False\\n```\\n\\n## Induction on numbers\\n\\nMost interesting Haskell programs involve some form of recursion. Reasoning about such programs normally proceeds using the simple but powerful technique of **induction**. Let us begin by recalling the simplest example of a recursive type, namely the type of natural numbers:\\n\\n```haskell\\ndata Nat = Zero | Succ Nat\\n```\\n\\nThis declaration states that `Zero` is a value of type `Nat` (the base case), and that if `n` is a value of type `Nat`, then so is `Succ n` (the recursive case). Implicit in the declaration is the fact that `Zero` and `Succ` are the only constructors for the type `Nat`. Hence, the values of `Nat` can be enumerated as follows:\\n\\n```\\nZero\\nSucc Zero\\nSucc (Succ Zero)\\nSucc (Succ (Succ Zero))\\n.\\n.\\n.\\n```\\n\\nFor simplicity, we only consider the **finite** natural numbers, obtained by starting with `Zero` and applying `Succ a` finite number of times. In particular, we do not consider the infinite value `Succ (Succ (Succ ...))`, which can be defined recursively by `inf = Succ inf`. A similar comment applies to all the other recursive types that we consider in this chapter.\\n\\nNow suppose we want to prove that some property, `p` say, holds for all (finite) natural numbers. Then the principle of induction states that it is sufficient to show that `p` holds for `Zero`, called the **base case**, and that `p` is preserved by `Succ`, called the **inductive case**. More precisely, in the inductive case one is required to show that if the property `p` holds for any natural number `n`, called the **induction hypothesis**, then it also holds for `Succ n`.\\n\\nWhy is induction sufficient to show that `p` holds for all natural numbers? For example, how does it then follow that `p` holds for `Succ (Succ Zero)`. Starting from the base case that `p` holds for `Zero`, we can apply the inductive case once to conclude that `p` holds for `Succ Zero`, by taking `n` $=$ `Zero`, and then apply the inductive case a second time to conclude that `p` holds for `Succ (Succ Zero)`, by taking `n` $=$ `Succ Zero`. In a similar manner, it can be established that the property `p` holds for any natural number.\\n\\nIt is useful to draw an analogy with the **domino effect**. Suppose there is a line of dominoes standing on end and you know that the first domino will fall, and that whenever a domino falls then its next neighbour will also fall. Then it is clear that all the dominoes will fall, by applying the first fact to get the process started, and repeatedly applying the second to keep it going. The same pattern of reasoning occurs with induction: we first verify the required property for `Zero` (the first domino falls), then that the property is preserved by `Succ` (if any domino falls, then so will its neighbour), and conclude that the property holds for all natural numbers (all dominoes fall).\\n\\nAs a concrete example, consider the definition of a recursive function that takes two natural numbers and adds them together:\\n\\n```haskell\\nadd :: Nat -> Nat -> Nat\\nadd Zero m      = m\\nadd (Succ n) m  = Succ (add n m)\\n```\\n\\nFrom the first equation, it is immediate that `add Zero m` $=$ `m` holds for any natural number `m`. Now let us show that the dual property, `add n Zero` $=$ `n`, which we abbreviate by `p`, also holds for all natural numbers `n`. We proceed by induction on `n`. The base case, showing that `p Zero` holds, amounts to showing that `add Zero Zero` $=$ `Zero`, which is immediate:\\n\\n```haskell\\n  add Zero Zero\\n= { applying add }\\n  Zero\\n```\\n\\nFor the inductive case, we must show that if `p` holds for any natural number `n`, then `p (Succ n)` also holds. That is, using the induction hypothesis `add n Zero` $=$ `n` as an assumption, we must show that the equation `add (Succ n) Zero` $=$ `Succ n` holds, which can be verified as follows:\\n\\n```haskell\\n  add (Succ n) Zero\\n= { applying add }\\n  Succ (add n Zero)\\n= { induction hypothesis }\\n  Succ n\\n```\\n\u25a1\\n\\nBecause proofs by induction normally involve more than one calculation, it is useful to explicitly indicate the end of the proof. For this purpose, we use a square box \u25a1 in the right-hand margin, as illustrated above.\\n\\nAs another example, let us show that addition of natural numbers is associative. That is, `add x (add y z)` $=$ `add (add x y) z` for all `x`, `y` and `z`. There are three variables, so which should induction be performed over? Note that the `add` function is defined by pattern matching on its first argument, so it is natural to try induction on `x`, which appears twice as the first argument to `add` in the associativity equation, whereas `y` only appears once as such and `z` never. Using induction on `x`, the proof of the associativity of `add` proceeds as follows.\\n\\nBase case:\\n```haskell\\n  add Zero (add y z)\\n= { applying the outer add }\\n  add y z\\n= { unapplying add }\\n  add (add Zero y) z\\n```\\n\\nInductive case:\\n```haskell\\n  add (Succ x) (add y z)\\n= { applying the outer add }\\n  Succ (add x (add y z))\\n= { induction hypothesis }\\n  Succ (add (add x y) z)\\n= { unapplying the outer add }\\n  add (Succ (add x y)) z\\n= { unapplying the inner add }\\n  add (add (Succ x) y) z\\n```\\n\u25a1\\n\\nNote that both cases in the proof start by applying definitions, and conclude by unapplying definitions. This pattern is typical in proofs by induction, but the latter part may seem somewhat mysterious at first sight. In particular, knowing which definitions to unapply seems to require a degree of foresight. In practice, however, if one becomes stuck at a certain point during such a calculation, progress can often be made by focusing on the desired end result and trying to work backwards to the point where one became stuck.\\n\\nFor example, after applying the induction hypothesis in the inductive case above to obtain `Succ (add (add x y) z)`, it may not be clear how to proceed, as there are no more definitions that can be applied. However, if we then focus on the expression that we are aiming towards, `add (add (Succ x) y) z`, we can simply apply the inner `add` and then the outer `add` to produce the expression at which we became stuck, which process can then be reversed (turning applying into unapplying) to complete the calculation.\\n\\nAlthough we have introduced induction using the recursive type `Nat`, the same principle can also be used with the type of integers that is built-in to Haskell. In particular, to prove that some property `p` holds for all integers `n` $\u2265$ `0`, it is sufficient to show that `p` holds for `0`, the base case, and that if `p` holds for any `n` $\u2265$ `0`, then it also holds for `n+1`, the inductive case.\\n\\nFor example, consider the following recursive definition for the library function `replicate` that produces a list with `n` identical elements:\\n\\n```haskell\\nreplicate :: Int -> a -> [a]\\nreplicate 0 _ = []\\nreplicate n x = x : replicate (n-1) x\\n```\\n\\nIt is easy to show that this function does indeed produce a list with `n` elements, that is `length (replicate n x)` $=$ `n`, by induction on `n` $\u2265$ `0`.\\n\\nBase case:\\n\\n```haskell\\n  length (replicate 0 x)\\n= { applying replicate }\\n  length []\\n= { applying length }\\n  0\\n```\\n\\nInductive case:\\n\\n```haskell\\n  length (replicate (n+1) x)\\n= { applying replicate }\\n  length (x : replicate n x)\\n= { applying length }\\n  1 + length (replicate n x)\\n= { induction hypothesis }\\n  1 + n\\n= { commutativity of + }\\n  n + 1\\n```\\n\u25a1\\n\\n## Induction on lists\\n\\nInduction is not restricted to natural numbers, but can also be used to reason about other recursive types, such as the type of lists. Just as natural numbers are built up recursively from zero by applying the successor function, so lists are built up from the empty list by applying the cons operator.\\n\\nSuppose we want to prove that some property `p` holds for all lists. Then the induction principle for lists states that it is sufficient to show that `p` holds for the empty list `[]`, the base case, and that if `p` holds for any list `xs`, then it also holds for `x:xs` for any element `x`, the inductive case. Of course, both the element `x` and the list `xs` must be of the appropriate types.\\n\\nAs a first example, let us show that the function `reverse` defined earlier in this chapter is its own inverse, `reverse (reverse xs)`$ =$ `xs`, by induction on `xs`. The base case is verified simply by applying the definition:\\n\\n```haskell\\n  reverse (reverse [])\\n= { applying the inner reverse }\\n  reverse []\\n= { applying reverse }\\n  []\\n```\\n\\nFor the inductive case, using the assumption `reverse (reverse xs)` $=$ `xs`, we show that `reverse (reverse (x:xs))` $=$ `x:xs`, as follows:\\n\\n```haskell\\n  reverse (reverse (x:xs))\\n= { applying the inner reverse }\\n  reverse (reverse xs ++ [x])\\n= { distributivity - see below }\\n  reverse [x] ++ reverse (reverse xs)\\n= { singleton lists - see below }\\n  [x] ++ reverse (reverse xs)\\n= { induction hypothesis }\\n  [x] ++ xs\\n= { applying ++ }\\n  x : xs\\n```\\n\u25a1\\n\\nThe above calculation uses two auxiliary properties of the function `reverse`, namely our earlier result that `reverse` preserves singleton lists, `reverse [x]` $=$ `[x]`, together with a new result that `reverse` distributes over append, except that the order of the two argument lists is then swapped:\\n\\n`reverse (xs ++ ys)` $=$ `reverse ys ++ reverse xs`\\n\\nTechnically, we say that the distribution is **contravariant**. Because the append operator `++` is defined by pattern matching on its first argument, it is natural to attempt to verify this property by induction on `xs`.\\n\\nBase case:\\n```haskell\\n  reverse ([] ++ ys)\\n= { applying ++ }\\n  reverse ys\\n= { identity for ++ }\\n  reverse ys ++ []\\n= { unapplying reverse }\\n  reverse ys ++ reverse []\\n```\\n\\nInductive case:\\n```haskell\\n  reverse ((x:xs) ++ ys)\\n= { applying ++ }\\n  reverse (x : (xs ++ ys))\\n= { applying reverse }\\n  reverse (xs ++ ys) ++ [x]\\n= { induction hypothesis }\\n  (reverse ys ++ reverse xs) ++ [x]\\n= { associativity of ++ }\\n  reverse ys ++ (reverse xs ++ [x])\\n= { unapplying the second reverse }\\n  reverse ys ++ reverse (x:xs)\\n```\\n\u25a1\\n\\nThe above calculations in turn use the fact that `++` is associative with `[]` as its identity, which can be verified by induction in a similar manner to our earlier results concerning `add` and `Zero` (see the exercises section.)\\n\\nWhen we introduced the concept of a functor in chapter 12, we noted that the function `fmap` is required to satisfy two equational laws:\\n\\n- `fmap id`       $=$ `id`\\n- `fmap (g . h)`  $=$ `fmap g . fmap h`\\n\\nAs another example of the use of induction on lists, we now show how these laws can be verified for the list functor, for which purpose we use the following recursive definition for the function `fmap` on lists:\\n\\n```haskell\\nfmap :: (a -> b) -> [a] -> [b]\\nfmap g [] = []\\nfmap g (x:xs) = g x : fmap g xs\\n```\\n\\nBy definition, two functions of the same type are equal if they always return the same results for the same arguments. Hence, to verify the first functor law `fmap id` $=$ `id` for the case of lists, which has the form of an equality between functions, we must show that `fmap id xs` $=$ `id xs` for any list `xs`. Using the definition for the identity function, `id x = x`, this equation simplifies to `fmap id xs` $=$ `xs`, which can then be verified by induction on `xs`.\\n\\nBase case:\\n```haskell\\n  fmap id []\\n= { applying fmap }\\n  []\\n```\\n\\nInductive case:\\n```haskell\\n  fmap id (x : xs)\\n= { applying fmap }\\n  id x : fmap id xs\\n= { applying id }\\n  x : fmap id xs\\n= { induction hypothesis }\\n  x : xs\\n```\\n\u25a1\\n\\nIn turn, for the second functor law we must show that `fmap (g . h) xs` $=$ `(fmap g . fmap h) xs` for any `xs`. Using the definition for function composition, `(f . g) x = f (g x)`, this equation simplifies to `fmap (g . h) xs` $=$ `fmap g (fmap h xs)`, which can then be verified by induction.\\n\\nBase case:\\n```haskell\\n  fmap (g . h) []\\n= { applying fmap }\\n  []\\n= { unapplying fmap }\\n  fmap g []\\n= { unapplying fmap }\\n  fmap g (fmap h [])\\n```\\n\\nInductive case:\\n```haskell\\n  fmap (g . h) (x : xs)\\n= { applying fmap }\\n  (g . h) x : fmap (g . h) xs\\n= { applying . }\\n  g (h x) : fmap (g . h) xs\\n= { induction hypothesis }\\n  g (h x) : fmap g (fmap h xs)\\n= { unapplying fmap }\\n  fmap g (h x : fmap h xs)\\n= { unapplying fmap }\\n  fmap g (fmap h (x : xs))\\n```\\n\u25a1\\n\\nThe exercises for this chapter include a number of other examples of verifying the functor laws, together with the applicative and monad laws.\\n\\n## Making append vanish\\n\\nMany recursive functions are naturally defined using the append operator `++` on lists, but this operator carries a considerable efficiency cost when used recursively. In this section, we show how induction can be used to eliminate such uses of append, and hence make functions more efficient. As a first example, consider again the following simple recursive definition:\\n\\n```haskell\\nreverse :: [a] -> [a]\\nreverse []      = []\\nreverse (x:xs)  = reverse xs ++ [x]\\n```\\n\\nHow efficient is this version of `reverse`? First of all, it is easy to show that the number of reduction steps required to evaluate `xs ++ ys` is one greater than the length of `xs`, assuming for simplicity that both `xs` and `ys` are already fully evaluated. \\n\\nAs a result, we say that `++` takes linear time in the length of its first argument. In turn, the number of steps required by `reverse xs` for a list of length $n$ can be shown to be the sum of the integers from $1$ to $n + 1$, which is $(n+1)(n+2)/2$. Multiplying out the brackets using the equation verified at the start of this chapter gives $(n\xb2 + 3n + 2)/2$, as a result of which we say that `reverse` takes quadratic time in the length of its argument.\\n\\nQuadratic time is bad. For example, reversing a list with ten thousand elements will take approximately fifty million reduction steps. Fortunately, however, through the use of induction it is easy to eliminate the use of append in the definition of `reverse`, and hence improve its efficiency.\\n\\nThe trick is to attempt to define a **more general** function, which combines the behaviours of `reverse` and `++`. In particular, we seek to define a recursive function `reverse\'` that satisfies the following equation:\\n\\n`reverse\' xs ys` $=$ `reverse xs ++ ys`\\n\\nThat is, applying `reverse\'` to two lists should give the result of reversing the first list, appended together with the second list. If we can define such a function, then reverse itself can be redefined by `reverse xs = reverse\' xs []`, using the fact that the empty list is the identity for append.\\n\\nRather than giving the definition for `reverse\'`, and then showing that it satisfies the above equation, we can in fact use this equation as the driving force for **constructing** the definition itself. In particular, we attempt to verify this equation by induction on `xs`. The base case results in an equation that gives the definition for `reverse\' [] ys`, while the inductive case results in an equation that gives the definition for `reverse\' (x:xs) ys`.\\n\\nBase case:\\n```haskell\\n  reverse\' [] ys\\n= { specification of reverse\' }\\n  reverse [] ++ ys\\n= { applying reverse }\\n  [] ++ ys\\n= { applying ++ }\\n  ys\\n```\\n\\nInductive case:\\n```haskell\\n  reverse\' (x:xs) ys\\n= { specification of reverse\' }\\n  reverse (x:xs) ++ ys\\n= { applying reverse }\\n  (reverse xs ++ [x]) ++ ys\\n= { associativity of ++ }\\n  reverse xs ++ ([x] ++ ys)\\n= { induction hypothesis }\\n  reverse\' xs ([x] ++ ys)\\n= { applying ++ }\\n  reverse\' xs (x : ys)\\n```\\n\u25a1\\n\\nWe conclude from this proof that the definition\\n\\n```haskell\\nreverse\' :: [a] -> [a] -> [a]\\nreverse\' []     ys = ys\\nreverse\' (x:xs) ys = reverse\' xs (x : ys)\\n```\\n\\nsuffices to show that `reverse\' xs ys` $=$ `reverse xs ++ ys` by induction. Note that the definition for `reverse\'` does not refer to the original `reverse` function, or append. Hence, `reverse` itself can now be redefined as follows:\\n\\n```haskell\\nreverse :: [a] -> [a]\\nreverse xs = reverse\' xs []\\n```\\n\\nFor example, we have:\\n\\n```haskell\\n  reverse [1,2,3]\\n= { applying reverse }\\n  reverse\' [1,2,3] []\\n= { applying reverse\' }\\n  reverse\' [2,3] (1:[])\\n= { applying reverse\' }\\n  reverse\' [3] (2:(1:[]))\\n= { applying reverse\' }\\n  reverse\' [] (3:(2:(1:[])))\\n= { applying reverse\' }\\n  3:(2:(1:[]))\\n```\\n\\nThat is, the list is reversed by using an extra argument to accumulate the final result. The new definition for `reverse` is perhaps less clear than the original version, but it is much more efficient. In particular, the number of reduction steps required to evaluate `reverse xs` for a list of length $n$ using the new definition is simply $n + 2$, and hence `reverse` now takes linear time in the length of its argument. For example, reversing a list with ten thousand elements will now take approximately ten thousand steps, in contrast to fifty million with the original definition \u2013 quite an improvement!\\n\\nNote that we have already seen the use of accumulation to improve the efficiency of functions, by means of the function `foldl` in chapters 7 and 15. For example, the accumulator version of `reverse` can also be obtained by defining `reverse = foldl (\\\\xs x -> x:xs) []`. However, it is instructive to see how the same kind of behaviour can be obtained using induction.\\n\\nAs another example of the elimination of append, which also illustrates the use of induction on tree-like types, consider the following type of binary trees, together with a function that flattens such trees to a list:\\n\\n```haskell\\ndata Tree = Leaf Int | Node Tree Tree\\n\\nflatten :: Tree -> [Int]\\nflatten (Leaf n) = [n]\\nflatten (Node l r) = flatten l ++ flatten r\\n```\\n\\nBecause of the use of append, the function `flatten` is inefficient. Let us now construct a more efficient version, by using the same trick as for `reverse`. That is, we seek to define a more general function, `flatten\'`, that combines the behaviours of the functions `flatten` and `++`:\\n\\n```haskell\\nflatten\' t ns = flatten t ++ ns\\n```\\n\\nIn order to prove that some property holds for all trees, the induction principle for the type `Tree` states that it is sufficient to show that it holds for all trees of the form `Leaf n`, and that if the property holds for any trees `l` and `r`, then it also holds for `Node l r`. Using this principle, we construct a definition for `flatten\'` that satisfies the above equation as follows.\\n\\nBase case:\\n```haskell\\n  flatten\' (Leaf n) ns\\n= { specification of flatten\' }\\n  flatten (Leaf n) ++ ns\\n= { applying flatten }\\n  [n] ++ ns\\n= { applying ++ }\\n  n : ns\\n```\\n\\nInductive case:\\n```haskell\\n  flatten\' (Node l r) ns\\n= { specification of flatten\' }\\n  (flatten l ++ flatten r) ++ ns\\n= { associativity of ++ }\\n  flatten l ++ (flatten r ++ ns)\\n= { induction hypothesis for l }\\n  flatten\' l (flatten r ++ ns)\\n= { induction hypothesis for r }\\n  flatten\' l (flatten\' r ns)\\n```\\n\u25a1\\n\\nWe conclude that the definition\\n\\n```haskell\\nflatten\' :: Tree -> [Int] -> [Int]\\nflatten\' (Leaf n)   ns = n : ns\\nflatten\' (Node l r) ns = flatten\' l (flatten\' r ns)\\n```\\n\\nsatisfies the specification for `flatten\'`, and hence that the original function `flatten` can now be redefined as follows:\\n\\n```haskell\\nflatten :: Tree -> [Int]\\nflatten t = flatten\' t []\\n```\\n\\nOnce again, the new definition for `flatten` is perhaps less clear than the original version, but is much more efficient, by using an extra argument to accumulate the final result, rather than using append.\\n\\n:::note\\n\\n\uc99d\uba85 \ubd80\ubd84\uc774 \ub2e4\uc18c \ubd88\ud655\uc2e4\ud558\ub2e4. `flatten\'`\uc758 \uac80\uc99d \ubd80\ubd84\uc744 \uc880 \ub354 \ucd94\uac00\ud558\uba74 \uc88b\uaca0\ub2e4.\\n\\nBase case \uac80\uc99d:\\n```haskell\\nflatten\' (Leaf n) ns\\n= { \uc6b0\ub9ac\uc758 \uc815\uc758 }\\nn : ns\\n= { ++ \uc815\uc758 }\\n[n] ++ ns  \\n= { flatten \uc815\uc758 }\\nflatten (Leaf n) ++ ns\\n```\\n\\nInductive case \uac80\uc99d:\\n```haskell\\nflatten\' (Node l r) ns\\n= { \uc6b0\ub9ac\uc758 \uc815\uc758 }\\nflatten\' l (flatten\' r ns)\\n= { \uadc0\ub0a9 \uac00\uc815: flatten\' r ns = flatten r ++ ns }\\nflatten\' l (flatten r ++ ns)\\n= { \uadc0\ub0a9 \uac00\uc815: flatten\' l xs = flatten l ++ xs }\\nflatten l ++ (flatten r ++ ns)\\n= { ++ \uacb0\ud569\ubc95\uce59 }\\n(flatten l ++ flatten r) ++ ns\\n= { flatten \uc815\uc758 }\\nflatten (Node l r) ++ ns\\n```\\n\\n\ub530\ub77c\uc11c \uc8fc\uc5b4\uc9c4 \uac00\uc815\ub300\ub85c\ub77c\uba74\\n- `flatten\' (Leaf n) ns` $=$ `flatten (Leaf n) ns`\\n- `flatten\' (Node l r) ns` $=$ `flatten (Node l r) ns`\\n\\n\uc774\ubbc0\ub85c `flatten\'`\uc758 \uc815\uc758\uac00 \uc62c\ubc14\ub974\ub2e4\uace0 \ud574\uc57c \uc880 \ub354 \ud655\uc2e4\ud55c \uc124\uba85\uc774\ub2e4.\\n\\n:::\\n\\n:::note\\n\\n\uc99d\uba85\uc744 \ud1b5\ud574 \ubc14\ub85c \ud568\uc218 \uc815\uc758\ub97c \ub3c4\ucd9c\ud558\ub294 \uc774\ub7f0 \uae30\ubc95\uc740 equational reasoning(\ub4f1\uc2dd \ucd94\ub860)\uc758 \uc6d0\ub9ac\ub97c \uc774\uc6a9\ud55c \uae30\ubc95\uc774\ub77c \ud560 \uc218 \uc788\ub2e4.\\n1. \ubaa9\ud45c \uba85\uc138: `flatten\' t ns = flatten t ++ ns`\\n2. \ub4f1\uc2dd \ucd94\ub860\uc73c\ub85c \uc804\uac1c: \uac01 \uacbd\uc6b0\uc5d0\uc11c \uc6b0\ubcc0\uc744 \uacc4\uc18d \ubcc0\ud615\\n3. \uc885\ub8cc \uc870\uac74: \uc88c\ubcc0\uacfc \uac19\uc740 \ud615\ud0dc `flatten\' ... ...`\uac00 \ub098\uc62c \ub54c\uae4c\uc9c0\\n4. \uc815\uc758 \uc644\uc131: \uadf8 \ucd5c\uc885 \ud615\ud0dc\ub97c \ud568\uc218 \uc815\uc758\ub85c \uc0ac\uc6a9\\n\\n\uacb0\uad6d \ubaa9\ud45c\ub97c \uc138\uc6b0\uace0, \uadf8 \ubaa9\ud45c\uac00 \uc99d\uba85\ub41c\ub2e4\uba74, \ubaa9\ud45c\uc758 \ubcc0\ud615\uc740 \uacb0\uad6d \ud568\uc218\uc758 \uc815\uc758\ub85c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4\ub294 \uc6d0\ub9ac \uac19\ub2e4.\\n\\n:::\\n\\n## Compiler correctness\\n\\nWe conclude this chapter with an extended example. Recall that in chapter 8 we defined a type of simple arithmetic expressions built up from integers using an addition operator, together with a function (here called `eval`) that evaluates an expression directly to an integer value:\\n\\n```haskell\\ndata Expr = Val Int | Add Expr Expr\\n\\neval :: Expr -> Int\\neval (Val n)    = n\\neval (Add x y)  = eval x + eval y\\n```\\n\\nSuch expressions can also be evaluated indirectly, by means of code that executes using a stack. In this context, a stack is simply a list of integers, and code comprises a list of push and add operations on the stack:\\n\\n```haskell\\ntype Stack = [Int]\\n\\ntype Code = [Op]\\n\\ndata Op = PUSH Int | ADD\\n  deriving Show\\n```\\n\\nThe meaning of such code is given by defining a function that executes a piece of code using an initial stack to give a final stack:\\n\\n```haskell\\nexec :: Code -> Stack -> Stack\\nexec []           s           = s\\nexec (PUSH n : c) s           = exec c (n : s)\\nexec (ADD : c)    (m : n : s) = exec c (n+m : s)\\n```\\n\\nThat is, the push operation places a new integer on the top of the stack, while add replaces the top two integers by their sum. Using these operations, it is now straightforward to define a function that compiles an expression into code. An integer value is compiled by simply pushing that value, while an addition is compiled by first compiling the two argument expressions `x` and `y`, and then adding the resulting two integers on the stack:\\n\\n```haskell\\ncomp :: Expr -> Code\\ncomp (Val n)    = [PUSH n]\\ncomp (Add x y)  = comp x ++ comp y ++ [ADD]\\n```\\n\\nNote that when an add operation is performed, the value of expression `y` will be the top of the stack, and the value of `x` will be the second top, hence the swapping of these two values in the definition of `exec`.\\n\\nTo illustrate the behaviour of the three functions defined above, if we consider an expression that represents $(2 + 3) + 4$, then we have:\\n\\n```haskell\\n> let e = Add (Add (Val 2) (Val 3)) (Val 4)\\n\\n> eval e\\n9\\n\\n> comp e\\n[PUSH 2, PUSH 3, ADD, PUSH 4, ADD]\\n\\n> exec (comp e) []\\n[9]\\n```\\n\\nGeneralising from this example, the correctness of our compiler for expressions can be expressed by the following equation:\\n\\n`exec (comp e) []` $=$ `[eval e]`\\n\\nThat is, compiling an expression and then executing the resulting code using an empty initial stack gives the same final stack as evaluating the expression and then converting the resulting integer into a singleton stack. For the purposes of proving this result, however, we will see that it is necessary to generalise from the empty initial stack to an arbitrary initial stack:\\n\\n`exec (comp e) s` $=$ `eval e : s`\\n\\nUsing induction for the type `Expr`, which is the same as induction for the type `Tree` in the previous section except that the names of the constructors are different, the compiler correctness equation can be verified as follows.\\n\\nBase case:\\n```haskell\\n  exec (comp (Val n)) s\\n= { applying comp }\\n  exec [PUSH n] s\\n= { applying exec }\\n  n : s\\n= { unapplying eval }\\n  eval (Val n) : s\\n```\\n\\nInductive case:\\n```haskell\\n  exec (comp (Add x y)) s\\n= { applying comp }\\n  exec (comp x ++ comp y ++ [ADD]) s\\n= { associativity of ++ }\\n  exec (comp x ++ (comp y ++ [ADD])) s\\n= { distributivity - see below }\\n  exec (comp y ++ [ADD]) (exec (comp x) s)\\n= { induction hypothesis for x }\\n  exec (comp y ++ [ADD]) (eval x : s)\\n= { distributivity again }\\n  exec [ADD] (exec (comp y) (eval x : s))\\n= { induction hypothesis for y }\\n  exec [ADD] (eval y : eval x : s)\\n= { applying exec }\\n  (eval x + eval y) : s\\n= { unapplying eval }\\n  eval (Add x y) : s\\n```\\n\u25a1\\n\\nNote that without having generalised the result to an arbitrary stack, the second induction hypothesis step would not be applicable, because the stack becomes non-empty at this point. The distributivity property used in the inductive case states that executing two pieces of code appended together gives the same result as executing the two pieces of code in sequence:\\n\\n`exec (c ++ d) s` $=$ `exec d (exec c s)`\\n\\nThe proof of this distributivity property proceeds by induction on the code `c`, with the inductive case being split into two separate cases, depending upon whether the first operation in the code is a push or an add.\\n\\nBase case:\\n```haskell\\n  exec ([] ++ d) s\\n= { applying ++ }\\n  exec d s\\n= { unapplying exec }\\n  exec d (exec [] s)\\n```\\n\\nInductive case:\\n```haskell\\n  exec ((PUSH n : c) ++ d) s\\n= { applying ++ }\\n  exec (PUSH n : (c ++ d)) s\\n= { applying exec }\\n  exec (c ++ d) (n : s)\\n= { induction hypothesis }\\n  exec d (exec c (n : s))\\n= { unapplying exec }\\n  exec d (exec (PUSH n : c) s)\\n```\\n\\nInductive case:\\n```haskell\\n  exec ((ADD : c) ++ d) s\\n= { applying ++ }\\n  exec (ADD : (c ++ d)) s\\n= { assume s of the form m : n : s\' }\\n  exec (ADD : (c ++ d)) (m : n : s\')\\n= { applying exec }\\n  exec (c ++ d) (n+m : s\')\\n= { induction hypothesis }\\n  exec d (exec c (n+m : s\'))\\n= { unapplying exec }\\n  exec d (exec (ADD : c) (m : n : s\'))\\n```\\n\u25a1\\n\\nThe stack not having the assumed form in the second inductive case corresponds to a stack **underflow error**. In practice, this will never arise, because the structure of the compiler ensures that the stack will always contain at least two integers at the point when an add operation is performed.\\n\\nIn fact, however, both the distributivity property and its consequent underflow issue can be avoided altogether by applying the technique of the previous section to eliminate the use of append. In particular, we seek to define a generalised function comp\' with the following property:\\n\\n`comp\' e c` $=$ `comp e ++ c`\\n\\nBy induction on `e`, we can construct the definition\\n\\n```haskell\\ncomp\' :: Expr -> Code -> Code\\ncomp\' (Val n)     c = PUSH n : c\\ncomp\' (Add x y) c = comp\' x (comp\' y (ADD : c))\\n```\\n\\nfrom which it follows that we can redefine `comp e = comp\' e []`. In turn, the correctness of the new version of the compiler with respect to our semantics for expressions can now be stated as follows:\\n\\n`exec (comp\' e c) s` $=$ `exec c (eval e : s)`\\n\\nThat is, compiling an expression and then executing the resulting code together with arbitrary additional code gives the same result as executing the additional code with the value of the expression on top of the original stack. The proof of this result is by induction on the expression `e`.\\n\\nBase case:\\n```haskell\\n  exec (comp\' (Val n) c) s\\n= { applying comp\' }\\n  exec (PUSH n : c) s\\n= { applying exec }\\n  exec c (n : s)\\n= { unapplying eval }\\n  exec c (eval (Val n) : s)\\n```\\n\\nInductive case:\\n```haskell\\n  exec (comp\' (Add x y) c) s\\n= { applying comp\' }\\n  exec (comp\' x (comp\' y (ADD : c))) s\\n= { induction hypothesis for x }\\n  exec (comp\' y (ADD : c)) (eval x : s)\\n= { induction hypothesis for y }\\n  exec (ADD : c) (eval y : eval x : s)\\n= { applying exec }\\n  exec c ((eval x + eval y) : s)\\n= { unapplying eval }\\n  exec c (eval (Add x y) : s)\\n```\\n\u25a1\\n\\nNote that with `s` $=$ `c` $=$ `[]`, this new compiler correctness result simplifies to `exec (comp e) []` $=$ `[eval e]`, our original statement of correctness. In addition to avoiding the problem of stack underflow in the correctness proof, the accumulator version of the compiler has two further benefits. First of all, it avoids the use of `++`, and is hence more efficient. And, secondly, the new proof is less than half the combined length of our previous two proofs. As is often the case in formal reasoning, generalising a result in the appropriate manner can considerably simplify its proof. Mathematics is an excellent tool for guiding the development of efficient programs with simple proofs!"},{"id":"lazy-evaluation","metadata":{"permalink":"/blog/lazy-evaluation","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09-05-hs-ch15/index.md","source":"@site/blog/2025-09-05-hs-ch15/index.md","title":"Lazy evaluation","description":"In this chapter we introduce lazy evaluation, the mechanism used to evaluate expressions in Haskell. We start by reviewing the notion of evaluation, then consider evaluation strategies and their properties, discuss infinite structures and modular programming, and conclude with a special form of function application that can improve the space performance of programs.","date":"2025-09-05T00:00:00.000Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":20.24,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"lazy-evaluation","title":"Lazy evaluation","authors":["dream2405"],"tags":["haskell","functional_programming"],"image":"./image-3.png"},"unlisted":false,"prevItem":{"title":"Reasoning about programs","permalink":"/blog/reasoning-about-programs"},"nextItem":{"title":"Foldables and friends","permalink":"/blog/foldables-and-friends"}},"content":"In this chapter we introduce lazy evaluation, the mechanism used to evaluate expressions in Haskell. We start by reviewing the notion of evaluation, then consider evaluation strategies and their properties, discuss infinite structures and modular programming, and conclude with a special form of function application that can improve the space performance of programs.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Introduction\\n\\nAs we have seen throughout this book, the basic method of computation in Haskell is the application of functions to arguments. For example, suppose that we define a function that increments an integer:\\n\\n```haskell\\ninc :: Int -> Int\\ninc n = n + 1\\n```\\n\\nThen the expression `inc (2*3)` can be evaluated as follows:\\n\\n```haskell\\ninc (2*3)\\n= { applying * }\\ninc 6\\n= { applying inc }\\n6 + 1\\n= { applying + }\\n7\\n```\\n\\nAlternatively, the same final result can also be obtained by performing the first two function applications in the opposite order:\\n\\n```haskell\\ninc (2*3)\\n= { applying inc }\\n(2*3) + 1\\n= { applying * }\\n6 + 1\\n= { applying + }\\n7\\n```\\n\\nThe fact that changing the order in which functions are applied does not affect the final result is not specific to simple examples such as the above, but is an important general property of function application in Haskell. More formally, in Haskell any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate. We will return to the issue of termination later on in this chapter.\\n\\nWe also note that the above property does not hold for most imperative programming languages, in which the basic method of computation is changing stored values. For example, consider the imperative expression `n + (n = 1)` that adds the current value of the variable n to the result of changing its value to one. Assuming that n initially has the value zero, this expression can be evaluated by first performing the left-hand side of the addition\\n\\n```haskell\\nn + (n = 1)\\n= { applying n }\\n0 + (n = 1)\\n= { applying = }\\n0 + 1\\n= { applying + }\\n1\\n```\\n\\nor alternatively, by first performing the right-hand side:\\n\\n```haskell\\nn + (n = 1)\\n= { applying = }\\nn + 1\\n= { applying n }\\n1 + 1\\n= { applying + }\\n2\\n```\\n\\nThe final value is different in each case. The general problem illustrated by this example is that the precise time at which an assignment is performed in an imperative language may affect the value that results from a computation. In contrast, the time at which a function is applied to an argument in Haskell never affects the value that results from a computation. Nonetheless, as we shall see in the remainder of this chapter, there are important practical issues concerning the order and nature of the evaluation process.\\n\\n## Evaluation strategies\\n\\nAn expression that has the form of a function applied to one or more arguments that can be \u2018reduced\u2019 by performing the application is called a **reducible expression**, or **redex** for short. As indicated by the use of quotations marks in the preceding sentence, such reductions do not necessarily decrease the size of an expression, although in practice this is often the case.\\n\\nBy way of example, suppose that we define a function `mult` that takes a pair of integers and returns their product:\\n\\n```haskell\\nmult :: (Int,Int) -> Int\\nmult (x,y) = x * y\\n```\\n\\nNow consider the expression mult `(1+2,2+3)`. This expression contains three redexes, namely the sub-expressions `1+2` and `2+3`, which have the form of the addition operator `+` applied to two arguments, and the entire expression itself `mult (1+2,2+3)`, which has the form of the function `mult` applied to a pair of arguments. Performing the corresponding reductions gives the expressions `mult (3,2+3)`, `mult (1+2,5)`, and `(1+2) * (2+3)`.\\n\\nWhen evaluating an expression, in what order should the reductions be performed? One common strategy, known as **innermost evaluation**, is to always choose a redex that is innermost, in the sense that it contains no other redex. If there is more than one innermost redex, by convention we choose the one that begins at the leftmost position in the expression.\\n\\nFor example, both of the sub-expressions `1+2` and `2+3` contain no other redexes and hence innermost within the expression mult `(1+2,2+3)`, with the redex `1+2` beginning at the leftmost position. More generally, our example expression is evaluated using innermost evaluation as follows:\\n\\n```haskell\\n  mult (1+2, 2+3)\\n= { applying the first + }\\n  mult (3, 2+3)\\n= { applying + }\\n  mult (3, 5)\\n= { applying mult }\\n  3 * 5\\n= { applying * }\\n  15\\n```\\n\\nInnermost evaluation can also be characterised in terms of how arguments are passed to functions. In particular, using this strategy ensures that arguments are always fully evaluated before functions are applied. That is, arguments are passed **by value**. For example, as shown above, evaluating `mult (1+2,2+3)` using innermost evaluation proceeds by first evaluating the arguments `1+2` and `2+3`, and then applying `mult`. The fact that we always choose the leftmost innermost redex ensures that the first argument is evaluated before the second.\\n\\nAnother common strategy for evaluating an expression, dual to innermost evaluation, is to always choose a redex that is outermost, in the sense that it is contained in no other redex. If there is more than one such redex then as previously we choose that which begins at the leftmost position. Not surprisingly, this evaluation strategy is known as **outermost evaluation**.\\n\\nFor example, the expression `mult (1+2,2+3)` is contained in no other redex and is hence outermost within itself. More generally, evaluating this expression using outermost evaluation proceeds as follows:\\n\\n```haskell\\n  mult (1+2, 2+3)\\n= { applying mult }\\n  (1+2) * (2+3)\\n= { applying the first + }\\n  3 * (2+3)\\n= { applying + }\\n  3 * 5\\n= { applying * }\\n  15\\n```\\n\\nIn terms of how arguments are passed to functions, using outermost evaluation allows functions to be applied before their arguments are evaluated. For this reason, we say that arguments are passed **by name**. For example, as shown above, evaluating `mult (1+2,2+3)` using outermost evaluation proceeds by first applying the function mult to the two unevaluated arguments `1+2` and `2+3`, and then evaluating these two expressions in turn.\\n\\nWe conclude this section by noting that many built-in functions require their arguments to be evaluated before being applied, even when using outermost evaluation. For example, as illustrated in the calculation above, built-in arithmetic operators such as `*` and `+` cannot be applied until their two arguments have been evaluated to numbers. Functions with this property are called **strict**, and will be discussed in further detail at the end of this chapter.\\n\\n### Lambda expressions\\n\\nLet us now define a curried version of `mult` that takes its arguments one at a time, using a lambda expression to make the use of currying explicit:\\n\\n```haskell\\nmult :: Int -> Int -> Int\\nmult x = \\\\y -> x * y\\n```\\n\\nThen using innermost evaluation, for example, we have:\\n\\n```haskell\\n  mult (1+2) (2+3)\\n= { applying the first + }\\n  mult 3 (2+3)\\n= { applying mult }\\n  (\\\\y -> 3 * y) (2+3)\\n= { applying + }\\n  (\\\\y -> 3 * y) 5\\n= { applying the lambda }\\n  3 * 5\\n= { applying * }\\n  15\\n```\\n\\nThat is, the two arguments are now substituted into the body of the function `mult` one at a time, as we would expect using currying, rather than at the same time as in the previous section. This behaviour arises because `mult 3` is the leftmost innermost redex in the expression `mult 3 (2+3)`, as opposed to `2+3` in the expression `mult (3,2+3)`. Performing a reduction on `mult 3` in the second step of the calculation above gives the lambda expression `\\\\y -> 3 * y`, which awaits the result of evaluating the second argument.\\n\\nNote that in Haskell, the selection of redexes within the bodies lambda expressions is prohibited. The rationale for not \u2018reducing under lambdas\u2019 is that functions are viewed as black boxes that we are not permitted to look inside. More formally, the only operation that can be performed on a function is that of applying it to an argument. As such, reduction within the body of a function is only permitted once the function has been applied.\\n\\nFor example, the function `\\\\x -> 1 + 2` is deemed to already be fully evaluated, even though its body contains the redex `1 + 2`, but once this function has been applied to an argument, evaluation of this redex can then proceed:\\n\\n```haskell\\n  (\\\\x -> 1 + 2) 0\\n= { applying the lambda }\\n  1 + 2\\n= { applying + }\\n  3\\n```\\n\\nUsing innermost and outermost evaluation, but not within lambda expressions, is normally referred to as **call-by-value** and **call-by-name** evaluation, respectively. In the next two sections we explore how these two evaluation strategies compare in terms of two important properties, namely their termination behaviour and the number of reduction steps that they require.\\n\\n:::note\\n\\n\ud604\ub300 \ud504\ub85c\uadf8\ub798\ubc0d\uc5d0\uc11c\ub294 \ub450 \uc6a9\uc5b4 pass-by-value\uc640 call-by-value\ub97c \uac70\uc758 \uac19\uc740 \uc758\ubbf8\ub85c \ud63c\uc6a9\ud558\uc9c0\ub9cc, \uc5c4\ubc00\ud788 \ub530\uc9c0\uba74 \uc57d\uac04\uc758 \uad00\uc810 \ucc28\uc774\uac00 \uc788\ub2e4.\\n\\n- pass-by-value: \ud568\uc218\uac00 \uc801\uc6a9\ub418\uae30 \uc804\uc5d0 \uc778\uc790\uac00 \ud56d\uc0c1 \uc644\uc804\ud788 \ud3c9\uac00\ub418\uc57c \ud568\\n    - \ud568\uc218\uc5d0 \uc778\uc790\ub97c \uc804\ub2ec\ud558\ub294 **\uba54\ucee4\ub2c8\uc998**\uc5d0 \ucd08\uc810\uc744 \ub9de\ucd98, \ubcf4\ub2e4 \uad6c\uccb4\uc801\uc774\uace0 \uae30\uc220\uc801\uc778 \uc124\uba85\\n- call-by-value: \ub78c\ub2e4 \ud45c\ud604\uc2dd \ub0b4\ubd80\ub97c \ucd95\uc57d\ud558\uc9c0 \uc54a\ub294 \ubc29\uc2dd\uc758 innermost evaluation\\n    - \ud504\ub85c\uadf8\ub7a8\uc758 **\ud3c9\uac00 \uc804\ub7b5(Evaluation Strategy)** \uc5d0 \ucd08\uc810\uc744 \ub9de\ucd98, \ubcf4\ub2e4 \ucd94\uc0c1\uc801\uc774\uace0 \uc774\ub860\uc801\uc778 \uac1c\ub150\\n\\n\uc989, call-by-value \ub77c\ub294 \ud3c9\uac00 \uc804\ub7b5\uc744 \uad6c\ud604\ud558\ub294 \uac00\uc7a5 \uc77c\ubc18\uc801\uc778 \ubc29\ubc95\uc774 \ubc14\ub85c pass-by-value \uba54\ucee4\ub2c8\uc998\uc774\ub2e4.\\n\\n:::\\n\\n## Termination\\n\\nConsider the following recursive definition:\\n\\n```haskell\\ninf :: Int\\ninf = 1 + inf\\n```\\n\\nThat is, the integer `inf` (abbreviating infinity) is defined as the successor of itself. Evaluating inf produces a larger and larger expression, regardless of the evaluation strategy, and hence does not terminate:\\n\\n```haskell\\n  inf\\n= { applying inf }\\n  1 + inf\\n= { applying inf }\\n  1 + (1 + inf)\\n= { applying inf }\\n  1 + (1 + (1 + inf))\\n= { applying inf }\\n  \u22ee\\n```\\n\\nNow consider the expression `fst (0,inf)` that contains the value `inf`, where `fst` is the library function that selects the first component of a pair, defined by `fst (x,y) = x`. Using call-by-value evaluation with this expression results in non-termination in a similar manner to `inf` itself:\\n\\n```haskell\\n  fst (0, inf)\\n= { applying inf }\\n  fst (0, 1 + inf)\\n= { applying inf }\\n  fst (0, 1 + (1 + inf))\\n= { applying inf }\\n  fst (0, 1 + (1 + (1 + inf)))\\n= { applying inf }\\n  \u22ee\\n```\\n\\nIn contrast, using call-by-name evaluation results in termination with the result zero in just one step, by immediately applying the definition of `fst` and hence avoiding the evaluation of the non-terminating expression `inf`:\\n\\n```haskell\\n  fst (0, inf)\\n= { applying fst }\\n  0\\n```\\n\\nThis simple example shows that call-by-name evaluation may produce a result when call-by-value evaluation fails to terminate. More generally, we have the following important property: if there exists any evaluation sequence that terminates for a given expression, then call-by-name evaluation will also terminate for this expression, and produce the same final result.\\n\\nIn summary, call-by-name evaluation is preferable to call-by-value for the purpose of ensuring that evaluation terminates as often as possible.\\n\\n## Number of reductions\\n\\nNow consider the following definition:\\n\\n```haskell\\nsquare :: Int -> Int\\nsquare n = n * n\\n```\\n\\nFor example, using call-by-value evaluation, we have:\\n\\n```haskell\\n  square (1+2)\\n= { applying + }\\n  square 3\\n= { applying square }\\n  3 * 3\\n= { applying * }\\n  9\\n```\\n\\nIn contrast, using call-by-name evaluation requires one extra reduction step, due to the fact that the argument expression `1+2` is duplicated when the function `square` is applied, and hence must be evaluated twice:\\n\\n```haskell\\n  square (1+2)\\n= { applying square }\\n  (1+2) * (1+2)\\n= { applying the first + }\\n  3 * (1+2)\\n= { applying + }\\n  3 * 3\\n= { applying * }\\n  9\\n```\\n\\nThis example shows that call-by-name evaluation may require more reduction steps than call-by-value evaluation, in particular when an argument is used more than once in the body of a function. More generally, we have the following property: arguments are evaluated precisely once using call-by-value evaluation, but may be evaluated many times using call-by-name.\\n\\nFortunately, the above efficiency problem with call-by-name evaluation can easily be solved, by using pointers to indicate sharing of expressions during evaluation. That is, rather than physically copying an argument if it is used many times in the body of a function, we simply keep one copy of the argument and make many pointers to it. In this manner, any reductions that are performed on the argument are automatically shared between each of the pointers to that argument. For example, using this strategy we have:\\n\\n![img2](image.png)\\n![img3](image-1.png)\\n\\nThat is, when applying the definition `square n = n * n` in the first step, we keep a single copy of the argument expression `1+2`, and make two pointers to it. In this manner, when the expression `1+2` is reduced in the second step, both pointers in the expression share the result.\\n\\nThe use of call-by-name evaluation in conjunction with sharing is known as **lazy evaluation**. This is the evaluation strategy that is used in Haskell, as a result of which Haskell is known as a lazy programming language. Being based upon call-by-name evaluation, lazy evaluation has the property that it ensures that evaluation terminates as often as possible. Moreover, using sharing ensures that lazy evaluation never requires more steps than call-by-value evaluation. The use of the term \u2018lazy\u2019 will be explained in the next section.\\n\\n## Infinite structures\\n\\nAn additional property of call-by-name evaluation, and hence lazy evaluation, is that it allows what at first may seem impossible: programming with infinite structures. We have already seen a simple example of this idea earlier in this chapter, in the form of the evaluation of `fst (0,inf)` avoiding the production of the infinite structure `1 + (1 + (1 + ...))` defined by `inf`.\\n\\nMore interesting forms of behaviour occur when we consider infinite lists. For example, consider the following recursive definition:\\n\\n```haskell\\nones :: [Int]\\nones = 1 : ones\\n```\\n\\nThat is, the list `ones` is defined as a single one followed by itself. As with `inf`, evaluating ones does not terminate, regardless of the strategy used:\\n\\n```haskell\\n  ones\\n= { applying ones }\\n  1 : ones\\n= { applying ones }\\n  1 : (1 : ones)\\n= { applying ones }\\n  1 : (1 : (1 : ones))\\n= { applying ones }\\n  ...\\n```\\n\\nIn practice, evaluating `ones` using GHCi will produce a never-ending list of ones, until the user eventually decides to terminate this process:\\n\\n```haskell\\n> ones\\n[1,1,1,1,1,1,1,1,1,1,...\\n```\\n\\nNow consider the expression `head ones`, where `head` is the library function that selects the first element of a list, defined by head `(x:_) = x`. Using call-by-value evaluation in this case also results in non-termination:\\n\\n```haskell\\n  head ones\\n= { applying ones }\\n  head (1 : ones)\\n= { applying ones }\\n  head (1 : (1 : ones))\\n= { applying ones }\\n  head (1 : (1 : (1 : ones)))\\n= { applying ones }\\n  ...\\n```\\n\\nIn contrast, using lazy evaluation (or call-by-name evaluation, as sharing is not required in this example) results in termination in two steps:\\n\\n```haskell\\n  head ones\\n= { applying ones }\\n  head (1 : ones)\\n= { applying head }\\n  1\\n```\\n\\nThis behaviour arises because lazy evaluation proceeds in a lazy manner as its name suggests, only evaluating arguments as and when this is strictly necessary in order to produce results. For example, when selecting the first element of a list, the remainder of the list is not required, and hence in `head (1 : ones)` the further evaluation of the infinite list `ones` is avoided. More generally, we have the following property: using lazy evaluation, expressions are only evaluated as much as required by the context in which they are used.\\n\\nUsing this idea, we now see that under lazy evaluation `ones` is not an infinite list as such, but rather a **potentially infinite** list, which is only evaluated as much as required by the context. This idea is not restricted to lists, but applies equally to any form of data structure in Haskell. For example, infinite trees are considered in the exercises for this chapter.\\n\\n## Modular programming\\n\\nLazy evaluation also allows us to separate **control** from **data** in our computations. For example, a list of three ones can be produced by selecting the first three elements (control) of the infinite list of ones (data):\\n\\n```haskell\\n> take 3 ones\\n[1,1,1]\\n```\\n\\nUsing the definition of `take` from the standard prelude\\n\\n```haskell\\ntake 0 _ = []\\ntake _ [] = []\\ntake n (x:xs) = x : take (n-1) xs\\n```\\n\\nthis behaviour arises using lazy evaluation as follows:\\n\\n```haskell\\n  take 3 ones\\n= { applying ones }\\n  take 3 (1 : ones)\\n= { applying take }\\n  1 : take 2 ones\\n= { applying ones }\\n  1 : take 2 (1 : ones)\\n= { applying take }\\n  1 : 1 : take 1 ones\\n= { applying ones }\\n  1 : 1 : take 1 (1 : ones)\\n= { applying take }\\n  1 : 1 : 1 : take 0 ones\\n= { applying take }\\n  1 : 1 : 1 : []\\n= { list notation }\\n  [1,1,1]\\n```\\n\\nThat is, the data is only evaluated as much as required by the control, and these two parts take it in turn to perform reductions. Without lazy evaluation, the control and data parts would need to be combined in the form of a single function that produces a list of `n` identical elements, such as:\\n\\n```haskell\\nreplicate :: Int -> a -> [a]\\nreplicate 0 _ = []\\nreplicate n x = x : replicate (n-1) x\\n```\\n\\nBeing able to modularise programs by separating them into logically distinct parts is an important goal in programming, and being able to separate control from data is one of the most important benefits of lazy evaluation.\\n\\nNote that care is still required when programming with infinite lists, to avoid non-termination. For example, the expression\\n\\n```haskell\\nfilter (<= 5) [1..]\\n```\\n\\n(where `[n..]` produces the infinite list of integers beginning with `n`) will produce the integers $1, 2, 3, 4, 5$ and then loop forever, because the function `filter (<= 5)` keeps testing elements of the infinite list in a vain attempt to find another that is less than or equal to five. \\n\\nIn contrast, the expression\\n\\n```haskell\\ntakeWhile (<= 5) [1..]\\n```\\n\\nwill produce the same integers and then terminate, because `takeWhile (<= 5)` stops as soon as it finds an element that is greater than five.\\n\\nWe conclude this section with an example concerning prime numbers. Recall that in chapter 5, we wrote a function to generate prime numbers up to a given limit. In contrast, here is a simple procedure for generating the infinite sequence of all prime numbers, as opposed to a finite prefix of this sequence:\\n\\n1. write down the infinite sequence $2, 3, 4, 5, 6, ...$;\\n2. mark the first number, $p$, in the sequence as prime;\\n3. delete all multiples of $p$ from the sequence;\\n4. return to the second step.\\n\\nNote that the first and third steps each require an infinite amount of work, and hence in practice the steps must be interleaved. The first few iterations of this procedure can be illustrated as follows:\\n\\n![img4](image-2.png)\\n\\nEach row corresponds to one iteration of the procedure, with the first row being the initial sequence (step two), the first number in each row being circled to indicate its primality (step two), and all multiples of this number being underlined to indicate their deletion (step three) prior to the next iteration. In this manner, we can imagine the initial sequence of numbers falling downwards, with certain numbers being sieved out at each stage by the underlining, and the circled numbers forming the infinite sequence of primes:\\n\\n$$\\n2, 3, 5, 7, 11, 13, ...\\n$$\\n\\nThe above procedure for generating prime numbers is known as the **sieve of Eratosthenes**, after the Greek mathematician who first described it. This procedure can be translated directly into Haskell:\\n\\n```haskell\\nprimes :: [Int]\\nprimes = sieve [2..]\\n\\nsieve :: [Int] -> [Int]\\nsieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\\n```\\n\\nThat is, starting with the infinite list `[2..]` (step one), we apply the function `sieve` that retains the first number `p` as being prime (step two), and then calls itself recursively with a new list obtained by filtering all multiples of `p` from this list (steps three and four). Lazy evaluation ensures that this program does indeed produce the infinite list of all prime numbers:\\n\\n```haskell\\n> primes\\n[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,...\\n```\\n\\nBy freeing the generation of prime numbers from the constraint of finiteness, we have obtained a modular program on which different control parts can be used in different situations. For example, the first ten prime numbers, and the prime numbers less than ten, can be produced as follows:\\n\\n```haskell\\n> take 10 primes\\n[2,3,5,7,11,13,17,19,23,29]\\n\\n> takeWhile (< 10) primes\\n[2,3,5,7]\\n```\\n\\n## Strict application\\n\\nHaskell uses lazy evaluation by default, but also provides a special **strict** version of function application, written as `$!`, which can sometimes be useful. Informally, an expression of the form `f $! x` behaves in the same way as the normal functional application `f x`, except that the top-level of evaluation of the argument expression `x` is forced before the function `f` is applied.\\n\\nFor example, if the argument has a basic type, such as `Int` or `Bool`, then top-level evaluation is simply complete evaluation. On the other hand, for a pair type such as `(Int,Bool)`, evaluation is performed until a pair of expressions is obtained, but no further. Similarly, for a list type, evaluation is performed until the empty list or the cons of two expressions is obtained.\\n\\nMore formally, an expression of the form `f $! x` is only a redex once evaluation of the argument `x`, using lazy evaluation as normal, has reached the point where it is known that the result is not an undefined value, at which point the expression can be reduced to the normal application `f x`. For example, using the definition `square n = n * n`, evaluation of the application `square $! (1+2)` proceeds in a call-by-value manner, by first evaluating the argument expression `1+2` to give the value `3`, and then applying the function `square`:\\n\\n```haskell\\n  square $! (1+2)\\n= { applying + }\\n  square $! 3\\n= { applying $! }\\n  square 3\\n= { applying square }\\n  3 * 3\\n= { applying * }\\n  9\\n```\\n\\nWhen used with a curried function with multiple arguments, strict application can be used to force top-level evaluation of any combination of arguments. For example, if `f` is a curried function with two arguments, an application of the form `f x y` can be modified to have three different behaviours:\\n\\n- `(f $! x) y` forces top-level evaluation of `x`\\n\\n- `f x $! y` forces top-level evaluation of `y`\\n\\n- `(f $! x) $! y` forces top-level evaluation of `x` and `y`\\n\\nIn Haskell, strict application is mainly used to improve the space performance of programs. For example, consider a function `sumwith` that calculates the sum of a list of integers using an accumulator value:\\n\\n```haskell\\nsumwith :: Int -> [Int] -> Int\\nsumwith v [] = v\\nsumwith v (x:xs) = sumwith (v+x) xs\\n```\\n\\nThen, using lazy evaluation, we have:\\n\\n```haskell\\n  sumwith 0 [1,2,3]\\n= { applying sumwith }\\n  sumwith (0+1) [2,3]\\n= { applying sumwith }\\n  sumwith ((0+1)+2) [3]\\n= { applying sumwith }\\n  sumwith (((0+1)+2)+3) []\\n= { applying the first + }\\n  sumwith ((1)+2)+3\\n= { applying the first + }\\n  sumwith (3)+3\\n= { applying + }\\n  6\\n```\\n\\nNote that the entire summation `((0+1)+2)+3` is constructed before any of the component additions are actually performed. More generally, `sumwith` will construct a summation whose size is proportional to the number of integers in the original list, which for a long list may require a significant amount of space. \\n\\nIn practice, it would be preferable to perform each addition as soon as it is introduced, to improve the space performance of the function. This behaviour can be achieved by redefining sumwith using strict application, to force evaluation of its accumulator value:\\n\\n```haskell\\nsumwith v [] = v\\nsumwith v (x:xs) = (sumwith $! (v+x)) xs\\n```\\n\\nFor example, we now have:\\n\\n```haskell\\n  sumwith 0 [1,2,3]\\n= { applying sumwith }\\n  (sumwith $! (0+1)) [2,3]\\n= { applying + }\\n  (sumwith $! 1) [2,3]\\n= { applying $! }\\n  sumwith 1 [2,3]\\n= { applying sumwith }\\n  (sumwith $! (1+2)) [3]\\n= { applying + }\\n  (sumwith $! 3) [3]\\n= { applying $! }\\n  sumwith 3 [3]\\n= { applying sumwith }\\n  (sumwith $! (3+3)) []\\n= { applying + }\\n  (sumwith $! 6) []\\n= { applying $! }\\n  sumwith 6 []\\n= { applying sumwith }\\n  6\\n```\\n\\nThis evaluation requires more steps than previously, due to the additional overhead of using strict application, but now performs each addition as soon as it is introduced, rather than constructing a large summation.\\n\\nGeneralising from the above example, the library `Data.Foldable` provides a strict version of the higher-order library function `foldl` that forces evaluation of its accumulator prior to processing the tail of the list:\\n\\n```haskell\\nfoldl\' :: (a -> b -> a) -> a -> [b] -> a\\nfoldl\' f v [] = v\\nfoldl\' f v (x:xs) = ((foldl\' f) $! (f v x)) xs\\n```\\n\\nFor example, using this function we can define `sumwith = foldl\' (+)`. It is important to note, however, that strict application is not a silver bullet that automatically improves the space behaviour of Haskell programs. Even for relatively simple examples, the use of strict application is a specialist topic that requires careful consideration of the behaviour of lazy evaluation."},{"id":"foldables-and-friends","metadata":{"permalink":"/blog/foldables-and-friends","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09-04-hs-ch14/index.md","source":"@site/blog/2025-09-04-hs-ch14/index.md","title":"Foldables and friends","description":"banner","date":"2025-09-04T00:00:00.000Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":17.36,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"foldables-and-friends","title":"Foldables and friends","authors":["dream2405"],"tags":["haskell","functional_programming"],"image":"./image.png"},"unlisted":false,"prevItem":{"title":"Lazy evaluation","permalink":"/blog/lazy-evaluation"},"nextItem":{"title":"An Introduction to wait-free algorithms","permalink":"/blog/intro-wait-free-algorithms"}},"content":"![banner](./image.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n\uc774 \uae00\uc5d0\uc11c\ub294 \ud558\uc2a4\ucf08\uc5d0\uc11c \ub370\uc774\ud130 \uad6c\uc870\uc758 \uac12\ub4e4\uc744 \ucc98\ub9ac\ud558\ub294 \uc138 \uac00\uc9c0 \uc77c\ubc18\uc801\uc778 \ud328\ud134\uc744 \uc18c\uac1c\ud55c\ub2e4. \uba3c\uc800 \uac12\uc744 \uacb0\ud569\ud558\ub294 \ub370 \uacb0\ud569 \uc5f0\uc0b0\uc790(associative operator)\ub97c \uc0ac\uc6a9\ud558\ub294 **\ubaa8\ub178\uc774\ub4dc(monoids)** \ub85c \uc2dc\uc791\ud574, \uadf8 \ub2e4\uc74c\uc73c\ub85c \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c \ud3f4\ub529(folding) \uac1c\ub150\uc744 \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc73c\ub85c \uc77c\ubc18\ud654\ud558\ub294 **\ud3f4\ub354\ube14(foldables)** \uc744 \uc0b4\ud3b4\ubcf4\uace0, \ub9e4\ud551(mapping)\uc758 \uac1c\ub150\uc744 \ub354\uc6b1 \uc77c\ubc18\ud654\ud558\ub294 **\ud2b8\ub798\ubc84\uc11c\ube14(traversables)** \ub85c \ub9c8\ubb34\ub9ac\ud560 \uac83\uc774\ub2e4.\\n\\n## Monoids\\n\uc218\ud559\uc5d0\uc11c \ubaa8\ub178\uc774\ub4dc\ub780 \uc9d1\ud569\uc758 \ub450 \uc6d0\uc18c\ub97c \uacb0\ud569\ud558\ub294 \uacb0\ud569 \uc5f0\uc0b0\uc790(associative operator)\uc640, \uadf8 \uc5f0\uc0b0\uc790\uc5d0 \ub300\ud55c \ud56d\ub4f1\uc6d0(identity element)\uc744 \uac16\ucd98 \uc9d1\ud569\uc774\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \uc815\uc218 \uc9d1\ud569\uc740 \ub367\uc148 \uc5f0\uc0b0\uacfc \ud56d\ub4f1\uc6d0\uc778 0\uc73c\ub85c \ubaa8\ub178\uc774\ub4dc\ub97c \ud615\uc131\ud55c\ub2e4. \\n\\n\ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \ubaa8\ub178\uc774\ub4dc\uc758 \uac1c\ub150\uc774 \ub2e4\uc74c\uacfc \uac19\uc740 \ub0b4\uc7a5 \ud074\ub798\uc2a4 \uc120\uc5b8\uc73c\ub85c \uad6c\ud604\ub41c\ub2e4.\\n\\n```haskell\\nclass Monoid a where\\n    mempty  :: a\\n    mappend :: a -> a -> a\\n\\n    mconcat :: [a] -> a\\n    mconcat = foldr mappend mempty\\n```\\n\uc989, \uc5b4\ub5a4 \ud0c0\uc785\uc774 `Monoid` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub418\ub824\uba74, \ubaa8\ub178\uc774\ub4dc\uc758 \ud56d\ub4f1\uc6d0\uacfc \uacb0\ud569 \uc5f0\uc0b0\uc790\uc758 \uc5ed\ud560\uc744 \uc218\ud589\ud558\ub294 `mempty` \uac12\uacfc `mappend` \ud568\uc218\ub97c \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc2e4\uc81c \ucf54\ub4dc\uc5d0\uc11c\ub294 `mappend` \ud568\uc218 \uc591\ucabd\uc5d0 \uc5ed\ub530\uc634\ud45c(back quote)\ub97c \ubd99\uc5ec ``x `mappend` y``\uc640 \uac19\uc774 \uc911\uc704(infix) \uc5f0\uc0b0\uc790\ub85c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0\uac00 \ub9ce\ub2e4.\\n\\n`Monoid` \ud074\ub798\uc2a4\ub294 \uc774 \ub450 \uac00\uc9c0 \uae30\ubcf8 \uc694\uc18c \uc678\uc5d0\ub3c4, \ub9ac\uc2a4\ud2b8\uc758 \uac01 cons\ub97c `mappend`\ub85c, \ube44\uc5b4\uc788\ub294 \ub9ac\uc2a4\ud2b8(`[]`)\ub97c `mempty`\ub85c \ub300\uccb4\ud558\uc5ec \ub9ac\uc2a4\ud2b8\uc758 \uac12\ub4e4\uc744 \ubaa8\ub450 \uacb0\ud569\ud558\ub294 `mconcat` \ud568\uc218\ub3c4 \uae30\ubcf8 \uc815\uc758\ub85c \uc81c\uacf5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, `[x,y,z]` \ud615\ud0dc\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 mconcat\uc744 \uc801\uc6a9\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n``x `mappend` (y `mappend` (z `mappend` mempty))``\\n\\n\uc218\ud559\uc5d0\uc11c\uc640 \ub9c8\ucc2c\uac00\uc9c0\ub85c, `Monoid` \ud074\ub798\uc2a4\uc758 \ub450 \uae30\ubcf8 \uc694\uc18c\ub294 \ub2e4\uc74c\uc758 \ud56d\ub4f1 \ubc95\uce59\uacfc \uacb0\ud569 \ubc95\uce59\uc744 \ubc18\ub4dc\uc2dc \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4.\\n- ``mempty `mappend` x`` = `x`\\n- ``x `mappend` mempty`` = `x`\\n- ``x `mappend` (y `mappend` z)`` = ``(x `mappend` y) `mappend` z``\\n\\n\uc608\ub97c \ub4e4\uc5b4, \uc774 \ubc95\uce59\ub4e4\uc744 \uc0ac\uc6a9\ud558\uba74 `mconcat [x,y,z]`\uc758 \uacb0\uacfc\ub294 \ub354 \uac04\ub2e8\ud55c \ud615\ud0dc\ub85c \uc791\uc131\ub420 \uc218 \uc788\ub2e4. \ubaa8\ub178\uc774\ub4dc \ubc95\uce59\uc740 \uad04\ud638\ub098 `mempty`\uac00 \uacb0\uacfc\uc5d0 \uc601\ud5a5\uc744 \uc8fc\uc9c0 \uc54a\uc74c\uc744 \ubcf4\uc7a5\ud558\ubbc0\ub85c, \uc774\ub97c \uc0dd\ub7b5\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nx `mappend` y `mappend` z\\n```\\n:::info\\n\\n\ud5a5\ud6c4 \ud558\uc2a4\ucf08\uc758 `Monoid` \ud074\ub798\uc2a4\ub294 \ub450 \uac1c\uc758 \uac1c\ubcc4 \ud074\ub798\uc2a4\ub85c \ub098\ub260 \uc218\ub3c4 \uc788\ub2e4.  \\n\ud558\ub098\ub294 \uacb0\ud569 \uc5f0\uc0b0\uc790\ub97c \uc81c\uacf5\ud558\ub294 \ud074\ub798\uc2a4\uc774\uace0, \ub2e4\ub978 \ud558\ub098\ub294 \ud56d\ub4f1\uc6d0\uc744 \uc81c\uacf5\ud558\ub294 \ud074\ub798\uc2a4\uc774\ub2e4.\\n\\n:::\\n\\n### Examples\\n\\n`Data.Monoid` \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0\ub294 \uc5ec\ub7ec \ud45c\uc900 \ubaa8\ub178\uc774\ub4dc\uac00 \uc81c\uacf5\ub41c\ub2e4. \uac00\uc7a5 \uac04\ub2e8\ud55c \uc608\ub294 \ub9ac\uc2a4\ud2b8 \ubaa8\ub178\uc774\ub4dc\uc778\ub370, \uc5ec\uae30\uc11c `mempty`\uc640 `mappend`\ub294 \uac01\uac01 \ube48 \ub9ac\uc2a4\ud2b8\uc640 \ub9ac\uc2a4\ud2b8 \uacb0\ud569 \uc5f0\uc0b0\uc790\ub85c \uad6c\ud604\ub41c\ub2e4\\n```haskell\\ninstance Monoid [a] where\\n    -- mempty :: [a]\\n    mempty = []\\n  \\n    -- mappend :: [a] -> [a] -> [a]\\n    mappend = (++)\\n```\\n:::note\\n\\n\uba54\uc11c\ub4dc\uc758 \uc774\ub984 `mempty`\uc640 `mappend`\ub294 \uc774 \uc778\uc2a4\ud134\uc2a4\uc5d0\uc11c \ub530\uc628 \uac83\uc774\uc9c0\ub9cc, \uc77c\ubc18\uc801\uc73c\ub85c \ubaa8\ub178\uc774\ub4dc\uc758 \uae30\ubcf8 \uc5f0\uc0b0\uc774 \ubb34\uc870\uac74 \ube48 \uac12\uc774\ub098 \uac12\uc744 \ucd94\uac00\ud558\ub294 \uae30\ub2a5\uc5d0 \ud574\ub2f9\ud560 \ud544\uc694\ub294 \uc5c6\uae30 \ub54c\ubb38\uc5d0 \uc774\ub984 \uc120\ud0dd\uc774 \ub2e4\uc18c \uc544\uc27d\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4.  \\n\ubaa8\ub178\uc774\ub4dc \ubc95\uce59\uc744 \ub9cc\uc871\ud558\ub294 \ub450 \uac1c\uc758 \uae30\ubcf8 \uc5f0\uc0b0\ub9cc \ub9cc\uc871\ud558\uba74 \ucda9\ubd84\ud558\ub2e4.\\n\\n:::\\n\\n\ub450 \ubc88\uc9f8 \uc608\ub85c, `Maybe a` \ud0c0\uc785\ub3c4 \ub9e4\uac1c\ubcc0\uc218 \ud0c0\uc785 `a`\uac00 \ubaa8\ub178\uc774\ub4dc\ub77c\uba74 \ubaa8\ub178\uc774\ub4dc\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Monoid a => Monoid (Maybe a) where\\n    -- mempty :: Maybe a\\n    mempty = Nothing\\n    \\n    -- mappend :: Maybe a -> Maybe a -> Maybe a\\n    Nothing  `mappend` my         = my\\n    mx       `mappend` Nothing    = mx\\n    Just x   `mappend` Just y     = Just (x `mappend` y)\\n```\\n\uc5ec\uae30\uc11c `mempty`\ub294 \uc2e4\ud328\ub97c \ub098\ud0c0\ub0b4\ub294 `Nothing`\uc774\uace0, `mappend`\ub294 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 \ub450 \uc778\uc218\uc758 \uacb0\uacfc\ub97c \uc870\ud569\ud55c\ub2e4. \\n\ud55c\ucabd \uc778\uc218\uac00 \uc2e4\ud328\ud558\uba74 \ub2e4\ub978 \ucabd \uc778\uc218\ub97c \ubc18\ud658\ud558\uace0, \ub458 \ub2e4 \uc131\uacf5\ud558\uba74 \ub9e4\uac1c\ubcc0\uc218 \ud0c0\uc785 `a`\uc758 `mappend`\ub97c \uc0ac\uc6a9\ud574 \ub450 \uacb0\uacfc\uac12\uc744 \uacb0\ud569\ud55c\ub2e4.\\n\ud55c\ucabd\uc774 \uc2e4\ud328\ud558\uba74 \ub2e4\ub978 \ucabd \uc778\uc218\ub97c \ubc18\ud658\ud558\uace0, \ub458 \ub2e4 \uc131\uacf5\ud558\uba74 \ub9e4\uac1c\ubcc0\uc218 \ud0c0\uc785 `a`\uc758 `mappend`\ub85c \ub450 \uacb0\uacfc\uac12\uc744 \ud569\uce5c\ub2e4.\\n\\n\ud558\ub098\uc758 \ud0c0\uc785\uc774 \uc5ec\ub7ec \uac00\uc9c0 \ubc29\uc2dd\uc73c\ub85c \ubaa8\ub178\uc774\ub4dc\ub97c \uad6c\uc131\ud560 \uc218 \uc788\ub2e4. \uc608\ub97c \ub4e4\uc5b4 \uc815\uc218\uac00 \ub367\uc148\uc5d0\uc11c \ubaa8\ub178\uc774\ub4dc\ub97c \uc774\ub8ec\ub2e4\ub294 \uac83\uc744 \uc774\ubbf8 \uc0b4\ud3b4\ubd24\uc73c\ubbc0\ub85c, \ub2e4\uc74c\uacfc \uac19\uc774 \uac04\ub2e8\ud55c \uc778\uc2a4\ud134\uc2a4\ub97c \uc120\uc5b8\ud560 \uc218 \uc788\ub2e4.\\n\\n```haskell\\ninstance Monoid Int where\\n    -- mempty :: Int\\n    mempty = 0\\n    \\n    -- mappend :: Int -> Int -> Int\\n    mappend = (+)\\n```\\n\\n\uc815\uc218\ub294 \uacf1\uc148\uc5d0\uc11c\ub3c4 \ubaa8\ub178\uc774\ub4dc\ub97c \uc774\ub8e8\uba70, \uc774\ub54c \ud56d\ub4f1\uc6d0\uc740 1\uc774\ubbc0\ub85c \ub2e4\uc74c\uacfc \uac19\uc774 \uc120\uc5b8\ud560 \uc218\ub3c4 \uc788\ub2e4.\\n\\n```haskell\\ninstance Monoid Int where\\n    -- mempty :: Int\\n    mempty = 1\\n    \\n    -- mappend :: Int -> Int -> Int\\n    mappend = (*)\\n```\\n\\n\ud558\uc9c0\ub9cc \ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \uac19\uc740 \ud0c0\uc785\uc5d0 \ub300\ud574 \uac19\uc740 \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \uc5ec\ub7ec \uac1c \uc120\uc5b8\ud560 \uc218 \uc5c6\ub2e4. \ub530\ub77c\uc11c `Monoid Int`\uc5d0 \ub300\ud574 \uc774\ub7f0 \uc2dd\uc73c\ub85c \ub450 \uac1c\uc758 \ubcc4\ub3c4 \uc778\uc2a4\ud134\uc2a4\ub97c \uc120\uc5b8\ud558\ub824 \ud558\uba74 \uc624\ub958\uac00 \ubc1c\uc0dd\ud55c\ub2e4. \\n\\n\ud574\uacb0\ucc45\uc740 \uac01 \uc778\uc2a4\ud134\uc2a4\ub9c8\ub2e4 \uc804\uc6a9 \ub798\ud37c \ud0c0\uc785\uc744 \ub9cc\ub4dc\ub294 \uac83\uc774\ub2e4.\\n\\n\ub367\uc148\uc758 \uacbd\uc6b0, \ubaa8\ub178\uc774\ub4dc \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \uc0c8\ub85c\uc6b4 \ud0c0\uc785 `Sum a`\ub97c \uc120\uc5b8\ud558\ub294\ub370, \uc774\ub294 `Sum`\uc774\ub77c\ub294 \ub354\ubbf8 \uc0dd\uc131\uc790\ub97c \uac00\uc9c0\uace0 \uc788\uc73c\uba70 \ud0c0\uc785 `a`\uc758 \ub2e8\uc77c \uc778\uc218\ub97c \ubc1b\ub294\ub2e4. \ub610\ud55c \uc0dd\uc131\uc790\ub97c \uc81c\uac70\ud558\ub294 \ud568\uc218\ub3c4 \ud568\uaed8 \uc81c\uacf5\ud55c\ub2e4.\\n\\n```haskell\\nnewtype Sum a = Sum a\\n    deriving (Eq, Ord, Show, Read)\\n\\ngetSum :: Sum a -> a\\ngetSum (Sum x) = x\\n```\\n\\n\uc704\uc758 `deriving` \uc808\uc740 `Sum a` \ud0c0\uc785\uc758 \uac12\ub4e4\uc774 \ud45c\uc900 \ub3d9\ub4f1\uc131 \ubc0f \uc21c\uc11c \uc5f0\uc0b0\uc790\ub97c \uc9c0\uc6d0\ud558\uace0, \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\ud558\uac70\ub098 \ubb38\uc790\uc5f4\uc5d0\uc11c \ubcc0\ud658\ud560 \uc218 \uc788\ub3c4\ub85d \ubcf4\uc7a5\ud55c\ub2e4. \uc774\uc81c \uc22b\uc790 \ud0c0\uc785(`Int` \uac19\uc740)\uc778 \ub9e4\uac1c\ubcc0\uc218 \ud0c0\uc785 `a`\uc5d0 \ub300\ud574, `Sum a` \ud0c0\uc785\uc744 \ubaa8\ub178\uc774\ub4dc\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4. `mempty`\ub294 `Sum 0`\uc73c\ub85c, `mappend`\ub294 `Sum a` \ud0c0\uc785 \uac12\ub4e4\uc5d0 \ub300\ud55c \ub367\uc148 \uc5f0\uc0b0\uc790\ub85c \uc815\uc758\ud55c\ub2e4.\\n\\n```haskell\\ninstance Num a => Monoid (Sum a) where\\n    -- mempty :: Sum a\\n    mempty = Sum 0\\n\\n    -- mappend :: Sum a -> Sum a -> Sum a\\n    Sum x `mappend` Sum y = Sum (x+y)\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4, \uc774 \uc778\uc2a4\ud134\uc2a4\ub97c \uc0ac\uc6a9\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> mconcat [Sum 2, Sum 3, Sum 4]\\nSum 9\\n```\\n\\n:::info\\n\\nGHCi\uc5d0\uc11c \uc774\ub7f0 \uc608\uc81c\ub97c \uc2dc\ub3c4\ud574\ubcf4\ub824\uba74 \uba3c\uc800 ```import Data.Monoid```\ub97c \uc785\ub825\ud574 \ubaa8\ub178\uc774\ub4dc \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ub85c\ub4dc\ud574\uc57c \ud55c\ub2e4.\\n\\n:::\\n\\n\ud2b9\ud788, \ub9ac\uc2a4\ud2b8\uc758 \uac01 \uc22b\uc790\uc5d0 `Sum`\uc744 \uc801\uc6a9\ud558\uba74 `mconcat`\uc774 \ud569\uacc4\ub97c \uad6c\ud558\uae30 \uc704\ud574 \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud558\uac8c \ub41c\ub2e4.\\n\\n\ub9c8\ucc2c\uac00\uc9c0\ub85c \uc22b\uc790 \uacf1\uc148\uc758 \uacbd\uc6b0, \ubaa8\ub178\uc774\ub4dc \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \ub367\uc148\uacfc \uac19\uc740 \uc811\uadfc \ubc29\uc2dd\uc744 \uc0ac\uc6a9\ud574 \uc0c8\ub85c\uc6b4 \ud0c0\uc785 `Product a`\ub97c \uc120\uc5b8\ud55c\ub2e4.\\n```haskell\\nnewtype Product a = Product a\\n    deriving (Eq, Ord, Show, Read)\\n\\ngetProduct :: Product a -> a\\ngetProduct (Product x) = x\\n```\\n\\n\uadf8\ub7ec\uba74 `Product a` \ud0c0\uc785\uc744 \uacf1\uc148\uc5d0 \uc801\ud569\ud55c \ubc29\uc2dd\uc73c\ub85c \ub450 \uae30\ubcf8 \uc5f0\uc0b0\uc744 \uc815\uc758\ud574\uc11c `Monoid` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Num a => Monoid (Product a) where\\n    -- mempty :: Product a\\n    mempty = Product 1\\n    \\n    -- mappend :: Product a -> Product a -> Product a\\n    Product x `mappend` Product y = Product (x*y)\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4\\n```haskell\\n> mconcat [Product 2, Product 3, Product 4]\\nProduct 24\\n```\\n\\n\ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c, \ub17c\ub9ac\uac12 \ud0c0\uc785\uc740 \ub17c\ub9ac\uacf1\uacfc \ub17c\ub9ac\ud569 \ubaa8\ub450\uc5d0 \ub300\ud574 \ubaa8\ub178\uc774\ub4dc\ub97c \ud615\uc131\ud55c\ub2e4. \uc774\ub97c \uc704\ud574 \ubaa8\ub178\uc774\ub4dc \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 `Bool` \ud0c0\uc785\uc744 \uc704\ud55c `All`\uacfc `Any`\ub77c\ub294 wrapper \ud0c0\uc785\uc744 \uc81c\uacf5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, `All`\uc5d0 \ub300\ud55c `mconcat` \ud568\uc218\ub294 \ub9ac\uc2a4\ud2b8\uc758 \ubaa8\ub4e0 \ub17c\ub9ac\uac12\uc774 `True`\uc778\uc9c0 \uacb0\uc815\ud558\uace0, `Any`\uc5d0 \ub300\ud574\uc11c\ub294 \uadf8\ub7f0 \uac12\uc774 \ud558\ub098\ub77c\ub3c4 \uc788\ub294\uc9c0 \uacb0\uc815\ud55c\ub2e4.\\n\\n```haskell\\n> mconcat [All True, All True, All True]\\nAll True\\n\\n> mconcat [Any False, Any False, Any False]\\nAny False\\n```\\n:::info\\n\\n\ud558\uc2a4\ucf08 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 ``x <> y`` = ``x `mappend` y``\ub85c \uc815\uc758\ub418\ub294 `mappend`\uc758 \uc911\uc704(infix) \ubc84\uc804\uc744 \uc81c\uacf5\ud55c\ub2e4.  \\n\uc774\ub294 `x <> y <> z`\uc5d0\uc11c\ucc98\ub7fc \ubaa8\ub178\uc774\ub4dc \ud45c\ud604\uc2dd\uc744 \ub354 \uac04\uacb0\ud558\uac8c \uc791\uc131\ud560 \uc218 \uc788\uac8c \ud574\uc900\ub2e4. \uc774 \uc5f0\uc0b0\uc790\ub294 \uc2e4\uc81c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc790\uc8fc \uc0ac\uc6a9\ub418\uc9c0\ub9cc, \uc774 \uc7a5\uc5d0\uc11c\ub294 \uc124\uba85\uc758 \ubaa9\uc801\uc73c\ub85c `mappend` \uae30\ubcf8 \ud568\uc218\ub97c \uc9c1\uc811 \uc0ac\uc6a9\ud588\ub2e4.\\n\\n:::\\n\\n## Foldables\\n\\n\ud558\uc2a4\ucf08\uc5d0\uc11c \ubaa8\ub178\uc774\ub4dc\uc758 \uc8fc\uc694 \uc751\uc6a9 \uc911 \ud558\ub098\ub294 \ub370\uc774\ud130 \uad6c\uc870\uc758 \ubaa8\ub4e0 \uac12\uc744 \uacb0\ud569\ud558\uc5ec \ub2e8\uc77c \uac12\uc744 \ub9cc\ub4dc\ub294 \uac83\uc774\ub2e4. \\n\uc608\ub97c \ub4e4\uc5b4 \ub9ac\uc2a4\ud2b8\uc758 \uacbd\uc6b0 \uc774 \uc544\uc774\ub514\uc5b4\ub97c \uad6c\ud604\ud558\ub294 `fold` \ud568\uc218\ub97c \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nfold :: Monoid a => [a] -> a\\nfold []     = mempty\\nfold (x:xs) = x `mappend` fold xs\\n```\\n\\n\uc989, \ube48 \ub9ac\uc2a4\ud2b8\uc5d0 `fold`\ub97c \uc801\uc6a9\ud558\uba74 \ubaa8\ub178\uc774\ub4dc\uc758 \ud56d\ub4f1\uc6d0 `mempty`\uac00 \ub098\uc624\uace0, \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \ub9ac\uc2a4\ud2b8\uc758 \uacbd\uc6b0\uc5d0\ub294 \ubaa8\ub178\uc774\ub4dc \uc5f0\uc0b0\uc790 `mappend`\ub97c \uc0ac\uc6a9\ud574 \ub9ac\uc2a4\ud2b8\uc758 \uba38\ub9ac\uc640 \uaf2c\ub9ac\ub97c \uc7ac\uadc0\uc801\uc73c\ub85c \ucc98\ub9ac\ud55c \uacb0\uacfc\ub97c \uacb0\ud569\ud55c\ub2e4. \\n\\n\uc608\ub97c \ub4e4\uc5b4 `[x,y,z]` \ud615\ud0dc\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 fold\ub97c \uc801\uc6a9\ud558\uba74\\n```haskell\\nx `mappend` (y `mappend` (z `mappend` mempty))\\n```\\n\\n\ub2e4\uc2dc \ub9d0\ud574, `fold`\ub294 \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud574 \ub9ac\uc2a4\ud2b8\ub97c \'\uc811\ub294\' \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc81c\uacf5\ud558\uba70, \uc774\uac83\uc774 \ud568\uc218 \uc774\ub984\uc744 \uc120\ud0dd\ud55c \uc774\uc720\ub2e4.  \\n`fold`\ub294 `Monoid` \ud074\ub798\uc2a4\uc758 `mconcat`\uacfc \uac19\uc740 \ubc29\uc2dd\uc73c\ub85c \uc791\ub3d9\ud558\uc9c0\ub9cc, `foldr`\uc744 \uc0ac\uc6a9\ud558\ub294 \ub300\uc2e0 \uba85\uc2dc\uc801 \uc7ac\uadc0\ub97c \uc0ac\uc6a9\ud574 \uc815\uc758\ub41c\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\uc790. \\n\\n\ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c, leaf\uc5d0 \ub370\uc774\ud130\ub97c \uac00\uc9c4 \uc774\uc9c4 \ud2b8\ub9ac \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 `fold` \ubc84\uc804\uc744 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\\n    deriving Show\\n\\nfold :: Monoid a => Tree a -> a\\nfold (Leaf x)   = x\\nfold (Node l r) = fold l `mappend` fold r\\n```\\n\\n\uc989, leaf\uc758 \uacbd\uc6b0\uc5d0\ub294 \ub2e8\uc21c\ud788 \uadf8\uac83\uc774 \ud3ec\ud568\ud558\ub294 \uac12\uc744 \ubc18\ud658\ud558\uace0, \ub178\ub4dc\uc758 \uacbd\uc6b0\uc5d0\ub294 \ub450 \ud558\uc704 \ud2b8\ub9ac\ub97c \uc7ac\uadc0\uc801\uc73c\ub85c \uc811\uace0 `mappend`\ub97c \uc0ac\uc6a9\ud574 \uacb0\uacfc \uac12\ub4e4\uc744 \uacb0\ud569\ud55c\ub2e4. \uc774 \uc608\uc81c\uc5d0\uc11c\ub294 \uc774\ub7f0 \ud0c0\uc785\uc758 \ud2b8\ub9ac\uac00 \ud56d\uc0c1 \ube44\uc5b4\uc788\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0 \uc815\uc758\uc5d0\uc11c \ud56d\ub4f1\uc6d0 `mempty`\ub97c \uc0ac\uc6a9\ud560 \ud544\uc694\uac00 \uc5c6\ub2e4.\\n\\n\ub354 \uc77c\ubc18\uc801\uc73c\ub85c, \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud574 \ub370\uc774\ud130 \uad6c\uc870\uc758 \uac12\ub4e4\uc744 \uc811\ub294 \uc544\uc774\ub514\uc5b4\ub294 \ub9ac\uc2a4\ud2b8\ub098 \uc774\uc9c4 \ud2b8\ub9ac \uac19\uc740 \ud0c0\uc785\uc5d0\ub9cc \ud55c\uc815\ub418\uc9c0 \uc54a\uace0, \ub2e4\uc591\ud55c \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc73c\ub85c \ucd94\uc0c1\ud654\ud560 \uc218 \uc788\ub2e4. \ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \uc774 \uac1c\ub150\uc774 `Data.Foldable` \ub77c\uc774\ube0c\ub7ec\ub9ac\uc758 \ub2e4\uc74c \ud074\ub798\uc2a4 \uc120\uc5b8\uc73c\ub85c \uad6c\ud604\ub418\uc5b4 \uc788\ub2e4.\\n```haskell\\nclass Foldable t where\\n    fold    :: Monoid a => t a -> a\\n    foldMap :: Monoid b => (a -> b) -> t a -> b\\n    foldr   :: (a -> b -> b) -> b -> t a -> b\\n    foldl   :: (a -> b -> a) -> a -> t b -> a\\n```\\n\uc989, \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc774 `Foldable` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub418\ub824\uba74 \uc9c0\uc815\ub41c \ud0c0\uc785\uc758 \ub2e4\uc591\ud55c `fold` \ud568\uc218\ub97c \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc704\uc758 \uc120\uc5b8\uc5d0\uc11c \uad00\ub840\uc801\uc73c\ub85c `foldable` \ud0c0\uc785\uc740 \ubcf4\ud1b5 `t`\ub85c \ud45c\uc2dc\ub41c\ub2e4.\\n\\n\uc9c1\uad00\uc801\uc73c\ub85c, `Foldable` \ud074\ub798\uc2a4\uc758 \uc77c\ubc18\ud654\ub41c `fold`\ub294 \uc6d0\uc18c\ub4e4\uc774 \ud0c0\uc785 `a`\ub97c \uac00\uc9c4 \ud0c0\uc785 `t a`\uc758 \ub370\uc774\ud130 \uad6c\uc870\ub97c \ubc1b\uc544\uc11c, \uc774 \ud0c0\uc785\uc5d0 \ub300\ud55c \ubaa8\ub178\uc774\ub4dc \uae30\ubcf8 \uc5f0\uc0b0\uc744 \uc0ac\uc6a9\ud574 \uc6d0\uc18c\ub4e4\uc744 \uacb0\ud569\ud558\uc5ec \ud0c0\uc785 `a`\uc758 \ub2e8\uc77c \uac12\uc744 \ub9cc\ub4e0\ub2e4. \\n\ubc18\uba74 `foldMap`\uc740 \ud0c0\uc785 `a -> b`\uc758 \ud568\uc218\ub97c \ucd94\uac00 \uc778\uc218\ub85c \ubc1b\uc544 `fold`\ub97c \uc77c\ubc18\ud654\ud558\ub294\ub370, \uc774 \ud568\uc218\ub294 \uad6c\uc870\uc758 \uac01 \uc6d0\uc18c\uc5d0 \uc801\uc6a9\ub41c \ud6c4 \ud0c0\uc785 `b`\uc5d0 \ub300\ud55c \ubaa8\ub178\uc774\ub4dc \uae30\ubcf8 \uc5f0\uc0b0\uc744 \uc0ac\uc6a9\ud574 \uacb0\uacfc \uac12\ub4e4\uc744 \uacb0\ud569\ud55c\ub2e4.\\n\\n\uc704 \ud074\ub798\uc2a4 \uc120\uc5b8\uc758 \ub9c8\uc9c0\ub9c9 \ub450 \ud568\uc218\uc778 `foldr`\uacfc `foldl`\uc740 \ub9ac\uc2a4\ud2b8\uc6a9 \uace0\ucc28 \ud568\uc218\ub97c \ub2e4\ub978 \ub370\uc774\ud130 \uad6c\uc870\ub85c \uc77c\ubc18\ud654\ud55c \uac83\uc774\ub2e4. \\n\uc774 \ub450 \ud568\uc218\ub294 \ub450 \uac12\uc744 \uacb0\ud569\ud558\ub294 \uc2dc\uc791 \uac12\uacfc \ud568\uc218\uac00 \uc778\uc218\ub85c \uba85\uc2dc\uc801\uc73c\ub85c \uc81c\uacf5\ub418\uae30 \ub54c\ubb38\uc5d0 \uae30\ubcf8 \ubaa8\ub178\uc774\ub4dc\uac00 \ud544\uc694\ud558\uc9c0 \uc54a\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\uc790.\\n\\n\uc644\uc804\ud55c \ubc84\uc804\uc758 `Foldable` \ud074\ub798\uc2a4\uc5d0\ub294 \uc5ec\ub7ec \ub2e4\ub978 \uc720\uc6a9\ud55c \ud568\uc218\ub4e4\uacfc \uae30\ubcf8 \uc815\uc758\ub4e4\uc774 \ud3ec\ud568\ub418\uc5b4 \uc788\uc9c0\ub9cc, \uc704\uc5d0\uc11c \uc81c\uc2dc\ud55c \ucd95\uc57d\ub41c \ubc84\uc804\uc744 \uc0b4\ud3b4\ubcf4\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud558\uaca0\ub2e4.\\n\\n### Examples\\n\\n\uc608\uc0c1\ud560 \uc218 \uc788\ub4ef\uc774, \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc740 \ud3f4\ub529(folding) \uae30\ubcf8 \ud568\uc218\ub4e4\uc744 \uc801\uc808\ud55c \ubc29\uc2dd\uc73c\ub85c \uc815\uc758\ud568\uc73c\ub85c\uc368 \ud3f4\ub354\ube14 \ud0c0\uc785\uc73c\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n\\n```haskell\\ninstance Foldable [] where\\n    -- fold :: Monoid a => [a] -> a\\n    fold []     = mempty\\n    fold (x:xs) = x `mappend` fold xs\\n    \\n    -- foldMap :: Monoid b => (a -> b) -> [a] -> b\\n    foldMap _ []     = mempty\\n    foldMap f (x:xs) = f x `mappend` foldMap f xs\\n    \\n    -- foldr :: (a -> b -> b) -> b -> [a] -> b\\n    foldr _ v []     = v\\n    foldr f v (x:xs) = f x (foldr f v xs)\\n    \\n    -- foldl :: (a -> b -> a) -> a -> [b] -> a\\n    foldl _ v []     = v\\n    foldl f v (x:xs) = foldl f (f v x) xs\\n```\\n\uc608\ub97c \ub4e4\uc5b4, \uc774\uc804 \uc139\uc158\uc758 \uc22b\uc790 \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74, `foldMap`\uc740 \uc774\uc81c \uc22b\uc790 \ub9ac\uc2a4\ud2b8\uc758 \ud569\uacc4\uc640 \uacf1\uc744 \uacc4\uc0b0\ud558\ub294 \ub370 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> getSum (foldMap Sum [1..10])\\n55\\n\\n> getProduct (foldMap Product [1..10])\\n3628800\\n```\\n:::info\\n\\n\uc774 \uc608\uc81c\ub97c \uc2e4\ud589\ud558\ub824\uba74, `Data.Monoid`\uc640 `Data.Foldable`\uc744 \uc784\ud3ec\ud2b8\ud574\uc57c \ud55c\ub2e4.\\n\\n::: \\n\\n\uc774\uc9c4 \ud2b8\ub9ac \ub610\ud55c \ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c \uc778\uc2a4\ud134\uc2a4\ub97c \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \\n\ub2e8, `foldr`\uacfc `foldl`\uc774 \ud2b8\ub9ac \ub0b4\uc758 \uac12\ub4e4\uc744 \uac01\uac01 \uc624\ub978\ucabd-\uc5d0\uc11c-\uc67c\ucabd \uc21c\uc11c\uc640 \uc67c\ucabd-\uc5d0\uc11c-\uc624\ub978\ucabd \uc21c\uc11c\ub85c \uacb0\ud569\ud558\ub3c4\ub85d \uc8fc\uc758\ud574\uc57c \ud55c\ub2e4.\\n\\n```haskell\\ninstance Foldable Tree where\\n    -- fold :: Monoid a => Tree a -> a\\n    fold (Leaf x)   = x\\n    fold (Node l r) = fold l `mappend` fold r\\n    \\n    -- foldMap :: Monoid b => (a -> b) -> Tree a -> b\\n    foldMap f (Leaf x)   = f x\\n    foldMap f (Node l r) = foldMap f l `mappend` foldMap f r\\n    \\n    -- foldr :: (a -> b -> b) -> b -> Tree a -> b\\n    foldr f v (Leaf x)   = f x v\\n    foldr f v (Node l r) = foldr f (foldr f v r) l\\n    \\n    -- foldl :: (a -> b -> a) -> a -> [b] -> a\\n    foldl f v (Leaf x)   = f v x\\n    foldl f v (Node l r) = foldl f (foldl f v l) r\\n```\\n\uc608\ub97c \ub4e4\uc5b4, \ub2e4\uc74c\uacfc \uac19\uc740 \uc815\uc218 \ud2b8\ub9ac\ub97c \uc0dd\uac01\ud574\ubcf4\uc790.\\n```haskell\\ntree :: Tree Int\\ntree = Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)\\n```\\n\uc774\ub54c `foldr (+) 0 tree`\ub97c \ud3c9\uac00\ud558\uba74 `(1+(2+(3+0)))`\uc758 \uacb0\uacfc\uc778 `6`\uc774 \ub098\uc624\ub294\ub370, \ub367\uc148\uc774 \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc218\ud589\ub41c\ub2e4. \\n\ubc18\uba74 `foldl (+) 0 tree`\ub294 `(((0+1)+2)+3)`\uc758 \uacb0\uacfc `6`\uc744 \ub0b4\ub193\uc73c\uba70, \ub367\uc148\uc740 \uc67c\ucabd\uc5d0\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc218\ud589\ub41c\ub2e4. \\n\ub367\uc148\uc740 \uacb0\ud569 \ubc95\uce59\uc774 \uc131\ub9bd\ud558\ubbc0\ub85c \uc774 \uacbd\uc6b0 \uacb0\uacfc\ub294 \uac19\uc9c0\ub9cc, `foldl`\uc774 \ub354 \ud6a8\uc728\uc801\uc77c \uc218 \uc788\ub2e4.\\n\\n### Other primitives and defaults\\n\\n\ub124 \uac00\uc9c0 \uae30\ubcf8\uc801\uc778 \ud3f4\ub529 \ud568\uc218 \uc678\uc5d0\ub3c4, `Foldable` \ud074\ub798\uc2a4\ub294 \ub370\uc774\ud130 \uad6c\uc870 \ub0b4\uc758 \uac12\ub4e4\uc744 \uacb0\ud569\ud558\uae30 \uc704\ud55c \ub2e4\uc591\ud558\uace0 \uc720\uc6a9\ud55c \ub2e4\ub978 \ud568\uc218\ub4e4\ub3c4 \ud3ec\ud568\ud55c\ub2e4.  \\n\uccab \ubc88\uc9f8 \uadf8\ub8f9\uc740 \ub9ac\uc2a4\ud2b8\uc5d0 \uc775\uc219\ud55c \ud568\uc218\ub4e4\uc744 \uc77c\ubc18\ud654\ud55c\ub2e4.\\n\\n```haskell\\nnull    :: t a -> Bool\\nlength  :: t a -> Int\\nelem    :: Eq a => a -> t a -> Bool\\nmaximum :: Ord a => t a -> a\\nminimum :: Ord a => t a -> a\\nsum     :: Num a => t a -> a\\nproduct :: Num a => t a -> a\\n```\\n\uc608\ub97c \ub4e4\uc5b4, `null`\uc740 \uad6c\uc870\uac00 \ube44\uc5b4 \uc788\ub294\uc9c0(\uc6d0\uc18c\uac00 \uc5c6\ub294\uc9c0) \uacb0\uc815\ud558\uace0, `length`\ub294 `t a` \ud0c0\uc785\uc758 \uad6c\uc870 \uc548\uc5d0 \uc788\ub294 `a` \ud0c0\uc785 \uc6d0\uc18c\uc758 \uc218\ub97c \uc13c\ub2e4. \ub530\ub77c\uc11c \uc774 \ud568\uc218\ub4e4\uc740 \ub9ac\uc2a4\ud2b8\uc640 \ud2b8\ub9ac \ubaa8\ub450\uc5d0 \uc801\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> null []\\nTrue\\n\\n> null (Leaf 1)\\nFalse\\n\\n> length [1..10]\\n10\\n\\n> length (Node (Leaf \'a\') (Leaf \'b\'))\\n2\\n```\\n\\n\ub610\ud55c, \uc774 \ud074\ub798\uc2a4\ub294 \uc801\uc5b4\ub3c4 \ud558\ub098\uc758 \uc6d0\uc18c\ub97c \ud3ec\ud568\ud558\uc5ec \uc2dc\uc791 \uac12\uc774 \ud544\uc694 \uc5c6\ub294 \uad6c\uc870\ub97c \uc704\ud55c `foldr`\uacfc `foldl`\uc758 \ubc84\uc804\ub3c4 \ud3ec\ud568\ud55c\ub2e4.\\n\\n```haskell\\nfoldr1 :: (a -> a -> a) -> t a -> a\\nfoldl1 :: (a -> a -> a) -> t a -> a\\n```\\n\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```haskell\\n> foldr1 (+) [1..10]\\n55\\n\\n> foldl1 (+) (Node (Leaf 1) (Leaf 2))\\n3\\n```\\n\\n\ud074\ub798\uc2a4\uc758 \ub9c8\uc9c0\ub9c9 \uae30\ubcf8 \ud568\uc218\ub294 \ub370\uc774\ud130 \uad6c\uc870\ub97c \ub9ac\uc2a4\ud2b8\ub85c \ud3bc\uce58\ub294(flatten) \uac83\uc73c\ub85c, \uc608\ub97c \ub4e4\uc5b4 `Node (Leaf 1) (Leaf 2)` \ud2b8\ub9ac\ub97c `[1,2]` \ub9ac\uc2a4\ud2b8\ub85c \ubcc0\ud658\ud55c\ub2e4.\\n\\n```haskell\\ntoList :: t a -> [a]\\n```\\n\\n\uc0ac\uc2e4 `toList` \ud568\uc218\ub294 `Foldable` \ud074\ub798\uc2a4 \uc120\uc5b8\uc5d0\uc11c \ud2b9\ubcc4\ud55c \uc5ed\ud560\uc744 \ud55c\ub2e4. \ud074\ub798\uc2a4 \ub0b4 \ub300\ubd80\ubd84\uc758 \ub2e4\ub978 \uae30\ubcf8 \ud568\uc218\ub4e4\uc5d0 \ub300\ud55c **\uae30\ubcf8 \uc815\uc758(default definitions)** \ub97c \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c \uae30\ubcf8 \ud568\uc218\ub97c \uc774\uc6a9\ud574 \uc81c\uacf5\ud558\ub294 \ub370 \uc0ac\uc6a9\ub420 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4.  \\n\\n\uad6c\uccb4\uc801\uc73c\ub85c, \ub2e4\uc74c\uacfc \uac19\uc740 \uae30\ubcf8 \uc815\uc758\ub4e4\uc744 \uac16\ub294\ub2e4.\\n\\n```haskell\\nfoldr f v = foldr f v . toList\\nfoldl f v = foldl f v . toList\\nfoldr1 f  = foldr1 f  . toList\\nfoldl1 f  = foldl1 f  . toList\\n\\nnull      = null . toList\\nlength    = length . toList\\nelem x    = elem x . toList\\nmaximum   = maximum . toList\\nminimum   = minimum . toList\\nsum       = sum . toList\\nproduct   = product . toList\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4, `null = null . toList`\ub77c\ub294 \uc815\uc758\ub294 \uc5b4\ub5a4 \ub370\uc774\ud130 \uad6c\uc870\uac00 \ube44\uc5b4\uc788\ub294\uc9c0 \uc544\ub2cc\uc9c0\ub97c \uba3c\uc800 \uadf8 \uad6c\uc870\ub97c \ub9ac\uc2a4\ud2b8\ub85c \ud3bc\uce5c(flatten) \ub2e4\uc74c, \uadf8 \ub9ac\uc2a4\ud2b8\uac00 \ube44\uc5b4\uc788\ub294\uc9c0 \ud655\uc778\ud558\ub294 \ubc29\uc2dd\uc73c\ub85c \uacb0\uc815\ud560 \uc218 \uc788\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub2e4\ub978 \uc815\uc758\ub4e4\ub3c4 \ube44\uc2b7\ud558\uac8c \uac04\ub2e8\ud55c \ud574\uc11d\uc744 \uac16\ub294\ub2e4.\\n\\n`Foldable` \ud074\ub798\uc2a4\uc758 \ub9c8\uc9c0\ub9c9 \uc138 \uac00\uc9c0 \uae30\ubcf8 \uc815\uc758\ub294 `fold`, `foldMap`, `toList` \uae30\ubcf8 \ud568\uc218\ub4e4 \uac04\uc758 \uc911\uc694\ud55c \uad00\uacc4\ub97c \uc124\uc815\ud55c\ub2e4.\\n\\n```haskell\\nfold      = foldMap id\\nfoldMap f = foldr (mappend . f) mempty\\ntoList    = foldMap (\\\\x -> [x])\\n```\\n\uc989,\\n- `fold`\ub294 \uac01 \uc6d0\uc18c\ub97c \uacb0\ud569\ud558\uae30 \uc804\uc5d0 \ud56d\ub4f1 \ud568\uc218(`id`)\ub97c \uc801\uc6a9\ud558\ub294 `foldMap`\uc758 \ud2b9\ubcc4\ud55c \uacbd\uc6b0\ub85c \ubcfc \uc218 \uc788\ub2e4.\\n- `foldMap`\uc740 \uac01 \uc6d0\uc18c\uc5d0 \ud568\uc218 `f`\ub97c \uc801\uc6a9\ud55c \ud6c4, \ubaa8\ub178\uc774\ub4dc \uae30\ubcf8 \ud568\uc218\ub4e4(`mappend`, `mempty`)\uc744 \uc0ac\uc6a9\ud558\uc5ec \uacb0\ud569\ud558\ub294 `foldr`\uc758 \uad00\uc810\uc5d0\uc11c \uc815\uc758\ub420 \uc218 \uc788\ub2e4.\\n- `toList`\ub294 \uac01 \uc6d0\uc18c\ub97c \uc6d0\uc18c\uac00 \ud558\ub098\uc778 \ub9ac\uc2a4\ud2b8(singleton list)\ub85c \ubcc0\ud658\ud55c \ub2e4\uc74c, \ub9ac\uc2a4\ud2b8 \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud558\uc5ec \uadf8 \uacb0\uacfc\ub4e4\uc744 \uc774\uc5b4 \ubd99\uc774\ub294 `foldMap`\uc758 \uad00\uc810\uc5d0\uc11c \uc815\uc758\ub420 \uc218 \uc788\ub2e4.\\n\\n\uc694\uc57d\ud558\uc790\uba74, `Foldable` \ud074\ub798\uc2a4\ub294 \ub370\uc774\ud130 \uad6c\uc870 \ub0b4\uc758 \uac12\ub4e4\uc744 \ucc98\ub9ac\ud558\uae30 \uc704\ud55c \ub2e4\uc591\ud558\uace0 \uc720\uc6a9\ud55c \ud568\uc218\ub4e4\uc744 \uc81c\uacf5\ud558\uba70, \uc774\ub4e4 \ub300\ubd80\ubd84\uc740 \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c \ud2b9\uc815 \uc778\uc2a4\ud134\uc2a4\ub098 \ud074\ub798\uc2a4 \ub0b4\uc758 \ub2e4\ub978 \uc77c\ubc18\ud654\ub41c \ud568\uc218\ub97c \uc774\uc6a9\ud55c \uae30\ubcf8 \uc815\uc758\ub97c \uac16\ub294\ub2e4. \uc774 \uc2dc\uc810\uc5d0\uc11c \uc138 \uac00\uc9c0 \uc9c8\ubb38\uc744 \ub358\uc9c8 \uc218 \uc788\ub2e4.\\n\\n1. \uc65c \ud074\ub798\uc2a4\uc5d0 \uadf8\ub807\uac8c \ub9ce\uc740 \ud568\uc218\uac00 \uc788\ub294\uac00? \ud2b9\ud788, `null`, `length` \ub4f1\uacfc \uac19\uc740 \ucd94\uac00\uc801\uc778 \uae30\ubcf8 \ud568\uc218\ub4e4\uc774 \uc65c \ud3f4\ub354\ube14 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc758 \uc815\uc758\uac00 \uc544\ub2cc `Foldable` \ud074\ub798\uc2a4\uc758 \uba54\uc18c\ub4dc\ub85c \uc81c\uacf5\ub418\ub294\uc9c0 \ubb3c\uc744 \uc218 \uc788\ub2e4. \uadf8 \uc774\uc720\ub294 \ud544\uc694\ud560 \uacbd\uc6b0 \uae30\ubcf8 \uc815\uc758\ub97c \uc624\ubc84\ub77c\uc774\ub4dc(override)\ud560 \uc218 \uc788\ub3c4\ub85d \ud5c8\uc6a9\ud558\uae30 \uc704\ud568\uc774\uba70, \ub9cc\uc57d \uc774 \ud568\uc218\ub4e4\uc774 \ucd5c\uc0c1\uc704 \ud568\uc218(top-level functions)\ub85c \uc815\uc758\ub418\uc5c8\ub2e4\uba74 \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud588\uc744 \uac83\uc774\ub2e4.\\n2. \ubb34\uc5c7\uc744 \uc218\ub3d9\uc73c\ub85c \uc815\uc758\ud574\uc57c \ud558\ub294\uac00? `Foldable` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \uc704\ud55c **\ucd5c\uc18c \uc644\uc804 \uc815\uc758(minimal complete definition)** \ub294 `foldMap`\uc774\ub098 `foldr` \ub458 \uc911 \ud558\ub098\ub97c \uc815\uc758\ud558\ub294 \uac83\uc774\ub2e4. \ud074\ub798\uc2a4\uc758 \ub2e4\ub978 \ubaa8\ub4e0 \ud568\uc218\ub4e4\uc740 \uc774 \ub450 \ud568\uc218 \uc911 \ud558\ub098\ub85c\ubd80\ud130 \uae30\ubcf8 \uc815\uc758\uc640 \ub9ac\uc2a4\ud2b8 \uc778\uc2a4\ud134\uc2a4\ub97c \uc0ac\uc6a9\ud558\uc5ec \ud30c\uc0dd\ub420 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \ub9ac\uc2a4\ud2b8\uc640 \ud2b8\ub9ac\uc5d0\uc11c \uc774\ubbf8 \ubcf4\uc558\ub4ef\uc774, `foldMap` \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83\uc774 \uac00\uc7a5 \uac04\ub2e8\ud55c \uacbd\uc6b0\uac00 \ub9ce\ub2e4.\\n3. \ud6a8\uc728\uc131\uc740 \uc5b4\ub5a4\uac00? \ub9ce\uc740 \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c\ub294 \ud074\ub798\uc2a4\uc5d0 \uc81c\uacf5\ub41c \uae30\ubcf8 \uc815\uc758\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc73c\ub85c \ucda9\ubd84\ud558\uc9c0\ub9cc, \ub354 \ub192\uc740 \ud6a8\uc728\uc131\uc774 \uc694\uad6c\ub41c\ub2e4\uba74 \uc704\uc5d0\uc11c \uc5b8\uae09\ud588\ub4ef\uc774 \uc774\ub4e4\uc744 \uc624\ubc84\ub77c\uc774\ub4dc\ud560 \uc218 \uc788\ub2e4. \uc2e4\uc81c\ub85c GHC \uc2dc\uc2a4\ud15c\uc740 \uc6b0\ub9ac\uac00 \uc81c\uc2dc\ud55c \ub2e8\uc21c\ud55c \ubc84\uc804\ubcf4\ub2e4 \ub354 \ud6a8\uc728\uc801\uc778 \uae30\ubcf8 \uc815\uc758\ub97c \uc0ac\uc6a9\ud558\uc9c0\ub9cc, \uc774\ub4e4\uc740 \uae30\ub2a5\uc801\uc73c\ub85c \uc6b0\ub9ac\uc758 \ub354 \uac04\ub2e8\ud55c \ubc84\uc804\uacfc \ub3d9\uc77c\ud558\ub2e4.\\n\\nGHC\uac00 `Data.Foldable` \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc790\ub3d9\uc73c\ub85c \uc784\ud3ec\ud2b8\ud558\uc9c0\ub9cc, \ud604\uc7ac \ud074\ub798\uc2a4\uc758 `fold`\uc640 `toList` \uba54\uc18c\ub4dc\ub294 \uc228\uae34\ub2e4\ub294 \uc810\uc744 \uc5b8\uae09\ud558\uba70 \uc774 \uc139\uc158\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. \uc774\ub7ec\ud55c \uc774\uc720\ub85c, \uc6b0\ub9ac\ub294 \ud3f4\ub354\ube14 \ud0c0\uc785\uc744 \ud504\ub85c\uadf8\ub798\ubc0d\ud560 \ub54c \uc790\ub3d9\uc73c\ub85c \uc81c\uacf5\ub418\ub294 \ucd95\uc18c\ub41c \ubc84\uc804\uc5d0 \uc758\uc874\ud558\uae30\ubcf4\ub2e4\ub294 `Data.Foldable`\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \uc784\ud3ec\ud2b8\ud558\ub294 \uac83\uc744 \uc77c\ubc18\uc801\uc73c\ub85c \uc120\ud638\ud55c\ub2e4.\\n\\n### Generic functions\\n\\n\ud3f4\ub354\ube14 \ud0c0\uc785\uc758 \uac1c\ub150\uc744 \ucd94\uc0c1\ud654\ud558\ub294 \uac83\uc758 \uc911\uc694\ud55c \uc774\uc810\uc740 `Foldable` \ud074\ub798\uc2a4\uc758 \uae30\ubcf8 \ud568\uc218\ub4e4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc5b4\ub5a4 \ud3f4\ub354\ube14 \ud0c0\uc785\uacfc\ub3c4 \ud568\uaed8 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc77c\ubc18\ud654\ub41c \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \ub2a5\ub825\uc774\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \uc815\uc218 \ub9ac\uc2a4\ud2b8\uc758 \ud3c9\uade0\uc744 \uacc4\uc0b0\ud558\ub294 \ud568\uc218\ub97c \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ud588\ub2e4\uba74\\n\\n```haskell\\naverage :: [Int] -> Int\\naverage ns = sum ns `div` length ns\\n```\\n\\n\uc774\uc81c `sum`\uacfc `length`\uac00 \ub9ac\uc2a4\ud2b8\uc5d0\ub9cc \uad6d\ud55c\ub418\uc9c0 \uc54a\uace0 \uc5b4\ub5a4 \ud3f4\ub354\ube14 \ud0c0\uc785\uacfc\ub3c4 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4\ub294 \uac83\uc744 \ubcf4\uc558\uc73c\ubbc0\ub85c, `average`\uc758 \ud0c0\uc785 \uc815\uc758 \uc790\uccb4\ub97c \ubcc0\uacbd\ud560 \ud544\uc694 \uc5c6\uc774 \uc77c\ubc18\ud654\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\naverage :: Foldable t => t Int -> Int\\naverage ns = sum ns `div` length ns\\n```\\n\\n\ub530\ub77c\uc11c, \uc774 \ud568\uc218\ub294 \uc774\uc81c \ub9ac\uc2a4\ud2b8\uc640 \ud2b8\ub9ac \ubaa8\ub450\uc5d0 \uc801\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> average [1..10]\\n5\\n\\n> average (Node (Leaf 1) (Leaf 3))\\n2\\n```\\n\\n\ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c, `Data.Foldable` \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \ub17c\ub9ac\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud574 \ub3d9\uc791\ud558\ub294 \uc775\uc219\ud55c \ud568\uc218\ub4e4\uc758 \uc77c\ubc18\ud654\ub41c \ubc84\uc804\uc744 \uc81c\uacf5\ud55c\ub2e4.\\n\\n\\n```haskell\\nand :: Foldable t => t Bool -> Bool\\nand = getAll . foldMap All\\n\\nor :: Foldable t => t Bool -> Bool\\nor = getAny . foldMap Any\\n\\nall :: Foldable t => (a -> Bool) -> t a -> Bool\\nall p = getAll . foldMap (All . p)\\n\\nany :: Foldable t => (a -> Bool) -> t a -> Bool\\nany p = getAny . foldMap (Any . p)\\n```\\n\\n\uac01 \uacbd\uc6b0, `foldMap`\uc744 \uc801\uc808\ud55c \ubaa8\ub178\uc774\ub4dc \uae30\ubcf8 \ud568\uc218\uc640 \ud568\uaed8 \uc0ac\uc6a9\ud558\uba74 \uc6d0\ud558\ub294 \ub3d9\uc791\uc744 \uc77c\ubc18\ud654\ub41c \ubc29\uc2dd\uc73c\ub85c \uc5bb\uc744 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> and [True,False,True]\\nFalse\\n\\n> or (Node (Leaf True) (Leaf False))\\nTrue\\n\\n> all even [1,2,3]\\nFalse\\n\\n> any even (Node (Leaf 1) (Leaf 2))\\nTrue\\n```\\n\\n\ub9c8\uc9c0\ub9c9 \uc608\uc81c\ub85c, \ub9ac\uc2a4\ud2b8\uc758 \ub9ac\uc2a4\ud2b8\ub97c \uc774\uc5b4 \ubd99\uc774\ub294 `concat :: [[a]] -> [a]` \ud568\uc218\ub294 \uc774\uc81c \ub9ac\uc2a4\ud2b8 \ubaa8\ub178\uc774\ub4dc\ub97c \uc0ac\uc6a9\ud558\uc5ec \uac04\ub2e8\ud788 \ud3f4\ub529\ud568\uc73c\ub85c\uc368, \uc6d0\uc18c\uac00 \ub9ac\uc2a4\ud2b8\uc778 \uc784\uc758\uc758 \ud3f4\ub354\ube14 \ud0c0\uc785\uc5d0 \ub300\ud574 \uc77c\ubc18\ud654\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\nconcat :: Foldable t => t [a] -> [a]\\nconcat = fold\\n```\\n\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```haskell\\n> concat [\\"ab\\",\\"cd\\",\\"ef\\"]\\n\\"abcdef\\"\\n\\n> concat (Node (Leaf [1,2]) (Leaf [3]))\\n[1,2,3]\\n```\\n\\n\uacb0\ub860\uc801\uc73c\ub85c, \ud558\uc2a4\ucf08\uc5d0\uc11c \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \uc120\uc5b8\ud560 \ub54c, \uadf8 \ud0c0\uc785\uc744 \ud3f4\ub354\ube14 \ud0c0\uc785\uc73c\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub294\uc9c0 \uace0\ub824\ud558\ub294 \uac83\uc774 \uc720\uc6a9\ud558\ub2e4. \uadf8\ub807\uac8c \ud558\ub294 \uac83\uc758 \uc7a5\uc810\uc740 `Foldable` \ud074\ub798\uc2a4\uc5d0 \ud3ec\ud568\ub41c \uae30\ubcf8 \uc815\uc758\ub4e4\uacfc \uc774 \uae30\ubcf8 \ud568\uc218\ub4e4\uc744 \uc774\uc6a9\ud574 \uc815\uc758\ub41c \ub2e4\ub978 \uc77c\ubc18\ud654\ub41c \ud568\uc218\ub4e4\uc744 \ud1b5\ud574, \ud574\ub2f9 \ud0c0\uc785\uc744 \uc704\ud55c \ub2e4\uc591\ud558\uace0 \uc720\uc6a9\ud55c \ud568\uc218\ub4e4\uc744 \ubcf8\uc9c8\uc801\uc73c\ub85c \'\uacf5\uc9dc\ub85c\' \uc81c\uacf5\ubc1b\ub294\ub2e4\ub294 \uc810\uc774\ub2e4.\\n\\n## Traversables\\n\\n\ub370\uc774\ud130 \uad6c\uc870\uc758 \uac01 \uc6d0\uc18c \uc704\ub85c \ud568\uc218\ub97c \ub9e4\ud551\ud558\ub294 \uc544\uc774\ub514\uc5b4\ub294 \ud391\ud130\ub77c\ub294 \uac1c\ub150\uc73c\ub85c \ud3ec\ucc29\ub41c\ub2e4.\\n\\n```haskell\\nclass Functor f where\\n    fmap :: (a -> b) -> f a -> f b\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4, \ub9ac\uc2a4\ud2b8\uc758 \uacbd\uc6b0 \uae30\ubcf8 `fmap`\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \uc7ac\uadc0\uc801\uc73c\ub85c \uc815\uc758\ub420 \uc218 \uc788\ub294 \uc775\uc219\ud55c \ub77c\uc774\ube0c\ub7ec\ub9ac \ud568\uc218 `map`\uc774\ub2e4.\\n\\n```haskell\\nmap :: (a -> b) -> [a] -> [b]\\nmap g [] = []\\nmap g (x:xs) = g x : map g xs\\n```\\n\\n\ud558\uc9c0\ub9cc \ub9ac\uc2a4\ud2b8 \uc704\ub85c \ud568\uc218\ub97c \ub9e4\ud551\ud558\ub294 \uc544\uc774\ub514\uc5b4\ub294 \uc77c\ubc18\ud654\ub420 \uc218 \uc788\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \uac01 \uc6d0\uc18c\uc5d0 \uc801\uc6a9\ub418\ub294 \ud568\uc218 `g`\uac00 \uc2e4\ud328\ud560 \uc218 \uc788\ub2e4\uace0 \uac00\uc815\ud574\ubcf4\uc790. \uc989, `a -> b`\uac00 \uc544\ub2cc `a -> Maybe b` \ud0c0\uc785\uc744 \uac16\ub294\ub2e4\ub294 \uc758\ubbf8\uc774\ub2e4. \uadf8\ub9ac\uace0 \uc804\uccb4 \ub9e4\ud551\uc740 \ubaa8\ub4e0 \uac1c\ubcc4 \uc801\uc6a9\uc774 \uc131\uacf5\ud560 \uacbd\uc6b0\uc5d0\ub9cc \uc131\uacf5\ud55c\ub2e4\uace0 \ud558\uc790. `Maybe`\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c(applicative)\ub77c\ub294 \uc0ac\uc2e4\uc744 \uc774\uc6a9\ud558\uba74, \uc774 \ub3d9\uc791\uc744 \uad6c\ud604\ud558\ub294 \ud568\uc218\ub97c \uc27d\uac8c \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n\\n```haskell\\ntraverse :: (a -> Maybe b) -> [a] -> Maybe [b]\\ntraverse g []     = pure []\\ntraverse g (x:xs) = pure (:) <*> g x <*> traverse g xs\\n```\\n\\n\uc774 \uc815\uc758\uc758 \uc7ac\uadc0 \uad6c\uc870\ub294 `map`\uacfc \ubcf8\uc9c8\uc801\uc73c\ub85c \ub3d9\uc77c\ud558\uc9c0\ub9cc, \uc2e4\ud328 \uac00\ub2a5\uc131\uc744 \uad00\ub9ac\ud558\uae30 \uc704\ud574 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uba54\ucee4\ub2c8\uc998\uc774 \uc0ac\uc6a9\ub418\uc5c8\ub2e4\ub294 \uc810\uc774 \ub2e4\ub974\ub2e4. \uc774\ub7f0 \uc2dd\uc73c\ub85c, `traverse`\ub294 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub9ac\uc2a4\ud2b8\uc758 \uc6d0\uc18c\ub97c \uc21c\ud68c\ud558\ub294 \uac04\ub2e8\ud55c \uc218\ub2e8\uc744 \uc81c\uacf5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \uc815\uc218\uac00 \uc591\uc218\uc77c \ub54c\ub9cc 1\uc744 \uac10\uc18c\uc2dc\ud0a4\ub294 \ud568\uc218\ub97c \uc815\uc758\ud558\uae30 \uc704\ud574 `Maybe` \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud55c\ub2e4\uace0 \uac00\uc815\ud574\ubcf4\uc790.\\n\\n```haskell\\ndec :: Int -> Maybe Int\\ndec n = if n > 0 then Just (n-1) else Nothing\\n```\\n\\n\uadf8\ub7ec\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```haskell\\n> traverse dec [1,2,3]\\nJust [0,1,2]\\n\\n> traverse dec [2,1,0]\\nNothing\\n```\\n\\n\ub180\ub78d\uc9c0 \uc54a\uac8c\ub3c4, \uc704\uc640 \uac19\uc740 \ubc29\uc2dd\uc73c\ub85c \ub370\uc774\ud130 \uad6c\uc870\ub97c \uc21c\ud68c\ud558\ub294 \uc544\uc774\ub514\uc5b4\ub294 \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc5d0\ub9cc \uad6d\ud55c\ub418\uc9c0 \uc54a\uc73c\uba70, \uc2e4\ud328\ud560 \uc218 \uc788\ub294 \uc778\uc790 \ud568\uc218\uc5d0\ub9cc \ud2b9\uc815\ub418\uc9c0\ub3c4 \uc54a\ub294\ub2e4. \uc774\ub7ec\ud55c \uc77c\ubc18\ud654\ub41c \ub9e4\ud551\uc744 \uc9c0\uc6d0\ud558\ub294 \ud0c0\uc785 \ud074\ub798\uc2a4\ub97c \uc21c\ud68c \uac00\ub2a5\ud55c \ud0c0\uc785(traversable types), \uc904\uc5ec\uc11c **\ud2b8\ub798\ubc84\uc11c\ube14(traversables)** \uc774\ub77c\uace0 \ubd80\ub978\ub2e4. \\n\\n\ud558\uc2a4\ucf08\uc5d0\uc11c \uc774 \uac1c\ub150\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \ub0b4\uc7a5 \ud074\ub798\uc2a4 \uc120\uc5b8\uc73c\ub85c \uad6c\ud604\ub41c\ub2e4.\\n\\n```haskell\\nclass (Functor t, Foldable t) => Traversable t where\\n    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\\n```\\n\\n\uc989, \ud391\ud130\uc774\uba74\uc11c \ud3f4\ub354\ube14\uc778 \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785 `t`\uac00 `Traversable` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub418\ub824\uba74, \uba85\uc2dc\ub41c \ud0c0\uc785\uc758 `traverse` \ud568\uc218\ub97c \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4.\\n\\n- `t`\uac00 **\ud391\ud130(functor)** \uc5ec\uc57c \ud55c\ub2e4\ub294 \uc694\uad6c\uc0ac\ud56d\uc740 \ud2b8\ub798\ubc84\uc11c\ube14\uc774 \ub9e4\ud551\uc758 \uc544\uc774\ub514\uc5b4\ub97c \uc77c\ubc18\ud654\ud558\ubbc0\ub85c `fmap` \uae30\ubcf8 \ud568\uc218\ub97c \uc9c0\uc6d0\ud560 \uac83\uc73c\ub85c \uae30\ub300\ub41c\ub2e4\ub294 \uc0ac\uc2e4\uc744 \ubc18\uc601\ud55c\ub2e4.\\n- `t`\uac00 **\ud3f4\ub354\ube14(foldable)** \uc774\uc5b4\uc57c \ud55c\ub2e4\ub294 \uc694\uad6c\uc0ac\ud56d\uc740 \ud2b8\ub798\ubc84\uc11c\ube14 \ud0c0\uc785\uc758 \uac12\ub4e4\uc774 \uc6d0\ud55c\ub2e4\uba74 \ud3f4\ub529\ub420 \uc218\ub3c4 \uc788\uc74c\uc744 \ubcf4\uc7a5\ud55c\ub2e4.\\n\\n### Examples\\n\\n\ub9ac\uc2a4\ud2b8\ub294 \ud391\ud130\uc774\uba74\uc11c \ud3f4\ub354\ube14\uc774\uae30 \ub54c\ubb38\uc5d0, \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc740 `traverse`\ub97c `Maybe` \ud0c0\uc785\uc5d0\uc11c \uc784\uc758\uc758 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\ub85c \ub2e8\uc21c\ud558\uac8c \uc77c\ubc18\ud654\ud568\uc73c\ub85c\uc368 \ud2b8\ub798\ubc84\uc11c\ube14\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc989, \uc815\uc758\ub294 \ub3d9\uc77c\ud558\uac8c \uc720\uc9c0\ub418\uc9c0\ub9cc \ud0c0\uc785\uc740 \uc77c\ubc18\ud654\ub41c\ub2e4.\\n\\n```haskell\\ninstance Traversable [] where\\n    -- traverse :: Applicative f => (a -> f b) -> [a] -> f [b]\\n    traverse g []     = pure []\\n    traverse g (x:xs) = pure (:) <*> g x <*> traverse g xs\\n```\\n\\n\ud2b8\ub9ac\uc5d0 \ub300\ud55c \uc778\uc2a4\ud134\uc2a4\ub3c4 \ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c \uc815\uc758\ub420 \uc218 \uc788\uc9c0\ub9cc, \uc778\uc790 \ud568\uc218\uc758 \uc801\uc6a9\uc774 \uae30\ubcf8 \ucf00\uc774\uc2a4(base case)\uc5d0\uc11c \uc77c\uc5b4\ub09c\ub2e4\ub294 \uc810\uc774 \ub2e4\ub974\ub2e4.\\n\\n```haskell\\ninstance Traversable Tree where\\n    -- traverse :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)\\n    traverse g (Leaf x)   = pure Leaf <*> g x\\n    traverse g (Node l r) = pure Node <*> traverse g l <*> traverse g r\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4, \uc774\uc81c `traverse`\ub294 \uc774\uc804 \uc139\uc158\uc758 `dec`\uc640 \uac19\uc774 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 \ud568\uc218\ub97c \ub9ac\uc2a4\ud2b8\uc640 \ud2b8\ub9ac \ubaa8\ub450\uc5d0 \ub9e4\ud551\ud558\ub294 \ub370 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> traverse dec [1,2,3]\\nJust [0,1,2]\\n\\n> traverse dec [2,1,0]\\nNothing\\n\\n> traverse dec (Node (Leaf 1) (Leaf 2))\\nJust (Node (Leaf 0) (Leaf 1))\\n\\n> traverse dec (Node (Leaf 0) (Leaf 1))\\nNothing\\n```\\n\\n### Other primitives and defaults\\n\\n`traverse` \uae30\ubcf8 \ud568\uc218 \uc678\uc5d0\ub3c4 `Traversable` \ud074\ub798\uc2a4\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \ucd94\uac00 \ud568\uc218\uc640 \uae30\ubcf8 \uc815\uc758\ub97c \ud3ec\ud568\ud55c\ub2e4.\\n\\n```haskell\\nsequenceA :: Applicative f => t (f a) -> f (t a)\\nsequenceA = traverse id\\n```\\n\\n`sequenceA`\uc758 \ud0c0\uc785\uc740 \uc774 \ud568\uc218\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc561\uc158\uc744 \uc6d0\uc18c\ub85c \uac16\ub294 \ub370\uc774\ud130 \uad6c\uc870\ub97c, \ub370\uc774\ud130 \uad6c\uc870\ub97c \ubc18\ud658\ud558\ub294 \ub2e8\uc77c \uc561\uc158\uc73c\ub85c \ubcc0\ud658\ud568\uc744 \ub098\ud0c0\ub0b8\ub2e4. \uadf8\ub9ac\uace0 \uadf8 \uc815\uc758\ub294 \ud56d\ub4f1 \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \uad6c\uc870\ub97c \uc21c\ud68c\ud568\uc73c\ub85c\uc368 \uc774\ub97c \ub2ec\uc131\ud55c\ub2e4\uace0 \ub9d0\ud558\ub294\ub370, \uc774 \uacbd\uc6b0 \ud56d\ub4f1 \ud568\uc218\ub294 `f a -> f a` \ud0c0\uc785\uc744 \uac16\ub294\ub2e4. \uc608\ub97c \ub4e4\uc5b4, `sequenceA`\ub294 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \ud3ec\ud568\ud558\ub294 \ub370\uc774\ud130 \uad6c\uc870\ub97c \ubcc0\ud658\ud558\ub294 \ub370 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n```haskell\\n> sequenceA [Just 1, Just 2, Just 3]\\nJust [1,2,3]\\n\\n> sequenceA [Just 1, Nothing, Just 3]\\nNothing\\n\\n> sequenceA (Node (Leaf (Just 1)) (Leaf (Just 2)))\\nJust (Node (Leaf 1) (Leaf 2))\\n\\n> sequenceA (Node (Leaf (Just 1)) (Leaf Nothing))\\nNothing\\n```\\n\\n\ubc18\ub300\ub85c, \ud074\ub798\uc2a4 \uc120\uc5b8\uc740 `sequenceA`\ub97c \uc774\uc6a9\ud55c `traverse`\uc758 \uae30\ubcf8 \uc815\uc758\ub3c4 \ud3ec\ud568\ud55c\ub2e4. \uc774\ub294 effect\uac00 \uc788\ub294 \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub370\uc774\ud130 \uad6c\uc870\ub97c \uc21c\ud68c\ud558\uae30 \uc704\ud574, \uba3c\uc800 `fmap`\uc744 \uc0ac\uc6a9\ud558\uc5ec \uac01 \uc6d0\uc18c\uc5d0 \ud568\uc218\ub97c \uc801\uc6a9\ud55c \ub2e4\uc74c `sequenceA`\ub97c \uc0ac\uc6a9\ud558\uc5ec \ubaa8\ub4e0 effect\ub97c \uacb0\ud569\ud560 \uc218 \uc788\uc74c\uc744 \ud45c\ud604\ud55c\ub2e4.\\n\\n```haskell\\n-- traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\\ntraverse g = sequenceA . fmap g\\n```\\n\\n`Traversable` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \uc120\uc5b8\ud558\ub824\uba74 `traverse`\ub098 `sequenceA` \uc911 \ud558\ub098\ub97c \uc815\uc758\ud558\ub294 \uac83\uc73c\ub85c \ucda9\ubd84\ud558\ub2e4. \ub2e4\ub978 \ud558\ub098\ub294 \uc704 \uae30\ubcf8 \uc815\uc758\ub97c \uc0ac\uc6a9\ud558\uc5ec \ud30c\uc0dd\ub420 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \ud558\uc9c0\ub9cc `traverse`\uc758 \uae30\ubcf8 \uc815\uc758\ub294 \ub370\uc774\ud130 \uad6c\uc870\ub97c \ub450 \ubc88 \uc21c\ud68c(\ud55c \ubc88\uc740 `fmap`, \ud55c \ubc88\uc740 `sequenceA`)\ud558\ubbc0\ub85c, `sequenceA`\ubcf4\ub2e4\ub294 `traverse`\ub97c \uc815\uc758\ud558\ub294 \uac83\uc774 \uc77c\ubc18\uc801\uc73c\ub85c \uc120\ud638\ub41c\ub2e4.\\n\\n\ub9c8\uc9c0\ub9c9\uc73c\ub85c, \ud074\ub798\uc2a4\ub294 \uad00\ub828\ub41c \ud6a8\uacfc\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uac00 \uc544\ub2cc \ubaa8\ub098\ub4dc\uc778 \ud2b9\ubcc4\ud55c \uacbd\uc6b0\ub97c \uc704\ud574 \ub450 \ud2b8\ub798\ubc84\uc11c\ube14 \uae30\ubcf8 \ud568\uc218\uc5d0 \ub300\ud55c \ud2b9\ubcc4\ud55c \uc774\ub984\ub3c4 \uc81c\uacf5\ud55c\ub2e4.\\n\\n```haskell\\nmapM     :: Monad m => (a -> m b) -> t a -> m (t b)\\nmapM     = traverse\\n\\nsequence :: Monad m => t (m a) -> m (t a)\\nsequence = sequenceA\\n```\\n\\n\uacb0\ub860\uc801\uc73c\ub85c, \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \uc120\uc5b8\ud560 \ub54c `traverse`\ub098 `sequenceA` \uae30\ubcf8 \ud568\uc218 \uc911 \ud558\ub098\ub97c \uc815\uc758\ud568\uc73c\ub85c\uc368 \uadf8 \ud0c0\uc785\uc744 \ud2b8\ub798\ubc84\uc11c\ube14 \ud0c0\uc785\uc73c\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub294\uc9c0 \uace0\ub824\ud558\ub294 \uac83\uc774 \uc720\uc6a9\ud558\ub2e4. \uadf8\ub807\uac8c \ud558\ub294 \uac83\uc758 \uc7a5\uc810\uc740 `Traversable` \ud074\ub798\uc2a4\uc758 \uae30\ubcf8 \uc815\uc758\ub4e4\uc744 \ud1b5\ud574 \ud574\ub2f9 \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud55c effectful \ud504\ub85c\uadf8\ub798\ubc0d\uc744 \uc704\ud55c \uc5ec\ub7ec \uc720\uc6a9\ud55c \ud568\uc218\ub4e4\uc744 \uc81c\uacf5\ubc1b\ub294\ub2e4\ub294 \uc810\uc774\ub2e4."},{"id":"intro-wait-free-algorithms","metadata":{"permalink":"/blog/intro-wait-free-algorithms","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09-03-wait-free-algo/index.md","source":"@site/blog/2025-09-03-wait-free-algo/index.md","title":"An Introduction to wait-free algorithms","description":"image.png","date":"2025-09-03T00:00:00.000Z","tags":[{"inline":false,"label":"C++","permalink":"/blog/tags/cpp","description":"C++ tag description"},{"inline":false,"label":"\ub3d9\uc2dc\uc131 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/concurrent-programming","description":"\ub3d9\uc2dc\uc131 \ud504\ub85c\uadf8\ub798\ubc0d\uc5d0 \ub300\ud55c \uae00"}],"readingTime":12.85,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"intro-wait-free-algorithms","title":"An Introduction to wait-free algorithms","authors":["dream2405"],"tags":["C++","concurrent_programming"],"image":"./image.png"},"unlisted":false,"prevItem":{"title":"Foldables and friends","permalink":"/blog/foldables-and-friends"},"nextItem":{"title":"Monads and more","permalink":"/blog/monads-and-more"}},"content":"![image.png](image.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n[\uc720\ud29c\ube0c \ub9c1\ud06c](https://youtu.be/kPh8pod0-gk?si=fnCqMylNxru464Ot)\\n\\n\uc774 \uae00\uc740 CppCon 2024\uc5d0\uc11c \uce74\ub124\uae30 \uba5c\ub7f0 \ub300\ud559\uad50\uc758 \uc870\uad50\uc218(assistant teaching professor), \\nDaniel Anderson\uc774 \ubc1c\ud45c\ud55c \uc790\ub8cc\ub97c \ubc14\ud0d5\uc73c\ub85c \uc791\uc131\ub418\uc5c8\ub2e4.\\n\\n---\\n\\n## \ubc30\uc6b8 \ub0b4\uc6a9\\n\\n- \ub3d9\uc2dc\uc131\uacfc lock-free \ud504\ub85c\uadf8\ub798\ubc0d\uc5d0 \ub300\ud55c \uac04\ub2e8\ud55c \ubcf5\uc2b5\\n- lock-free \uc124\uacc4 \ud328\ud134\uc758 \\"\uae30\ubcf8\uc801\uc778\\" \ub0b4\uc6a9 \uac80\ud1a0\\n- wait-free \uc54c\uace0\ub9ac\uc998\uc758 \uc815\uc758\uc640 \uc2e4\uc81c \uc801\uc6a9\uc5d0 \ub300\ud55c \uc774\ud574\\n- \uc6b0\uc544\ud55c wait-free \uc54c\uace0\ub9ac\uc998\uacfc wait-free \uc124\uacc4\uc758 \uc608\uc2dc\\n- \uac04\ub2e8\ud55c \ubca4\uce58\ub9c8\ud06c \uacb0\uacfc\\n\\n### \ud574\uacb0\ud558\uace0\uc790 \ud558\ub294 \ubb38\uc81c\\n\\nsticky counter (0\uc5d0\uc11c \uba48\ucd94\ub294 \uce74\uc6b4\ud130)\ub97c \uad6c\ud604\ud558\uace0 \uc2f6\ub2e4\uace0 \uac00\uc815\ud558\uc790.\\n\\n`Counter` \uad6c\uc870\uccb4\uc758 \uae30\ubcf8\uc801\uc778 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```cpp\\n// Precondition: The counter is not zero\\nstruct Counter {\\n    // If the counter is greater than zero, add one and return true\\n    // otherwise do nothing and return false\\n    bool increment_if_not_zero();\\n    \\n    // Decrement the counter. If the counter now equals zero,\\n    // return true. Otherwise return false.\\n    bool decrement();\\n    \\n    uint64_t read(); // Return the current value of the counter\\n};\\n```\\n\\n`Counter` \uad6c\uc870\uccb4\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \uc138 \uac00\uc9c0 \uc8fc\uc694 \uae30\ub2a5\uc744 \uc81c\uacf5\ud55c\ub2e4.\\n\\n- `increment_if_not_zero()` : \uce74\uc6b4\ud130 \uc99d\uac00\ub97c \uc2dc\ub3c4\\n    - \uce74\uc6b4\ud130\uac00 `0`\ubcf4\ub2e4 \ud06c\uba74 `1`\uc744 \ub354\ud558\uace0 `true` \ubc18\ud658\\n    - \uce74\uc6b4\ud130\uac00 `0`\uc774\uba74 \uc544\ubb34\uac83\ub3c4 \ud558\uc9c0 \uc54a\uace0 `false` \ubc18\ud658\\n- `decrement()` : \uce74\uc6b4\ud130\ub97c \uac10\uc18c\\n    - \uce74\uc6b4\ud130\ub97c \uac10\uc18c\uc2dc\ud0a8 \ud6c4  `0`\uc774 \ub418\uba74 `true` \ubc18\ud658\\n    - \uce74\uc6b4\ud130\ub97c \uac10\uc18c\uc2dc\ud0a8 \ud6c4  `0`\uc774 \uc544\ub2c8\ub77c\uba74 `false` \ubc18\ud658\\n- `read()` : \ud604\uc7ac \uce74\uc6b4\ud130 \uac12\uc744 \ubc18\ud658\\n\\n:::note\\n\\n\uc774\ub7f0 \ubc29\uc2dd\uc758 \uce74\uc6b4\ud130\ub294 \ub9e4\uc6b0 \uc2e4\uc6a9\uc801\uc774\ub2e4. \\n\ub3d9\uc2dc\uc131 \uc790\ub8cc\uad6c\uc870\ub098, \uba40\ud2f0\uc2a4\ub808\ub529 \ud658\uacbd\uc5d0\uc11c\uc758 \uba54\ubaa8\ub9ac \uad00\ub9ac\uc5d0 \ub9e4\uc6b0 \uc801\ud569\ud558\ub2e4.\\n\\n\uc608\ub85c \ub4e4\uc5b4 `std::weak_ptr<T>::lock`\uc5d0 \uc774\ub7f0 \ubc29\uc2dd\uc758 \uce74\uc6b4\ud130\uac00 \ud544\uc694\ud558\ub2e4.\\n\\n`std::weak_ptr<T>::lock` \uc758 \uc8fc\uc694 \uae30\ub2a5\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n- `weak_ptr`\uac00 \uac00\ub9ac\ud0a4\ub294 \uac1d\uccb4\uac00 \uc544\uc9c1 \uc720\ud6a8\ud55c\uc9c0 \ud655\uc778\\n- \uc720\ud6a8\ud558\ub2e4\uba74 \ud574\ub2f9 \uac1d\uccb4\uc5d0 \ub300\ud55c `shared_ptr`\ub97c \ubc18\ud658\\n- \uac1d\uccb4\uac00 \uc774\ubbf8 \uc0ad\uc81c\ub418\uc5c8\ub2e4\uba74 \ube48 `shared_ptr` (`nullptr`\uc744 \uac00\ub9ac\ud0b4)\uc744 \ubc18\ud658\\n\\n\ub530\ub77c\uc11c `weak_ptr`\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \ub3d9\uc791\ud574\uc57c \ud55c\ub2e4.\\n\\n- \uac1d\uccb4\uc758 \uc218\uba85\uc744 \ucd94\uc801\ud558\ub418 reference count\ub294 \uc99d\uac00\ub418\uc9c0 \uc54a\uc74c\\n- `lock()` \ud638\ucd9c \uc2dc \uac1d\uccb4\uac00 \uc544\uc9c1 \uc874\uc7ac\ud558\ub294\uc9c0 \ud655\uc778\ud574\uc57c \ud568\\n- \ud655\uc778\ud558\ub294 \ub3d9\uc548 \ub2e4\ub978 \uc2a4\ub808\ub4dc\uc5d0\uc11c \uac1d\uccb4\ub97c \uc0ad\uc81c\ud560 \uc218 \uc788\uc74c\\n\\n\uc5ec\uae30\uc11c `Counter` \uc758 \uc5ed\ud560\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n- \uac1d\uccb4\uac00 \uc544\uc9c1 \uc0b4\uc544\uc788\ub294\uc9c0(reference count > 0) \ud655\uc778\\n- \uc0b4\uc544\uc788\ub2e4\uba74 reference count\ub97c \uc99d\uac00\uc2dc\ucf1c \uac1d\uccb4 \uc218\uba85 \uc5f0\uc7a5\\n- \uc774 \ub450 \uc791\uc5c5\uc774 atomic\ud558\uac8c \uc774\ub904\uc838\uc57c \ud568\\n\\n:::\\n\\n\uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud574\ubcf4\uc790.\\n\\n## \uccab \ubc88\uc9f8 \uad6c\ud604\\n\\n```cpp\\nstruct Counter {\\n    bool increment_if_not_zero() {\\n        if (counter > 0) {\\n            counter++;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool decrement() {\\n        return (--counter == 0);\\n    }\\n\\n    uint64_t read() { return counter; }\\n\\n    uint64_t counter{1};\\n};\\n```\\n\\n\ub3d9\uc2dc\uc131 \ud658\uacbd\uc744 \uace0\ub824\ud558\uc9c0 \uc54a\uc740 \ub2e8\uc21c\ud55c \uad6c\ud604\uc774\ub2e4. \uc774\ub7f0 \ubc29\uc2dd\uc758 \uad6c\ud604\uc740 \uc2f1\uae00 \uc2a4\ub808\ub4dc \ud658\uacbd\uc5d0\uc11c\ub294 \ubb38\uc81c\uac00 \uc5c6\uc9c0\ub9cc, \uba40\ud2f0 \uc2a4\ub808\ub4dc \ud658\uacbd\uc5d0\uc11c\ub294 \ubb38\uc81c\uac00 \uc0dd\uae38 \uac83\uc784\uc744 \uc54c\uc544\ucc28\ub9b4 \uc218 \uc788\uc744 \uac83\uc774\ub2e4.\\n\\n### Thread safe \ud558\uac8c \ub9cc\ub4e4\uae30\\n\\n```cpp\\nstruct Counter {\\n    bool increment_if_not_zero() {\\n        std::lock_guard g_{m};\\n        if (counter > 0) {\\n            counter++;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool decrement() {\\n        std::lock_guard g_{m};\\n        return (--counter == 0);\\n    }\\n    \\n    std::mutex m;\\n    \\n    uint64_t counter{1};\\n}\\n```\\n\\n\ub450 \ud568\uc218\ub97c \uc2a4\ub808\ub4dc-\uc548\uc804\ud558\uac8c \ub9cc\ub4e4\uc5c8\ub2e4.\\n\\n:::info\\n\\n`std::lock_guard`\ub294 C++\uc758 RAII(Resource Acquisition Is Initialization) \ud328\ud134\uc744 \ud65c\uc6a9\ud55c mutex wrapper \ud074\ub798\uc2a4\uc774\ub2e4.\\n\\n\uc774\ub97c \ud1b5\ud574 \ubba4\ud14d\uc2a4\ub97c lock\ud558\uba74, \uba85\uc2dc\uc801\uc778 unlock \ub300\uc2e0 \uc2a4\ucf54\ud504\ub97c \ubc97\uc5b4\ub098\uba74 \uc790\ub3d9\uc73c\ub85c \uc18c\uba78\ub418\uac8c \ub9cc\ub4e4\uc5b4 mutex\ub3c4 \uc790\ub3d9\uc73c\ub85c \ud574\uc81c\ub41c\ub2e4.\\n\\n:::\\n\\n\uc774\ub97c \ud1b5\ud574 \ubb34\uc5c7\uc744 \uc54c \uc218 \uc788\ub294\uac00?\\n\\n## \uc2dc\uc0ac\uc810\\n\\n- \uc774\ub7f0 \ubc29\uc2dd\uc740 \ub3d9\uc2dc\uc131 \ubb38\uc81c\uc758 \ub300\ubd80\ubd84\uc744 \ud574\uacb0\ud560 \uc218 \uc788\ub2e4\\n- \ud558\uc9c0\ub9cc \uc774\ub294 \uc2e4\uc9c8\uc801\uc73c\ub85c **\ub3d9\uc2dc\uc131\uc744 \uc81c\uac70**\ud568\uc73c\ub85c\uc368 \ud574\uacb0\ud558\ub294 \uac83.\\n- \uc774\ub7f0 \ubc29\uc2dd\uc740 \ub300\uccb4\ub85c(\ud56d\uc0c1\uc740 \uc544\ub2d8) \uc131\ub2a5\uc5d0 \ud070 \uc601\ud5a5\uc744 \ubbf8\uce5c\ub2e4\\n    - \uc8fc\uc758\uc0ac\ud56d: \uc131\ub2a5\uc5d0 \ub300\ud574 **\ucd94\uce21\ud558\uc9c0 \ub9c8\ub77c**. \ud56d\uc0c1 **\uc131\ub2a5\uc744 \uce21\uc815**\ud574\uc57c \ud55c\ub2e4.\\n\\n:::note\\n\\n\uc2e4\uc9c8\uc801\uc73c\ub85c \ub3d9\uc2dc\uc131\uc744 \uc81c\uac70\ud568\uc73c\ub85c\uc368 \ud574\uacb0\ud558\ub294 \uac83\uc774\ub77c\ub294 \ube44\ud310\uc740 critical section\uc5d0 \ub300\ud574 \uc598\uae30\ud558\ub294 \uac83 \uac19\ub2e4.\\n\\n\ucf54\ub4dc\uc758 \uc77c\ubd80\ubd84\uc5d0 \ub300\ud574 **\ub3d9\uc2dc\uc131 \uc0c1\ud669\uc744 \ucc28\ub2e8**\ud574\ubc84\ub9bc\uc73c\ub85c\uc368, \ub3d9\uc2dc\uc131 \uc0c1\ud669\uc774 \uc560\ucd08\ubd80\ud130 \uc77c\uc5b4\ub098\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub2f9\uc5f0\ud788 \ub3d9\uc2dc\uc131 \ubb38\uc81c\ub294 \ubc1c\uc0dd\ud558\uc9c0 \uc54a\ub294\ub2e4.\\n\\n\uc774\ub294 \uc5b4\ub5bb\uac8c \ubcf4\uba74 \ub9e4\uc6b0 \ub2e8\uc21c\ud55c \ud574\uacb0 \ubc29\ubc95\uc774\ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\uc81c\ub97c \ud574\uacb0\ud558\ub294 \uac83\uc774 \uc544\ub2c8\ub77c **\ubb38\uc81c\uac00 \ubc1c\uc0dd\ud560 \uac83 \uac19\uc740 \uc0c1\ud669**\uc744 \ucc28\ub2e8\ud574\ubc84\ub9ac\ub294 \uac83\uc774\uae30 \ub54c\ubb38\uc774\ub2e4.\\n\\n:::\\n\\n\uadf8\ub807\ub2e4\uba74 \ub354 \ubc1c\uc804\ub41c \ubc29\uc2dd\uc740 \uc5b4\ub5a4\uac83\ub4e4\uc774 \uc788\ub294\uac00?\\n\\n## \uc9c4\ud589 \ubcf4\uc7a5(Progress guarantees)\\n\\n\uc9c4\ud589 \ubcf4\uc7a5\uc774\ub780 \ub3d9\uc2dc\uc131 \uc54c\uace0\ub9ac\uc998\uc744 \uc774\ub860\uc801\uc73c\ub85c \ubd84\ub958\ud558\ub294 \ubc29\ubc95\uc774\ub2e4.\\n\\n- **Blocking**: \ubcf4\uc7a5 \uc5c6\uc74c\\n    - \uc55e\uc11c \ubcf8 \ubba4\ud14d\uc2a4\ub97c \uc0ac\uc6a9\ud55c \ubc29\uc2dd\uc774 \ud55c \uc608\uc2dc\\n    - \ub2e4\ub978 \uc2a4\ub808\ub4dc\uac00 mutex\ub97c \ubcf4\uc720\ud558\uace0 \uc788\uc73c\uba74, \ud604\uc7ac \uc2a4\ub808\ub4dc\ub294 \ubb34\uc870\uac74 \ub300\uae30\ud574\uc57c \ud55c\ub2e4\\n    - \ub2e4\ub978 \ubaa8\ub4e0 \uc2a4\ub808\ub4dc\uac00 \uc911\ub2e8\ub418\ub354\ub77c\ub3c4(isolation \uc0c1\ud0dc), mutex\ub97c \ubcf4\uc720\ud55c \uc2a4\ub808\ub4dc\uac00 \uc0b4\uc544\uc788\uc9c0 \uc54a\ub2e4\uba74 \uc601\uc6d0\ud788 \uc9c4\ud589\ud558\uc9c0 \ubabb\ud560 \uc218 \uc788\uc74c - deadlock \ubc1c\uc0dd \uac00\ub2a5\uc131\\n- **Obstruction free** (isolation\uc5d0\uc11c\uc758 \uc9c4\ud589): \ud558\ub098\uc758 \uc2a4\ub808\ub4dc\uac00 \uaca9\ub9ac\ub41c \uc0c1\ud0dc\uc5d0\uc11c \uc2e4\ud589\ub418\uba74 \uc720\ud55c\ud55c \uc218\uc758 \ub2e8\uacc4 \ub0b4\uc5d0 \uc5f0\uc0b0\uc744 \uc644\ub8cc\\n    - \uc5b4\ub5a0\ud55c \uc2a4\ub808\ub4dc\ub4e0\uc9c0 \uac04\uc5d0, \ud558\ub098\uc758 \uc2a4\ub808\ub4dc \uc678\uc5d0 \ub2e4\ub978 \ubaa8\ub4e0 \uc2a4\ub808\ub4dc\uac00 \uc911\ub2e8\ub41c \uc0c1\ud0dc\ub77c\uba74 \uc5b4\ub5a0\ud55c \uc0c1\ud669\uc774\ub4e0\uc9c0 \uac04\uc5d0 \ubc18\ub4dc\uc2dc \uc720\ud55c\ud55c \ub2e8\uacc4 \ub0b4\uc5d0 \uc791\uc5c5\uc744 \uc644\ub8cc\ud560 \uc218 \uc788\uc5b4\uc57c \ud55c\ub2e4.\\n    - \ub530\ub77c\uc11c \uc774 \ubc29\uc2dd\uc740 deadlock\uc5d0 \uba74\uc5ed\\n- **Lock free** (\ucd5c\uc18c \ud558\ub098\uc758 \uc2a4\ub808\ub4dc\uac00 \uc9c4\ud589): \uc5b4\ub290 \uc2dc\uc810\uc5d0\uc11c\ub4e0 \ucd5c\uc18c\ud55c \ud558\ub098\uc758 \uc2a4\ub808\ub4dc\ub294 \uc790\uc2e0\uc758 \uc5f0\uc0b0\uc5d0\uc11c \uc9c4\ud589\uc744 \uc774\ub8e8\uace0 \uc788\uc74c\\n    - \uc2dc\uc2a4\ud15c \uc804\uccb4\uc758 \ucc98\ub9ac\ub7c9\uc744 \ubcf4\uc7a5. \uc77c\ubd80 \uc5f0\uc0b0\uc740 \ud56d\uc0c1 \uc644\ub8cc\ub418\uace0 \uc788\uc9c0\ub9cc, \uac1c\ubcc4 \uc5f0\uc0b0\uc758 \uc644\ub8cc\ub294 \uc808\ub300 \ubcf4\uc7a5\ub418\uc9c0 \uc54a\uc74c\\n- **Wait free** (\ubaa8\ub4e0 \uc2a4\ub808\ub4dc\uac00 \uc9c4\ud589): \ub2e4\ub978 \ub3d9\uc2dc \uc5f0\uc0b0\uc5d0 \uad00\uacc4\uc5c6\uc774 \ubaa8\ub4e0 \uc5f0\uc0b0\uc774 \uc720\ud55c\ud55c \uc218\uc758 \ub2e8\uacc4 \ub0b4\uc5d0 \uc644\ub8cc\ub428\\n    - \ubaa8\ub4e0 \uac1c\ubcc4 \uc5f0\uc0b0\uc5d0 \ub300\ud574 \uc720\ud55c\ud55c \uc644\ub8cc \uc2dc\uac04\uc744 \ubcf4\uc7a5\ud568\\n\\n\uc774\uc81c `Counter` \ub97c lock-free\ub85c \uad6c\ud604\ud574\ubcf4\uc790.\\n\\n## lock-free \uad6c\ud604\\n\\n### `counter` \ubcc0\uc218\\n\\n```cpp\\nstd::atomic<uint64_t> counter{1};\\n```\\n\\nlock-free \ud504\ub85c\uadf8\ub798\ubc0d\uc744 \ud560\ub824\uba74, atomic \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4.\\n\\n### `increment_if_not_zero()` \ub97c \uad6c\ud604\\n\\n```cpp\\nbool increment_if_not_zero() {\\n    auto current = counter.load();\\n    while (current > 0 && !counter.compare_exchange_weak(current, current + 1)) { }\\n    return current > 0;\\n}\\n```\\n\\n\uc5ec\uae30\uc11c `compare_exchange_weak()` \ub77c\ub294 \uc5f0\uc0b0\uc774 \ub4f1\uc7a5\ud55c\ub2e4.\\n\\n`counter.compare_exchange_weak(current, current + 1)` \ucf54\ub4dc\uc758 \uc758\ubbf8\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n- `counter`\uc758 \ud604\uc7ac \uac12\uc774 `current`\uc640 \uac19\ub2e4\uba74\\n    - `counter` \uac12\uc744 `current + 1`\ub85c \ubcc0\uacbd\\n    - `true` \ubc18\ud658\\n- \ub2e4\ub974\ub2e4\uba74\\n    - `current`\ub97c `counter`\uc758 \ud604\uc7ac \uac12\uc73c\ub85c \uc5c5\ub370\uc774\ud2b8\\n    - `false` \ubc18\ud658\\n\\n`compare_exchange_weak()` \uc5f0\uc0b0\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \uc774\ub8e8\uc5b4\uc9c4\ub2e4.\\n\\n```cpp\\ncompare_exchange(expected&, desired) {\\n    if (current_value == expected) {\\n        current_value = desired; \\n        return true; \\n    } else { \\n        expected = current_value; \\n        return false; \\n    }\\n}\\n```\\n\\n:::warning\\n\\n\uc2e4\uc81c `compare_exchange` \uc5f0\uc0b0\uc758 \uad6c\ud604\uc740 **\ud558\ub4dc\uc6e8\uc5b4\uc758 \uc9c0\uc6d0 \uc5c6\uc774\ub294 \ubd88\uac00\ub2a5**\ud558\ub2e4.\\n\ucf54\ub4dc\ub85c \uad6c\ud604\ud558\ub824\uba74 \uacb0\uad6d \uc5b4\ub5a0\ud55c \ud615\ud0dc\ub85c\ub4e0 lock\uc774 \ud544\uc694\ud558\uae30 \ub54c\ubb38\uc5d0 atomic\ud568\uc744 \ubcf4\uc7a5\ud560 \uc218 \uc5c6\ub2e4.\\n\\n\uc2e4\uc81c\ub85c\ub294 ARM, x86_64 \ub4f1\uc758 \uc544\ud0a4\ud14d\ucc98\uc5d0\uc11c atomic \uc5f0\uc0b0\uc744 \uc704\ud55c \uba85\ub839\uc5b4\ub97c \uc81c\uacf5\ud558\ubbc0\ub85c \uc774\ub97c \ud1b5\ud574 \uad6c\ud604\ud55c\ub2e4.\\n\\n:::\\n\\n\uc774\ub7f0 \ubc29\uc2dd\uc744 **CAS loop**\ub77c\uace0 \ud55c\ub2e4.\\n\\n### `decrement()` \uad6c\ud604\\n\\n```cpp\\nbool decrement() {\\n    return counter.fetch_sub(1) == 1;\\n}\\n```\\n\\n`counter.fetch_sub(1)` \ucf54\ub4dc\uc758 \uc758\ubbf8\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n- `counter`\ub97c `1` \uac10\uc18c\uc2dc\ud0a4\uace0 \uc6d0\ub798\uc758 `counter` \uac12 \ubc18\ud658\\n\\n\ub530\ub77c\uc11c \ubc18\ud658\uac12\uc774  `1`\uc774\uc5c8\ub2e4\uba74 \uac10\uc18c \ud6c4 `0`\uc774 \ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uc774\ubbc0\ub85c `true` \ub97c \ubc18\ud658\ud55c\ub2e4.\\n\\n### \uc804\uccb4 \ucf54\ub4dc\\n\\n```cpp\\nstruct Counter {\\n    bool increment_if_not_zero() {\\n        auto current = counter.load();\\n        while (current > 0 && !counter.compare_exchange_weak(current, current + 1)) { }\\n        return current > 0;\\n    }\\n    \\n    bool decrement() {\\n        return counter.fetch_sub(1) == 1;\\n    }\\n    \\n    uint64_t read() { return counter.load(); }\\n    \\n    std::atomic<uint64_t> counter{1};\\n}\\n```\\n\\n## **CAS loop**\\n\\n\uc774\ub7f0 CAS loop(compare-and-swap loop) \ubc29\uc2dd\uc740 lock-free \uc54c\uace0\ub9ac\uc998\uacfc \ub370\uc774\ud130 \uad6c\uc870\uc758 \uae30\ubcf8\uc774 \ub418\ub294 \uc124\uacc4 \ud328\ud134\uc774\ub2e4.\\n\\n- \ub370\uc774\ud130 \uad6c\uc870\uc758 \ud604\uc7ac \uc0c1\ud0dc\ub97c \uc77d\uc74c\\n- \ud604\uc7ac \uc0c1\ud0dc\ub85c\ubd80\ud130 \uc0c8\ub85c\uc6b4 \uc6d0\ud558\ub294 \uc0c1\ud0dc\ub97c \uacc4\uc0b0\\n- \ub2e4\ub978 \ub204\uad70\uac00\uac00 \uc774\ubbf8 \ubcc0\uacbd\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\ub9cc \ubcc0\uacbd\uc744 \ucee4\ubc0b(compare-exchange)\\n- \ub2e4\ub978 \ub204\uad70\uac00\uac00 \ubcc0\uacbd\ud588\ub2e4\uba74, \ub2e4\uc2dc \uc2dc\ub3c4\\n\\n\uc9c4\ud589\uc740 **lock-free**\uc774\ub2e4.\\n\\n- \ub9cc\uc57d \ud55c \uc5f0\uc0b0\uc774 \uc9c4\ud589\ud558\uc9c0 \ubabb\ud588\ub2e4\uba74(compare-exchange\uac00 false\ub97c \ubc18\ud658) \\n\uc774\ub294 \ub2e4\ub978 \uc5f0\uc0b0\uc774 \uc9c4\ud589\ud588\uae30 \ub54c\ubb38\\n- \uc2a4\ub808\ub4dc\ubcc4 \uac1c\ubcc4 \uc5f0\uc0b0\uc740 \uc2e4\ud328\ud558\ub354\ub77c\ub3c4, **\uc2dc\uc2a4\ud15c \uc804\uccb4\uc801\uc73c\ub85c \uc9c4\ud589**\uc740 \ubcf4\uc7a5\\n\\n:::note\\n\\nCAS loop \ubc29\uc2dd\uc774 \uae30\uc874\uc758 blocking \ubc29\uc2dd\uacfc \ub2e4\ub978 \ud575\uc2ec\uc801\uc778 \uc774\uc720\ub294 \uacb0\uad6d **\uc9c4\ud589 \uac00\ub2a5 \uc5ec\ubd80\ub97c \ud310\ub2e8\ud558\ub294 \uc0c1\ud0dc**\uc5d0 \uc788\ub2e4. \\n\\nCAS loop\ub294 `counter` **\uac12 \uc790\uccb4**\uac00 \uc9c4\ud589 \uac00\ub2a5 \uc5ec\ubd80\ub97c \uacb0\uc815\ud55c\ub2e4.\\n\\n- \uc2e4\uc81c \uc791\uc5c5 \ub300\uc0c1(`counter`)\uacfc \uc9c4\ud589 \uac00\ub2a5 \uc5ec\ubd80 \ud310\ub2e8\uc774 \uacb0\ud569\ub418\uc5b4 \uc788\uc74c\\n- `counter` \uac12\uc774 \ubcc0\uacbd\ub418\uc5c8\ub2e4\ub294 \uac83 \u2192 \ub2e4\ub978 \uc2a4\ub808\ub4dc\uac00 \uc9c4\ud589\ud588\ub2e4\ub294 \uac83\\n\\nMutex\ub294 mutex\ub77c\ub294 **\ubcc4\ub3c4\uc758 \uc0c1\ud0dc\uac12**\uc73c\ub85c \uc9c4\ud589 \uac00\ub2a5 \uc5ec\ubd80\ub97c \uacb0\uc815\\n\\n- \uc2e4\uc81c \uc791\uc5c5 \ub300\uc0c1(`counter`)\uacfc \uc9c4\ud589 \uac00\ub2a5 \uc5ec\ubd80 \ud310\ub2e8\uc774 \ubd84\ub9ac\ub418\uc5b4 \uc788\uc74c\\n- `mutex` \ud68d\ub4dd \uc2e4\ud328 \u2192 \uc9c4\ud589 \ubd88\uac00, \ud558\uc9c0\ub9cc \uc774\uac83\uc774 \ub2e4\ub978 \uc2a4\ub808\ub4dc\uc758 \uc9c4\ud589\uc744 \ubcf4\uc7a5\ud558\uc9c0\ub294 \uc54a\uc74c\\n\\n\uc774 \ucc28\uc774\ub85c \uc778\ud574\\n\\n- CAS loop\ub294 \uc9c4\ud589 \uc2e4\ud328\uac00 \uace7 \ub2e4\ub978 \uc2a4\ub808\ub4dc\uc758 \uc9c4\ud589\uc744 \uc758\ubbf8\\n- Mutex\ub294 \uc9c4\ud589 \uc2e4\ud328\uac00 \ub2e4\ub978 \uc2a4\ub808\ub4dc\uc758 \uc9c4\ud589\uc744 \ubcf4\uc7a5\ud558\uc9c0 \uc54a\uc74c\\n\\n\ub530\ub77c\uc11c lock-free\uc758 \uc2dc\uc2a4\ud15c \uc804\uccb4\uc801 \uc9c4\ud589 \ubcf4\uc7a5\uc740 \uc0c1\ud0dc\uac12\uacfc \uc791\uc5c5\uc774 \uacb0\ud569\ub418\uc5b4 \uc788\ub2e4\ub294 \ud2b9\uc131\uc5d0\uc11c \uc790\uc5f0\uc2a4\ub7fd\uac8c \ub3c4\ucd9c\ub418\ub294 \uac83\uc774\ub2e4.\\n\\n:::\\n\\n**wait-free\ub294 \uc544\ub2c8\ub2e4.** \\n\\n- \ud2b9\uc815 \uc5f0\uc0b0\uc774 \uacbd\uc7c1\ud558\ub294 \uc5f0\uc0b0\ub4e4\uc774 \uc131\uacf5\ud558\uba74\uc11c CAS loop\uc5d0\uc11c \uc601\uc6d0\ud788 \uc2e4\ud328\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\\n- \uadf9\ub2e8\uc801\uc778 \uc608\uc2dc\ub85c\ub294, \uba40\ud2f0 \uc2a4\ub808\ub4dc \ud658\uacbd\uc5d0\uc11c \ud558\ub098\uc758 \uc2a4\ub808\ub4dc\ub9cc\uc774 \uc9c4\ud589\ud558\uace0 \ub2e4\ub978 \ubaa8\ub4e0 \uc2a4\ub808\ub4dc\ub4e4\uc774 \uacc4\uc18d \uc2e4\ud328\ud560 \uc218\ub3c4 \uc788\ub2e4.\\n\\n:::info\\n\\n\uc880 \ub354 \uc804\ubb38\uc801\uc778 \uc6a9\uc5b4\ub85c\ub294, lock-free \ubc29\uc2dd\uc740 blocking \ubc29\uc2dd\uacfc\ub294 \ub2ec\ub9ac deadlock \ud604\uc0c1\uc744 \ubc29\uc9c0\ud558\uc9c0\ub9cc, \uac1c\ubcc4 \uc2a4\ub808\ub4dc\uac00 \uc601\uc6d0\ud788 \uc9c4\ud589\ud558\uc9c0 \ubabb\ud558\ub294 **starvation** \ud604\uc0c1\uc740 \ub9c9\uc9c0 \ubabb\ud55c\ub2e4\uace0 \uc124\uba85\ud560 \uc218 \uc788\ub2e4.\\n\\n\uadf8\ub9ac\uace0 \uc774 starvation \ud604\uc0c1\uae4c\uc9c0\ub3c4 \ub9c9\ub294 \uac83\uc774 wait-free \ubc29\uc2dd\uc758 \ubaa9\ud45c \uc911 \ud558\ub098\uc774\ub2e4.\\n\\n:::\\n\\n\uadf8\ub807\ub2e4\uba74 wait-free\ub294 \uc5b4\ub5bb\uac8c \uc124\uacc4\ud574\uc57c \ud558\ub294\uac00?\\n\\n## Wait Freedom \ub3c4\uad6c\ub4e4\\n\\nwait-free \uc54c\uace0\ub9ac\uc998\uc740 \ubb34\ud55c\ud55c CAS \ub8e8\ud504\ub97c \ud3ec\ud568\ud560 \uc218 \uc5c6\ub2e4.\\n\\n- \uc774\ub294 compare-exchange\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\ub2e4\ub294 \uc758\ubbf8\uac00 \uc544\ub2c8\ub77c, \ub2e8\uc9c0 \ubb34\ud55c \ub8e8\ud504 \uc548\uc5d0\uc11c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\ub2e4\ub294 \uc758\ubbf8!\\n\\n\ub300\ubd80\ubd84\uc758 wait-free \uc54c\uace0\ub9ac\uc998\uc740 atomic read-modify-write \uc5f0\uc0b0\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\\n\\n- compare_exchange_weak/strong(expected, desired)\\n    - Atomically replaces the current value with desired if current equals expected, otherwise loads the current value\\n- fetch_add(x) / fetch_sub(x)\\n    - Atomically add/subtract x from the given variable and return the original value\\n- exchange(desired)\\n    - Stores the value desired and returns the old value\\n\\n## Wait-free \uc54c\uace0\ub9ac\uc998\uc744 \ud5a5\ud558\uc5ec\\n\\n\uae30\uc874\uc758 lock-free \uc54c\uace0\ub9ac\uc998\uc758 \ud575\uc2ec\uc740 CAS loop\\n\\n- \uc2a4\ub808\ub4dc\ub4e4\uc774 \ub2e4\ub978 \uc2a4\ub808\ub4dc\ub4e4\uc758 \uc9c4\ud589\uc744 **\ubc29\ud574**\ud568\\n- \uc989 \uc2a4\ub808\ub4dc\ub4e4\uc774 \ub2e4\ub978 \uc2a4\ub808\ub4dc\ub4e4\uc744 **\ud76c\uc0dd**\uc2dc\ud0a4\uba74\uc11c \uc790\uc2e0\uc758 \uc5f0\uc0b0\uc744 \uba3c\uc800 \uc644\ub8cc\ud558\ub824\uace0 \uacbd\uc7c1!\\n- wait freedom\uc744 \ub2ec\uc131\ud558\uae30 \uc704\ud574\uc11c\ub294, \uc2a4\ub808\ub4dc\ub4e4\uc774 \uacbd\uc7c1\ud558\ub294 \uc2a4\ub808\ub4dc\ub4e4\uc5d0 \uc758\ud574 **\ucc28\ub2e8\ub418\uc5b4\uc11c\ub294 \uc548 \ub428**\\n\\nwait-free \uc54c\uace0\ub9ac\uc998\uc758 \uc124\uacc4\\n\\n- \uacbd\uc7c1\uc801\uc774\uae30\ubcf4\ub2e4\ub294 **\ud611\ub825\uc801**\uc774\uc5b4\uc57c \ud568\\n- Wait-free \uc54c\uace0\ub9ac\uc998 \uc124\uacc4\uc758 \ud575\uc2ec\uc740 **helping**\\n- \uc9c4\ud589 \uc911\uc778 \ub2e4\ub978 \uc5f0\uc0b0\uacfc \ub3d9\uc2dc\uc5d0 \uc2e4\ud589\ub418\ub294 \uc5f0\uc0b0\ub4e4\uc740 \uadf8\ub4e4\uc744 \uae30\ub2e4\ub9ac\uac70\ub098 \uadf8\ub4e4\uacfc \uacbd\uc7c1\ud558\ub294 \ub300\uc2e0 \uadf8\ub4e4\uc758 \uc9c4\ud589\uc744 \ub3d5\uae30 \uc704\ud574 \uc2dc\ub3c4\\n- \uc9c4\ud589 \uc911\uc778 \ub2e4\ub978 \uc5f0\uc0b0\ub4e4\uc744 \uac10\uc9c0\ud560 \uc218 \uc788\ub294 \ubc29\ubc95\uc774 \ud544\uc694\\n\\n:::note\\n\\n\ubc1c\ud45c\uc790 Daniel Anderson \uad50\uc218\uc5d0 \ub530\ub974\uba74, \uc774\ub294 \uc27d\uc9c0 \uc54a\uc740 \ubc29\ubc95\uc774\ub2e4. \\n\uc5b4\ub5a0\ud55c CAS loop \ubc29\uc2dd\uc774\uac74 \uac04\uc5d0 helping \ubc29\uc2dd\uc73c\ub85c \ubc14\uafb8\ub294\uac8c \uac00\ub2a5\ud55c\uac83\ub3c4 \uc544\ub2c8\ub2e4.\\n\\n\ubc14\uafb8\ub294\uac8c \uac00\ub2a5\ud558\ub354\ub77c\ub3c4, blocking \ubc29\uc2dd\uc744 lock-free\ub85c \ubc14\uafb8\ub294 \uac83\ubcf4\ub2e4, \\n\uc77c\ubc18\uc801\uc73c\ub85c \ud6e8\uc52c \ud070 \uc54c\uace0\ub9ac\uc998\uc758 \uc7ac\uc124\uacc4\uac00 \ud544\uc694\ud558\ub2e4.\\n\\n\uadf8\ub7fc\uc5d0\ub3c4 \ubd88\uad6c\ud558\uace0 wait-free \uc54c\uace0\ub9ac\uc998\uc758 \uc7a5\uc810\uc774 \ub69c\ub837\ud558\uae30 \ub54c\ubb38\uc5d0 \uc6b0\ub9ac\ub294 \uc54c\uc544\uc57c \ud55c\ub2e4.\\n\\n:::\\n\\n## Wait-free counter design\\n\\nwait-free \ubc29\uc2dd counter\ub97c \ub9cc\ub4e4\uae30 \uc704\ud574 \uc694\uad6c\ub418\ub294 \uac83\uc740 2\uac00\uc9c0\uc774\ub2e4.\\n\\n- \uc5f0\uc0b0\ub4e4\uc774 \ub2e4\ub978 \uc5f0\uc0b0\ub4e4\uc774 \uc9c4\ud589 \uc911\uc778\uc9c0 \uac10\uc9c0\ud560 \ubc29\ubc95\uc774 \ud544\uc694\\n- \ub2e4\ub978 \uc2a4\ub808\ub4dc\ub4e4\uc5d0\uac8c \uc6b0\ub9ac\uac00 counter\ub97c 0\uc73c\ub85c \uc124\uc815\ud560 \uacc4\ud68d\uc774 \uc788\uac70\ub098 \uc774\ubbf8 \uc124\uc815\ud588\ub2e4\ub294 \uac83\uc744 \uc54c\ub9b4 \ubc29\ubc95\uc774 \ud544\uc694\\n    - \uc2a4\ub808\ub4dc\ub4e4\ub07c\ub9ac **\ud611\ub825**\ud558\uae30 \uc704\ud574\uc11c \uc774\ub7f0 \uc815\ubcf4\ub97c \uc54c\uc544\uc57c \ud55c\ub2e4. \uc774\uac83\uc774 \uc774\uc804\uc758 \ubc29\uc2dd\uacfc\uc758 \ud575\uc2ec \ucc28\ubcc4\uc810\uc774\ub2e4.\\n\\n**\ud575\uc2ec \uc544\uc774\ub514\uc5b4**: counter\uc758 \uc0c1\uc704 \ube44\ud2b8\ub4e4 \uc911 \uc77c\ubd80\ub97c \ud50c\ub798\uadf8\ub85c \uc0ac\uc6a9\ud55c\ub2e4.\\n\\n![image.png](image%201.png)\\n\\n \\n\\n- \ucd5c\uc0c1\uc704 \ud50c\ub798\uadf8\ub294, \uc5b4\ub5a0\ud55c \uc2a4\ub808\ub4dc\uac00 counter\uac00 0\uc73c\ub85c \uc124\uc815\ub418\uc5c8\ub2e4\ub294 \uac83\uc744 **\uc54c\ub9ac\uae30 \uc704\ud574** \uc0ac\uc6a9\\n- \ub450 \ubc88\uc9f8 \ud50c\ub798\uadf8\ub294 **helping**\uc744 \uc704\ud574 \uc0ac\uc6a9\\n\\n\uc6b0\uc120 \uc77d\uae30\uac00 \uc5c6\ub294 \uce74\uc6b4\ud130\ub97c \ub9cc\ub4e4\uc5b4\ubcf4\uc790.\\n\\n### Wait-free counter without read\\n\\n\uc6b0\uc120 `is_zero` flag\ub97c \uc124\uc815\ud558\uc790.\\n\\n```cpp\\nstatic constexpr uint64_t is_zero = 1ull << 63;\\n```\\n\\n\uadf8\ub9ac\uace0 `decrement()` \uc5f0\uc0b0\uc744 \uc815\uc758\ud55c\ub2e4.\\n\\n```cpp\\nbool decrement() {\\n    if (counter.fetch_sub(1) == 1) {\\n        uint64_t e = 0;\\n        return counter.compare_exchange_strong(e, is_zero);\\n    }\\n    return false;\\n}\\n```\\n\\n\ub3d9\uc791 \ubc29\uc2dd\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n1. `counter`\ub97c `1` \uac10\uc18c\uc2dc\ud0a4\uace0 \uc774\uc804 \uac12\uc744 \ubc18\ud658(`fetch_sub()`)\\n2. \ub9cc\uc57d \uc774\uc804 \uac12\uc774 `1`\uc774\uc5c8\ub2e4\uba74:\\n    - `counter`\uac00 `0`\uc774 \ub418\uc5c8\uc744 \uac83\uc774\ubbc0\ub85c\\n    - `counter`\uac00 \uc544\uc9c1 `0`\uc778\uc9c0 \ud655\uc778\ud558\uace0(e = 0)\\n    - \ub9de\ub2e4\uba74 `is_zero` flag\ub97c \uc124\uc815\\n3. \uadf8 \uc678\uc758 \uacbd\uc6b0 `false` \ubc18\ud658\\n\\n`0`\uc774 \ub418\ub294 \uc21c\uac04\uc744 \uc815\ud655\ud788 \uac10\uc9c0\ud558\uace0 flag\ub97c \uc124\uc815\ud558\ub294 \uac83\uc774 \ud575\uc2ec\uc774\ub2e4.\\n\\n\ub9c8\uc9c0\ub9c9\uc73c\ub85c CAS loop \uc5c6\uc774 \uc5b4\ub5bb\uac8c increment\ub97c \ud558\ub294\uc9c0 flag\uc758 \ub9c8\ubc95\uc744 \ubcf4\uc790.\\n\\n```cpp\\nbool increment_if_not_zero() {\\n    return (counter.fetch_add(1) & is_zero) == 0;\\n}\\n```\\n\\n\ub3d9\uc791 \ubc29\uc2dd\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n1. `counter`\ub97c `1` \uc99d\uac00\uc2dc\ud0a4\uace0 \uc774\uc804 \uac12\uc744 \ubc18\ud658(`fetch_add()`)\\n2. \uc774\uc804 \uac12\uc758 \ucd5c\uc0c1\uc704 \ube44\ud2b8(`is_zero` flag)\ub97c \ud655\uc778\\n3. flag\uac00 `0`\uc774\uba74 `true` \ubc18\ud658 (`counter`\uac00 `0`\uc774 \uc544\ub2c8\uc5c8\uc74c\uc744 \uc758\ubbf8)\\n4. flag\uac00 `1`\uc774\uba74 `false` \ubc18\ud658 (\uc774\ubbf8 `counter`\uac00 `0`\uc774\uc5c8\uc74c\uc744 \uc758\ubbf8)\\n\\n\ucd5c\uc0c1\uc704 \ube44\ud2b8\uac00 `1` \uc774\uba74, \uce74\uc6b4\ud130\ub294 `0` \uc774\uace0 \ud558\uc704 \ube44\ud2b8\ub4e4\uc740 \ubcf4\uc9c0 \uc54a\ub294 \uac83\uc774 \ud575\uc2ec\uc774\ub2e4.\\n\\n![image.png](image%202.png)\\n\\n\ub2e4\uc74c\uacfc \uac19\uc774 \ud558\uc704 \ube44\ud2b8\uac00 \uacc4\uc18d \uc99d\uac00\ud558\ub354\ub77c\ub3c4, \ucd5c\uc0c1\uc704 \ube44\ud2b8\uac00 `1`\uc774\ubbc0\ub85c \uce74\uc6b4\ud130\ub294 \ud558\uc704 \ube44\ud2b8\uc640 \uc0c1\uad00\uc5c6\uc774 `0`\uc774\ub2e4.\\n\\n\uc804\uccb4 \ucf54\ub4dc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```cpp\\nstruct Counter {\\n    static constexpr uint64_t is_zero = 1ull << 63;\\n\\n    bool increment_if_not_zero() {\\n        return (counter.fetch_add(1) & is_zero) == 0;\\n    }\\n\\n    bool decrement() {\\n        if (counter.fetch_sub(1) == 1) {\\n            uint64_t e = 0;\\n            return counter.compare_exchange_strong(e, is_zero);\\n        }\\n        return false;\\n    }\\n\\n    std::atomic<uint64_t> counter{1};\\n}\\n```\\n\\n\uc5ec\uae30\uae4c\uc9c0\ub9cc \ubcf4\uba74 \uaf64 \uc88b\uc740 \uc544\uc774\ub514\uc5b4 \uac19\uc544 \ubcf4\uc778\ub2e4. \uadf8\ub7ec\ub098 \uc774 \uad6c\ud604\uc740 **\ubb38\uc81c\uc810\uc774 \uc788\ub2e4**.\\n\\n`decrement()` \uad6c\ud604\uc758 \uc77c\ubd80\ubd84\uc744 \ubcf4\uc790.\\n\\n```cpp\\nif (counter.fetch_sub(1) == 1) {    // counter\uac00 1\uc5d0\uc11c 0\uc73c\ub85c \ubcc0\ud568\\n    uint64_t e = 0;\\n    return counter.compare_exchange_strong(e, is_zero); // \uc774 compare_exchange\uac00 \uc2e4\ud328\ud558\uba74??\\n}\\n```\\n\\n\uc774 \ubd80\ubd84\uc5d0\uc11c,\\n\\n1. `decrement()` \uc5f0\uc0b0\uc774 \uc2e4\uc81c\ub85c `counter`\ub97c 0\uc73c\ub85c \ub9cc\ub4e6\\n2. `increment()`\uac00 \uadf8 \uc0ac\uc774\uc5d0 \ubc1c\uc0dd\\n3. `decrement()`\uc5f0\uc0b0\uc774 \ub9c8\uce58 `increment()` \uc774\ud6c4\uc5d0 \ubc1c\uc0dd\ud55c \uac83\ucc98\ub7fc \ucc98\ub9ac\\n\\n\uadf8\ub7ec\ub098 \uc774 \ud2b9\uc9d5\uc740 **read\uac00 \uc5c6\ub2e4\uba74** \ubb38\uc81c\uac00 \ub418\uc9c0 \uc54a\ub294\ub2e4.\\n\\n`decrement()` \ubaa9\uc801\uc740 \uacb0\uad6d \\n\\n- `counter`\uac00 `0`\uc774 \ub418\ub294 \uc21c\uac04\uc744 \ud3ec\ucc29\\n- \uadf8 \uc21c\uac04\uc744 \ub2e4\ub978 \uc2a4\ub808\ub4dc\ub4e4\uc5d0\uac8c \uc601\uad6c\uc801\uc73c\ub85c \uc54c\ub9ac\ub294 \uac83\\n\\n\uc778\ub370, \ub9cc\uc57d CAS\uac00 \uc2e4\ud328\ud55c\ub2e4\uba74\\n\\n- \ub2e4\ub978 \uc2a4\ub808\ub4dc\uac00 \uc774\ubbf8 `counter`\ub97c \uc99d\uac00\uc2dc\ucf30\ub2e4\ub294 \uc758\ubbf8\\n- \uc989 \uc6b0\ub9ac\uac00 \uad00\ucc30\ud55c \\"0\uc774 \ub418\ub294 \uc21c\uac04\\"\uc740 \uc2e4\uc81c\ub85c \uc758\ubbf8\uc788\ub294 \uc21c\uac04\uc774 \uc544\ub2c8\uc5c8\uc74c\\n- `counter`\ub294 \uc9c4\uc9dc\ub85c \\"\uba48\ucd98\\" \uc801\uc774 \uc5c6\uc5c8\ub358 \uac83\\n\\n\ub530\ub77c\uc11c \uc774\ub294 \uc6b0\ub9ac\uac00 \uad6c\ud604\ud55c \uce74\uc6b4\ud130\uc758 \uc758\ubbf8\uc640 \ubd80\ud569\ud55c\ub2e4.\\n\\n\uadf8\ub807\ub2e4\uba74 read\uac00 \uc788\ub2e4\uba74 \uc5b4\ub5a4 \ubb38\uc81c\uac00 \ubc1c\uc0dd\ud558\ub294\uac00?\\n\\n### Adding a read operation. How hard can it be?\\n\\n`read()` \ub97c \ucd94\uac00\ud55c\ub2e4.\\n\\n```cpp\\nuint64_t read() {\\n    auto val = counter.load();\\n    return (val & is_zero) ? 0 : val;\\n}\\n```\\n\\n`val` \uc744 \ubd88\ub7ec\uc624\uace0, `is_zero` flag\uac00 \ucf1c\uc838\uc788\uc73c\uba74 `0`, \uc544\ub2c8\uba74 `val`\uc744 \ubc18\ud658\ud55c\ub2e4.\\n\\n\ub2e4\uc74c\uacfc \uac19\uc740 \uc2dc\ub098\ub9ac\uc624\ub97c \uc0dd\uac01\ud574\ubcf4\uc790.\\n\\n1. `read()`\ub294 `counter`\uac00 `0`\uc774\ub77c\uace0 \ud310\ub2e8\ud588\uc9c0\ub9cc\\n2. \uc2e4\uc81c\ub85c\ub294 `decrement()`\uac00 `false`\ub97c \ubc18\ud658(CAS \uc2e4\ud328)\\n3. `increment()`\ub294 \uc131\uacf5\\n4. \uacb0\uacfc\uc801\uc73c\ub85c `counter`\ub294 `1`\uc774\uc5b4\uc57c \ud558\ub294\ub370 `read()`\ub294 `0`\uc744 \ubc18\ud658\\n\\n\uc989 `read()` \uc5f0\uc0b0\uc774 **\uad00\ucc30\ud55c \uc0c1\ud0dc\uc640 \uc2e4\uc81c \uc5f0\uc0b0\uc758 \uacb0\uacfc\uac00 \ubd88\uc77c\uce58**\ud558\ub294 \ubb38\uc81c\uac00 \ubc1c\uc0dd\ud55c\ub2e4.\\n\\n\ub530\ub77c\uc11c **`val` \uc774 `0` \uc77c \ub54c** \ubb38\uc81c\uac00 \ubc1c\uc0dd\ud560 \uc218 \uc788\ub2e4. \ucf54\ub4dc\ub97c \uc218\uc815\ud574\uc57c \ud55c\ub2e4.\\n\\n```cpp\\nuint64_t read() {\\n    auto val = counter.load();\\n    if (val == 0 then what?\\n}\\n```\\n\\n\uc774\ub54c \ud574\uc57c \ud558\ub294 \uac8c **helping**\uc774\ub2e4!\\n\\n```cpp\\nuint64_t read() {\\n    auto val = counter.load();\\n    if (val == 0 && counter.compare_exchange_strong(val, is_zero)) return 0; // helping!\\n    return (val & is_zero) ? 0 : val;\\n}\\n```\\n\\n\ub2e4\uc74c\uacfc \uac19\uc774 \uc77d\uc5b4\ub4e4\uc778 \uac12\uc774 `0`\uc774\ub77c\uba74, `is_zero` flag \uc124\uc815\uc744 `read()` \uac00 **\ub3c4\uc640\uc900\ub2e4**.\\n\\n\uadf8\ub7ec\ub098 \uc774 \ubc29\ubc95\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 **\ubb38\uc81c\uc810\uc744 \ucd08\ub798**\ud55c\ub2e4.\\n\\n- `read()`\uac00 `is_zero` flag\ub97c \uc124\uc815\ud558\uba74, \uc5b4\ub5a4 `decrement()`\ub3c4 `true`\ub97c \ubc18\ud658\ud558\uc9c0 \uc54a\uc74c!\\n\\n:::note\\n\\n\ub9cc\uc57d \ub808\ud37c\ub7f0\uc2a4 \uce74\uc6b4\ud130\ub85c \uc774\ub7f0 \ubc29\uc2dd\uc744 \ucde8\ud55c\ub2e4\uba74, \ub2e4\uc74c\uacfc \uac19\uc740 \ubb38\uc81c\uc810\uc744 \ubc1c\uc0dd\uc2dc\ud0a8\ub2e4.\\n\ub808\ud37c\ub7f0\uc2a4 \uce74\uc6b4\ud130\ub294 **\ucc38\uc870 \uce74\uc6b4\ud2b8\uac00 0\uc774 \ub418\uba74 \ubc18\ub4dc\uc2dc \uac1d\uccb4\uac00 \uc0ad\uc81c**\ub3fc\uc57c \ud55c\ub2e4.\\n\\n\uadf8\ub7ec\ub098 \uc774\ub7f0 \ubc29\uc2dd\uc744 \uc0ac\uc6a9\ud558\uba74, `true`\ub97c \ubc18\ud658\ud55c `decrement()` \uac00 \uc5c6\ub294\ub370\ub3c4 \uce74\uc6b4\ud2b8\uac00 `0` \uc774 \ub418\uc5c8\uc73c\ubbc0\ub85c, \ub204\uad6c\ub3c4 \uc0ad\uc81c \ucc45\uc784\uc744 \uc9c0\uc9c0 \uc54a\uc544 **\uba54\ubaa8\ub9ac\uac00 \ub204\uc218**\ub420 \uc218 \uc788\ub2e4.\\n\\n:::\\n\\n\uc774\ub7f0 \ubb38\uc81c\uc758 \ud574\uacb0\uc744 \uc704\ud574\uc11c, \ucd94\uac00\uc801\uc778 flag\uac00 \ud544\uc694\ud558\ub2e4.\\n\\n### Almost there\\n\\n\ub2e4\uc74c\uacfc \uac19\uc740 helped flag\ub97c \ucd94\uac00\ud55c\ub2e4.\\n\\n```cpp\\nstatic constexpt uint64_t helped = 1ull << 62;\\n```\\n\\n`read()`\uac00 `is_zero` flag\ub97c \uc124\uc815\ud560 \ub54c, \uc774 `helped` flag\ub97c \uc124\uc815\ud55c\ub2e4.\\n\\n\uadf8\ub9ac\uace0 `decrement()` \ub97c \uc218\uc815\ud55c\ub2e4.\\n\\n```cpp\\nbool decrement() {\\n    if (counter.fetch_sub(1) == 1) {\\n        uint64_t e = 0;\\n        if (counter.compare_exchange_strong(e, is_zero)) return true;\\n        else if ((e & helped) && (counter.exchange(is_zero) & helped)) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n\ud575\uc2ec\uc801\uc778 \ubd80\ubd84\uc740 `e & helped) && (counter.exchange(is_zero) & helped` \uc774 \ubd80\ubd84\uc774\ub2e4.\\n\\n1. `(e & helped)`\\n    - `helped` flag\uac00 \uc124\uc815\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\\n    - \uc989, `read()` \uc5f0\uc0b0\uc774 \ub3c4\uc640\uc8fc\uc5c8\ub294\uc9c0 \ud655\uc778\\n2. `exchange(is_zero)` \\n    - \ud604\uc7ac \uac12\uc744 is_zero\ub85c \uad50\uccb4\ud558\uace0 \uc774\uc804 \uac12\uc744 \ubc18\ud658\\n    - `helped` flag\ub294 \uc81c\uac70\ub428 (`is_zero`\ub9cc \uc124\uc815)\\n3. `(exchange(is_zero) & helped)`\\n    - `exchange`\uac00 \ubc18\ud658\ud55c \uc774\uc804 \uac12\uc5d0 helped flag\uac00 \uc788\ub294\uc9c0 \ud655\uc778\\n    - `exchange`\ub294 atomic\ud558\ubbc0\ub85c \uc815\ud655\ud788 \ud558\ub098\uc758 `decrement`\ub9cc `helped` flag\ub97c \ubcfc \uc218 \uc788\uc74c\\n    - \ub2e4\ub978 `decrement`\ub4e4\uc740 \uc774\ubbf8 `helped` flag\uac00 \uc81c\uac70\ub41c \uac12\uc744 \ubcf4\uac8c \ub428\\n\\n\ub530\ub77c\uc11c \uc774 \ucf54\ub4dc\ub294,\\n\\n- `read`\uac00 \ub3c4\uc640\uc8fc\uc5c8\ub294\uc9c0 \ud655\uc778\ud558\uace0\\n- atomic\ud558\uac8c `helped` flag\ub97c \uc81c\uac70\ud558\uba74\uc11c\\n- \uc815\ud655\ud788 \ud558\ub098\uc758 `decrement`\ub9cc true\ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ubcf4\uc7a5\\n\\n\ub9c8\uc9c0\ub9c9\uc73c\ub85c `read()` \ub97c \uc218\uc815\ud55c\ub2e4.\\n\\n```cpp\\nuint64_t read() {\\n    auto val = counter.load();\\n    if (val == 0 && counter.compare_exchange_strong(val, is_zero | helped)) return 0; // helping!\\n    return (val & is_zero) ? 0 : val; \\n}\\n```\\n\\n\uae30\uc874\uc758 \ucf54\ub4dc\uc5d0, `counter`\ub97c `is_zero` flag\ub97c \uc124\uc815\ud558\ub294\ub370 **\ub3c4\uc640\uc8fc\uc5c8\ub2e4\uba74** `helped` flag\ub3c4 \ucd94\uac00\uc801\uc73c\ub85c \uc124\uc815\ud558\ub294 \ubd80\ubd84\uc744 \ucd94\uac00\ud588\ub2e4.\\n\\n\uc804\uccb4 \ucf54\ub4dc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n```cpp\\nstruct Counter {\\n    static constexpr uint64_t is_zero = 1ull << 63;\\n\\n    static constexpt uint64_t helped = 1ull << 62;\\n\\n    bool increment_if_not_zero() {\\n        return (counter.fetch_add(1) & is_zero) == 0; }\\n        bool decrement() {\\n        if (counter.fetch_sub(1) == 1) {\\n            uint64_t e = 0;\\n            if (counter.compare_exchange_strong(e, is_zero)) return true;\\n            else if ((e & helped) && (counter.exchange(is_zero) & helped)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    uint64_t read() {\\n        auto val = counter.load();\\n        if (val == 0 && counter.compare_exchange_strong(val, is_zero | helped)) \\n            return 0; // helping!\\n        return (val & is_zero) ? 0 : val; \\n    }\\n    \\n    std::atomic<uint64_t> counter{1};\\n}\\n```\\n\\nwait-free \uc54c\uace0\ub9ac\uc998\uc744 \uc644\uc131\ud588\ub2e4. \uae30\uc874\uc758 \ubc29\ubc95\uacfc \ub098\uc544\uc84c\uc744\uae4c?\\n\\n\uc55e\uc11c \ub9d0\ud588\ub4ef\uc774, \uc131\ub2a5\uc5d0 \ub300\ud574 \ucd94\uce21\ud558\uc9c0 \ub9d0\uace0, \uc131\ub2a5\uc744 \uce21\uc815\ud574\uc57c \ud55c\ub2e4.\\n\\n## \ubca4\uce58\ub9c8\ud06c\\n\\nDaniel Anderson \uad50\uc218\uac00  `atomic<shared_ptr>` \uad6c\ud604\uc5d0\uc11c wait-free counter\uc640 lock-free counter\ub97c \ube44\uad50\ud588\ub2e4.\\n\\n\uacb0\uacfc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n\\n**p\uac1c\uc758 \uc2a4\ub808\ub4dc\uac00 `atomic<shared_ptr>`\uc5d0\uc11c load\ud558\ub294 \uacbd\uc6b0**\\n\\n![image.png](image%203.png)\\n\\n**p\uac1c\uc758 \uc2a4\ub808\ub4dc, 50%\ub294 load, \ub098\uba38\uc9c0 50%\ub294 store**\\n\\n![image.png](image%204.png)\\n\\n**p\uac1c\uc758 \uc2a4\ub808\ub4dc, 10%\ub294 load, \ub098\uba38\uc9c0 90%\ub294 store**\\n\\n![image.png](image%205.png)\\n\\n\ube44\ub85d \uac04\ub2e8\ud55c \ubca4\uce58\ub9c8\ud06c\uc774\uc9c0\ub9cc, \ub2e4\uc74c\uacfc \uac19\uc740 \uacb0\ub860\uc744 \uc5bb\uc744 \uc218 \uc788\ub2e4.\\n\\n- \uc5b4\ub5a4 \uc54c\uace0\ub9ac\uc998\uc774 \ucd5c\uc120\uc778\uc9c0\ub294 \uc885\uc885 \uc6cc\ud06c\ub85c\ub4dc\uc5d0 \ub2ec\ub824\uc788\uc74c\\n- \uc5bc\ub9c8\ub098 \ub9ce\uc740 read vs write\uac00 \uc788\ub294\uc9c0\\n- \uc5bc\ub9c8\ub098 \ub9ce\uc740 \uc2a4\ub808\ub4dc/\ucf54\uc5b4\uac00 \uc788\ub294\uc9c0\\n- Wait-free\ub294 read-mostly \uc6cc\ud06c\ub85c\ub4dc\uc5d0\uc11c \ub354 \ub098\uc558\uc9c0\ub9cc, lock-free\ub294 write-mostly\uc5d0\uc11c \ub354 \ub098\uc544 \ubcf4\uc784\\n\\n## \ud575\uc2ec \uba54\uc2dc\uc9c0\\n\\n\uc131\ub2a5 \uad00\ub828\\n\\n- \uc808\ub300 \uc131\ub2a5\uc5d0 \ub300\ud574 \ucd94\uce21\ud558\uc9c0 \ub9d0 \uac83\\n- \ud558\uc9c0\ub9cc \uc54c\uace0\ub9ac\uc998\uc758 progress guarantees\ub97c \ubd84\uc11d\ud558\uc5ec \uc131\ub2a5\uc744 \uac00\uc124\ud654\ud558\uace0, \uc774\ub7ec\ud55c progress guarantees\ub97c \uc54c\uace0\ub9ac\uc998 \uc124\uacc4\uc758 \uc9c0\uce68\uc73c\ub85c \uc0ac\uc6a9\ud560 \uac83\\n- \uadf8\ub9ac\uace0 \ub098\uc11c \ubca4\uce58\ub9c8\ud06c\ub97c \uc218\ud589\ud560 \uac83\\n\\nProgress guarantees (\uc9c4\ud589 \ubcf4\uc7a5)\\n\\n- \ub3d9\uc2dc\uc131 \uc54c\uace0\ub9ac\uc998\uc744 \ubd84\ub958\ud558\ub294 \uc720\uc6a9\ud55c \uc774\ub860\uc801 \uae30\uc900\uc774\uba70 \uc54c\uace0\ub9ac\uc998 \uc124\uacc4\uc5d0 \ub3c4\uc6c0\uc744 \uc904 \uc218 \uc788\uc74c\\n- Lock-free \uc54c\uace0\ub9ac\uc998\uc740 \ud55c \uc2a4\ub808\ub4dc\uac00 \uc9c4\ud589\ud568\uc744 \ubcf4\uc7a5\ud558\ub294 \ubc18\uba74, Wait-free \uc54c\uace0\ub9ac\uc998\uc740 \ubaa8\ub4e0 \uc2a4\ub808\ub4dc\uc758 \uc9c4\ud589\uc744 \ubcf4\uc7a5\ud568\\n\\nWait-free \uc54c\uace0\ub9ac\uc998 \uc124\uacc4\\n\\n- \ud575\uc2ec \uae30\ubc95\uc740 helping - \uc5f0\uc0b0\ub4e4\uc774 \uc11c\ub85c \ub300\uae30\ud558\uac70\ub098(blocking) \uacbd\uc7c1\ud558\ub294(lock-free) \ub300\uc2e0 \ub3d9\uc2dc \uc2e4\ud589\ub418\ub294 \uc5f0\uc0b0\uc744 \ub3c4\uc640\uc90c\\n\\n---\\n\\n## \ucd94\uac00\\n\\n\uc624\ud0c0\ub098 \uc798\ubabb\ub41c \uc815\ubcf4\uac00 \uc77c\ubd80 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\uc815 \uc0ac\ud56d\uc774 \uc788\uc73c\uba74 \ub313\uae00\ub85c \ub0a8\uaca8\uc8fc\uc2dc\uba74 \uac10\uc0ac\ud558\uaca0\uc2b5\ub2c8\ub2e4."},{"id":"monads-and-more","metadata":{"permalink":"/blog/monads-and-more","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09-01-hs-ch12/index.md","source":"@site/blog/2025-09-01-hs-ch12/index.md","title":"Monads and more","description":"banner","date":"2025-09-01T00:00:00.000Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":27.02,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"monads-and-more","title":"Monads and more","authors":["dream2405"],"tags":["haskell","functional_programming"],"image":"./image.png"},"unlisted":false,"prevItem":{"title":"An Introduction to wait-free algorithms","permalink":"/blog/intro-wait-free-algorithms"}},"content":"![banner](./image.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n\ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 parameterised type\uc5d0 \ud568\uc218\ub97c \uc801\uc6a9\ud560 \uc218 \uc788\ub294 \uc5ec\ub7ec \ubc29\ubc95\ub4e4\uc774 \uc788\ub2e4.\\n\\n## Functors\\n\ub2e4\uc74c\uacfc \uac19\uc740 \uac04\ub2e8\ud55c \ud568\uc218\ub4e4\uc744 \ubcf4\uc790.\\n```haskell\\ninc :: [Int] -> [Int]\\ninc []      = []\\ninc (n:ns)  = n+1 : inc ns\\n\\nsqr :: [Int] -> [Int]\\nsqr []      = []\\nsqr (n:ns)  = n^2 : sqr ns\\n```\\n\uc774 \ub450 \ud568\uc218\uc758 \ucc28\uc774\ub294 \ub9ac\uc2a4\ud2b8\uc758 \uac01 \uc6d0\uc18c\uc5d0 \uc801\uc6a9\ub418\ub294 \ud568\uc218 \ubfd0\uc774\ub2e4.  \\n\uc774\ub7ec\ud55c \ud328\ud134\uc740 \ub77c\uc774\ube0c\ub7ec\ub9ac \ud568\uc218 `map`\uc73c\ub85c \uac04\ub2e8\ud788 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n\\n\uc6b0\uc120 \ub77c\uc774\ube0c\ub7ec\ub9ac \ud568\uc218 `map`\uc744 \uc0b4\ud3b4\ubcf4\uc790.\\n```haskell\\nmap :: (a -> b) -> [a] -> [b]\\nmap f []        = []\\nmap f (x:xs)    = f x : map f xs\\n```\\n\uc704\uc758 \ub450\uac1c\uc758 \ud568\uc218\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \uac04\ub2e8\ud558\uac8c \uc815\uc758\ub41c\ub2e4.\\n```haskell\\ninc = map (+1)\\nsqr = map (^2)\\n```\\n\uc774 \uc608\uc2dc\uc5d0\uc11c \ubcfc \uc218 \uc788\ub4ef\uc774, `map`\uc740 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c\uc758 \uac01 \uc6d0\uc18c\uc5d0 \ub300\ud55c \ud568\uc218\ub97c \ub9e4\ud551 \ud55c\ub2e4.  \\n\uadf8\ub807\ub2e4\uba74, \ub9ac\uc2a4\ud2b8 \ubfd0\ub9cc\uc774 \uc544\ub2cc \ub2e4\ub978 \uc790\ub8cc\uad6c\uc870, \ub354 \ub098\uc544\uac00 \uc5ec\ub7ec parameterised type\ub4e4\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc77c\ubc18\ud654\ud560 \uc218 \uc788\uc9c0 \uc54a\uc744\uae4c?\\n\\n\uc774\ub7ec\ud55c \ub9e4\ud551 \ud568\uc218\ub97c \uc9c0\uc6d0\ud558\ub294 \ud0c0\uc785\uc758 \ud074\ub798\uc2a4\ub97c **Functor**\ub77c\uace0 \ud55c\ub2e4.\\n```haskell\\nclass Functor f where\\n    fmap :: (a -> b) -> f a  -> f b\\n```\\nparameterised type `f`\uac00 `Functor` \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub418\ub824\uba74, \uba85\uc2dc\ub41c \ud0c0\uc785\uc758 `fmap` \ud568\uc218\ub97c \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4.  \\n`fmap`\uc740 `a -> b` \ud0c0\uc785\uc758 \ud568\uc218\uc640, \uc6d0\uc18c\uc758 \ud0c0\uc785\uc774 `a`\uc778 `f a` \uad6c\uc870\ub97c \ubc1b\uc544\uc11c, \uadf8 \ud568\uc218\ub97c \uac01 \uc6d0\uc18c\uc5d0 \uc801\uc6a9\ud55c \uacb0\uacfc\ub85c \uc6d0\uc18c\uc758 \ud0c0\uc785\uc774 `b`\uac00 \ub41c `f b` \uad6c\uc870\ub97c \uc0dd\uc131\ud55c\ub2e4.\\n\\n### \uc608\uc2dc\\n\ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc740 `fmap`\uc744 `map` \ud568\uc218\ub85c \uac04\ub2e8\ud788 \uc815\uc758\ud568\uc73c\ub85c\uc368 \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n\\n```haskell\\ninstance Functor [] where\\n    -- fmap :: (a -> b) -> [a] -> [b]\\n    fmap = map\\n```\\n\uc774 \uc120\uc5b8\uc5d0\uc11c `[]` \uae30\ud638\ub294 \ud0c0\uc785 \ub9e4\uac1c\ubcc0\uc218\uac00 \uc5c6\ub294 \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc744 \ub098\ud0c0\ub0b8\ub2e4. \uc774\ub294 `[a]` \ud0c0\uc785\uc774 \ub9ac\uc2a4\ud2b8 \ud0c0\uc785 `[]`\uc744 \ub9e4\uac1c\ubcc0\uc218 \ud0c0\uc785 `a`\uc5d0 \uc801\uc6a9\ud55c `[] a`\ub77c\ub294 \ub354 \uc6d0\uc2dc\uc801\uc778 \ud615\ud0dc\ub85c\ub3c4 \uc4f0\uc77c \uc218 \uc788\ub2e4\ub294 \uc0ac\uc2e4\uc5d0 \uadfc\uac70\ud55c\ub2e4.\\n\\n\ub610\ud55c, \uc704 \ucf54\ub4dc\uc5d0\uc11c `fmap`\uc758 \ud0c0\uc785\uc774 \uba85\uc2dc\uc801\uc73c\ub85c \uc120\uc5b8\ub418\uc9c0 \uc54a\uace0 \uc8fc\uc11d\uc73c\ub85c \uc791\uc131\ub41c \uc810\uc5d0 \uc8fc\ubaa9\ud574\uc57c \ud55c\ub2e4. \uc774\ub294 \ud558\uc2a4\ucf08\uc774 \uc778\uc2a4\ud134\uc2a4 \uc120\uc5b8\uc5d0 \uc774\ub7ec\ud55c \ud0c0\uc785 \uc815\ubcf4\ub97c \ud5c8\uc6a9\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc774\ub2e4. \ud558\uc9c0\ub9cc `fmap`\uc758 \uc815\uc758\ub97c \ub4dc\ub7ec\ub0b4\uace0 \ubb38\uc11c\ud654\ub97c \uc704\ud574, \ud0c0\uc785\uc744 \uc8fc\uc11d\uc73c\ub85c \ud3ec\ud568\ud588\ub2e4.\\n\\n\\\\\\n\ub450 \ubc88\uc9f8 \uc608\uc2dc\ub85c, \uc2e4\ud328\ud558\uac70\ub098 \uc131\uacf5\ud560 \uc218 \uc788\ub294 `a` \ud0c0\uc785\uc758 \uac12\uc744 \ub098\ud0c0\ub0b4\ub294 \ub0b4\uc7a5 \ud0c0\uc785 `Maybe a`\ub97c \ub5a0\uc62c\ub824 \ubcf4\uc790.\\n\\n```haskell\\ndata Maybe a = Nothing | Just a\\n```\\n\ub2e4\uc74c\uacfc \uac19\uc774 \uc801\uc808\ud55c \ud0c0\uc785\uc758 `fmap` \ud568\uc218\ub97c \uc815\uc758\ud558\uba74 \uac04\ub2e8\ud788 `Maybe` \ud0c0\uc785\uc744 \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.  \\n(\ud391\ud130\ub97c \ub098\ud0c0\ub0b4\ub294 `f`\uc640\uc758 \ud63c\ub3d9\uc744 \ud53c\ud558\uace0\uc790 \uc778\uc790\ub85c \ubc1b\ub294 \ud568\uc218\ub97c `g`\ub77c\uace0 \ubd80\ub984)\\n```haskell\\ninstance Functor Maybe where\\n    -- fmap :: (a -> b) -> Maybe a -> Maybe b\\n    fmap _ Nothing = Nothing\\n    fmap g (Just x) = Just (g x)\\n```\\n\uc989, \uc2e4\ud328\ud55c \uac12(`Nothing`)\uc5d0 \ud568\uc218\ub97c \ub9e4\ud551\ud558\uba74 \uc2e4\ud328\uac00 \uadf8\ub300\ub85c \uc804\ud30c\ub418\ub294 \uacb0\uacfc\uac00 \ub098\uc624\uace0, \uc131\uacf5\ud55c \uac12(`Just`)\uc758 \uacbd\uc6b0\uc5d0\ub294 \ub0b4\ubd80 \uac12\uc5d0 \ud568\uc218\ub97c \uc801\uc6a9\ud55c \ud6c4 \ub2e4\uc2dc \ud0dc\uadf8\ub97c \ubd99\uc778\ub2e4. \\n\\n\uc0ac\uc6a9 \uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> fmap (+1) Nothing\\nNothing\\n\\n> fmap (*2) (Just 3)\\nJust 6\\n\\n> fmap not (Just False)\\nJust True\\n```\\n\\n\\\\\\n\uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785 \ub610\ud55c \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc608\ub97c \ub4e4\uc5b4, leaf\uc5d0 \ub370\uc774\ud130\ub97c \uac16\ub294 \uc774\uc9c4 \ud2b8\ub9ac \ud0c0\uc785\uc744 \uc120\uc5b8\ud55c\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uc790.\\n```haskell\\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\\n    deriving Show\\n```\\n`deriving Show` \uad6c\ubb38\uc740 \ud2b8\ub9ac\uac00 \ud654\uba74\uc5d0 \ud45c\uc2dc\ub420 \uc218 \uc788\ub3c4\ub85d \ubcf4\uc7a5\ud55c\ub2e4. \uadf8 \ud6c4, \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785 `Tree`\ub294 \uc8fc\uc5b4\uc9c4 \ud568\uc218\ub97c \ud2b8\ub9ac\uc758 \uac01 \uc78e \uac12\uc5d0 \uc801\uc6a9\ud558\ub294 `fmap` \ud568\uc218\ub97c \uc815\uc758\ud568\uc73c\ub85c\uc368 \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Functor Tree where\\n    -- fmap :: (a -> b) -> Tree a -> Tree b\\n    fmap g (Leaf x) = Leaf (g x)\\n    fmap g (Node l r) = Node (fmap g l) (fmap g r)\\n```\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> fmap length (Leaf \\"abc\\")\\nLeaf 3\\n\\n> fmap even (Node (Leaf 1) (Leaf 2))\\nNode (Leaf False) (Leaf True)\\n```\\n\ud558\uc2a4\ucf08\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \ub9ce\uc740 \ud391\ud130 `f`\ub294 \uc704 \uc138 \uc608\uc2dc\uc640 \uc720\uc0ac\ud558\ub2e4. \uc989, `f a`\uac00 `a` \ud0c0\uc785\uc758 \uc6d0\uc18c\ub97c \ud3ec\ud568\ud558\ub294 \uc790\ub8cc \uad6c\uc870\ub77c\ub294 \uc758\ubbf8\uc5d0\uc11c \ub54c\ub85c **\ucee8\ud14c\uc774\ub108 \ud0c0\uc785(container type)** \uc774\ub77c \ubd88\ub9ac\uba70, `fmap`\uc740 \uc8fc\uc5b4\uc9c4 \ud568\uc218\ub97c \uac01 \uc6d0\uc18c\uc5d0 \uc801\uc6a9\ud55c\ub2e4.\\n\\n\ud558\uc9c0\ub9cc \ubaa8\ub4e0 \uc778\uc2a4\ud134\uc2a4\uac00 \uc774 \ud328\ud134\uc5d0 \ub4e4\uc5b4\ub9de\ub294 \uac83\uc740 \uc544\ub2c8\ub2e4. \uc608\ub97c \ub4e4\uc5b4, `IO` \ud0c0\uc785\uc740 \uc77c\ubc18\uc801\uc778 \uc758\ubbf8\uc758 \ucee8\ud14c\uc774\ub108 \ud0c0\uc785\uc774 \uc544\ub2c8\ub2e4. \uc65c\ub0d0\ud558\uba74 \uadf8 \uac12\uc740 \uc6b0\ub9ac\uac00 \ub0b4\ubd80 \uad6c\uc870\uc5d0 \uc811\uadfc\ud560 \uc218 \uc5c6\ub294 \uc785\ucd9c\ub825 \uc561\uc158(action)\uc744 \ub098\ud0c0\ub0b4\uae30 \ub54c\ubb38\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc774\ub294 \uc27d\uac8c \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Functor IO where\\n    -- fmap :: (a -> b) -> IO a -> IO b\\n    fmap g mx = do {x <- mx; return (g x)}\\n```\\n\uc774 \uacbd\uc6b0, `fmap`\uc740 \uc778\uc790\ub85c \uc8fc\uc5b4\uc9c4 \uc561\uc158\uc758 \uacb0\uacfc \uac12\uc5d0 \ud568\uc218\ub97c \uc801\uc6a9\ud558\uba70, \uc774\ub97c \ud1b5\ud574 \uadf8\ub7ec\ud55c \uac12\ub4e4\uc744 \ucc98\ub9ac\ud558\ub294 \uc218\ub2e8\uc744 \uc81c\uacf5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> fmap show (return True)\\n\\"True\\"\\n```\\n\\n\\\\\\n\ud391\ud130\ub97c \uc0ac\uc6a9\ud558\ub294 \ud575\uc2ec\uc801\uc778 \uc774\uc810 \ub450 \uac00\uc9c0\\n1. `fmap` \ud568\uc218\ub294 \ud391\ud130\uc758 \uc131\uc9c8\uc744 \ub9cc\uc871\ud558\ub294(functorial) \uc5b4\ub5a4 \uad6c\uc870\uc758 \uc6d0\uc18c\ub4e0 \ucc98\ub9ac\ud558\ub294 \ub370 \uc0ac\uc6a9\ub428  \\n\uc989, \uac01 \uc778\uc2a4\ud134\uc2a4\ub9c8\ub2e4 \ubcc4\uac1c\uc758 \ud568\uc218 \uc774\ub984\uc744 \ub9cc\ub4e4\uc5b4\ub0bc \ud544\uc694 \uc5c6\uc774, \ubcf8\uc9c8\uc801\uc73c\ub85c \ub3d9\uc77c\ud55c \uc5ed\ud560\uc744 \ud558\ub294 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574 \uac19\uc740 \uc774\ub984\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4.\\n2. \uc5b4\ub5a4 \ud391\ud130\uc5d0\ub098 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc77c\ubc18\ud654\ub41c(generic) \ud568\uc218\ub97c \uc815\uc758  \\n\uc608\ub97c \ub4e4\uc5b4, \ub9ac\uc2a4\ud2b8\uc758 \uac01 \uc815\uc218\ub97c 1\uc529 \uc99d\uac00\uc2dc\ud0a4\ub358 \uc774\uc804\uc758 \ud568\uc218\ub294 `map` \ub300\uc2e0 `fmap`\uc744 \uc0ac\uc6a9\ud558\uae30\ub9cc \ud558\uba74 \uc5b4\ub5a4 \ud391\ud130 \ud0c0\uc785\uc5d0\ub3c4 \uc801\uc6a9\ub418\ub3c4\ub85d \uc77c\ubc18\ud654\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\ninc :: Functor f => f Int -> f Int\\ninc = fmap (+1)\\n```\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4\\n```haskell\\n> inc (Just 1)\\nJust 2\\n\\n> inc [1,2,3,4,5]\\n[2,3,4,5,6]\\n\\n> inc (Node (Leaf 1) (Leaf 2))\\nNode (Leaf 2) (Leaf 3)\\n```\\n\\n### Functor laws\\n\uba85\uc2dc\ub41c \ud0c0\uc785\uc758 `fmap` \ud568\uc218\ub97c \uc81c\uacf5\ud558\ub294 \uac83 \uc678\uc5d0\ub3c4, \ud391\ud130\ub294 \ub450 \uac00\uc9c0 \ub4f1\uc2dd \ubc95\uce59\uc744 \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4.\\n- `fmap id` = `id`\\n- `fmap (g . h)` = `fmap g . fmap h`\\n\\n\uccab \ubc88\uc9f8 \ub4f1\uc2dd\uc740 `fmap`\uc774 **\ud56d\ub4f1 \ud568\uc218(identity function)\ub97c \ubcf4\uc874**\ud55c\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4.  \\n\uc989, `fmap`\uc744 \ud56d\ub4f1 \ud568\uc218\uc5d0 \uc801\uc6a9\ud558\uba74 \uacb0\uacfc\ub85c \uac19\uc740 \ud56d\ub4f1 \ud568\uc218\ub97c \ubc18\ud658\ud55c\ub2e4. \ud558\uc9c0\ub9cc \uc774 \ub4f1\uc2dd\uc5d0\uc11c `id`\ub294 \ub450 \ubc88 \ub098\ud0c0\ub098\uc9c0\ub9cc \uc11c\ub85c \ud0c0\uc785\uc774 \ub2e4\ub974\ub2e4\ub294 \uc810\uc5d0 \uc720\uc758\ud574\uc57c \ud55c\ub2e4. \uc88c\ubcc0\uc758 `id`\ub294 `a -> a` \ud0c0\uc785\uc744 \uac00\uc9c0\ubbc0\ub85c `fmap id`\uc758 \ud0c0\uc785\uc740 `f a -> f a`\uac00 \ub41c\ub2e4. \ub530\ub77c\uc11c \ub4f1\uc2dd\uc774 \uc131\ub9bd\ud558\ub824\uba74 \uc6b0\ubcc0\uc758 `id` \ub610\ud55c `f a -> f a` \ud0c0\uc785\uc744 \uac00\uc838\uc57c\ub9cc \ud55c\ub2e4.\\n\\n\ub450 \ubc88\uc9f8 \ub4f1\uc2dd\uc740 `fmap`\uc774 **\ud568\uc218 \ud569\uc131\uc744 \ubcf4\uc874**\ud55c\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4.  \\n\uc989, \ub450 \ud568\uc218\uc758 \ud569\uc131\uc5d0 `fmap`\uc744 \uc801\uc6a9\ud558\ub294 \uac83\uc740, \ub450 \ud568\uc218 \uac01\uac01\uc5d0 `fmap`\uc744 \uc801\uc6a9\ud55c \ub4a4 \uadf8 \uacb0\uacfc\ub97c \ud569\uc131\ud558\ub294 \uac83\uacfc \uacb0\uacfc\uac00 \uac19\ub2e4. \uc774 \ud569\uc131\uc774 \ud0c0\uc785 \uac80\uc0ac\ub97c \ud1b5\uacfc\ud558\ub824\uba74, \uad6c\uc131 \uc694\uc18c\uc778 \ud568\uc218 `g`\uc640 `h`\ub294 \uac01\uac01 `b -> c`\uc640 `a -> b` \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud55c\ub2e4.\\n\\n`fmap`\uc758 \ub2e4\ud615\uc801 \ud0c0\uc785\uacfc \uacb0\ud569\ub41c \uc774 \ud391\ud130 \ubc95\uce59\ub4e4\uc740 `fmap`\uc774 \uc2e4\uc81c\ub85c \ub9e4\ud551(mapping) \uc5f0\uc0b0\uc744 \uc218\ud589\ud558\ub3c4\ub85d \ubcf4\uc7a5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \ub9ac\uc2a4\ud2b8\uc758 \uacbd\uc6b0 \uc774 \ubc95\uce59\ub4e4\uc740 \uc6d0\uc18c\uac00 \ucd94\uac00\ub418\uac70\ub098, \uc81c\uac70\ub418\uac70\ub098, \uc7ac\ubc30\uc5f4\ub418\uc9c0 \uc54a\uace0 \uc778\uc790\ub85c \uc8fc\uc5b4\uc9c4 \ub9ac\uc2a4\ud2b8\uc758 \uad6c\uc870\uac00 \ubcf4\uc874\ub428\uc744 \ubcf4\uc7a5\ud55c\ub2e4. \\n\\n\ub9cc\uc57d \ub0b4\uc7a5 \ub9ac\uc2a4\ud2b8 \ud391\ud130\ub97c \ub9ac\uc2a4\ud2b8 \uc6d0\uc18c\uc758 \uc21c\uc11c\ub97c \ub4a4\uc9d1\ub294 `fmap`\uc758 \ub300\uccb4 \ubc84\uc804\uc73c\ub85c \uad50\uccb4\ud588\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uc790.\\n```haskell\\ninstance Functor [] where\\n    -- fmap :: (a -> b) -> f a -> f b\\n    fmap g []     = []\\n    fmap g (x:xs) = fmap g xs ++ [g x]\\n```\\n(\ub9cc\uc57d \uc774 \uc608\uc81c\ub97c GHCi\uc5d0\uc11c \uc2e4\ud589\ud574\ubcf4\uace0 \uc2f6\ub2e4\uba74, \ub0b4\uc7a5 \ub9ac\uc2a4\ud2b8 \ud391\ud130\uc640\uc758 \ucda9\ub3cc\uc744 \ud53c\ud558\uae30 \uc704\ud574 \uc704 \uc120\uc5b8\uc744 \uc218\uc815\ud558\uc5ec \uc790\uc2e0\ub9cc\uc758 \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc744 \uba3c\uc800 \uc120\uc5b8\ud574\uc57c \ud55c\ub2e4.) \uc774 \uc120\uc5b8\uc740 \ud0c0\uc785\uc740 \uc62c\ubc14\ub974\uc9c0\ub9cc, \ub2e4\uc74c \uc608\uc81c\uc5d0\uc11c \ubcf4\ub4ef\uc774 \ud391\ud130 \ubc95\uce59\uc744 \ub9cc\uc871\ud558\uc9c0 \ubabb\ud55c\ub2e4.\\n```haskell\\n> fmap id [1,2]\\n[2,1]\\n\\n> id [1,2]\\n[1,2]\\n\\n> fmap (not . even) [1,2]\\n[False,True]\\n\\n> (fmap not . fmap even) [1,2]\\n[True,False]\\n```\\n\uc6b0\ub9ac\uac00 \uc608\uc81c \uc139\uc158\uc5d0\uc11c \uc815\uc758\ud588\ub358 \ubaa8\ub4e0 \ud391\ud130\ub4e4\uc740 \ud391\ud130 \ubc95\uce59\uc744 \ub9cc\uc871\ud55c\ub2e4. \uc0ac\uc2e4, \ud558\uc2a4\ucf08\uc758 \uc5b4\ub5a4 \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc5d0 \ub300\ud574, \ud544\uc694\ud55c \ubc95\uce59\ub4e4\uc744 \ub9cc\uc871\ud558\ub294 `fmap` \ud568\uc218\ub294 \uae30\uaecf\ud574\uc57c \ud558\ub098\ubfd0\uc774\ub2e4. \uc989, \uc8fc\uc5b4\uc9c4 \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc744 \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub294 \ubc29\ubc95\uc774 \uc788\ub2e4\uba74, \uadf8 \ubc29\ubc95\uc740 \ub2e8 \ud558\ub098\ubfd0\uc774\ub77c\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c \uc6b0\ub9ac\uac00 \uc815\uc758\ud588\ub358 \ub9ac\uc2a4\ud2b8, `Maybe`, `Tree`, `IO`\uc5d0 \ub300\ud55c \uc778\uc2a4\ud134\uc2a4\ub4e4\uc740 \ubaa8\ub450 \uc720\uc77c\ud558\uac8c \uacb0\uc815\ub41c \uac83\uc774\ub2e4.\\n\\n## Applicatives\\n\ud391\ud130\ub294 \uad6c\uc870\uc758 \uac01 \uc6d0\uc18c \uc704\ub85c \ud568\uc218\ub97c \ub9e4\ud551\ud55c\ub2e4\ub294 \uc544\uc774\ub514\uc5b4\ub97c \ucd94\uc0c1\ud654\ud55c\ub2e4. \uc774\uc81c \uc774 \uc544\uc774\ub514\uc5b4\ub97c \uc77c\ubc18\ud654\ud558\uc5ec, \ub2e8\uc77c \uc778\uc790\ub97c \uac16\ub294 \ud568\uc218\uc5d0 \uc81c\uc57d\ub418\ub294 \ub300\uc2e0 \uc784\uc758\uc758 \uac1c\uc218\uc758 \uc778\uc790\ub97c \uac16\ub294 \ud568\uc218\ub97c \ub9e4\ud551\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc2f6\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uc790. \ub354 \uc815\ud655\ud788\ub294, \ub2e4\uc74c\uacfc \uac19\uc740 \ud0c0\uc785\uc744 \uac16\ub294 `fmap` \ud568\uc218\ub4e4\uc758 \uacc4\uce35\uc744 \uc815\uc758\ud558\uace0 \uc2f6\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uc790.\\n```haskell\\nfmap0 :: a -> f a\\nfmap1 :: (a -> b) -> f a -> f b\\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\\n.\\n.\\n.\\n```\\n`fmap1`\uc740 `fmap`\uc758 \ub2e4\ub978 \uc774\ub984\uc77c \ubfd0\uc774\uace0, `fmap0`\ub294 \ub9e4\ud551\ub418\ub294 \ud568\uc218\uac00 \uc778\uc790\ub97c \uac16\uc9c0 \uc54a\ub294 \ud1f4\ud654\ub41c(degenerate) \uacbd\uc6b0\uc774\ub2e4. \ud55c \uac00\uc9c0 \uac00\ub2a5\ud55c \uc811\uadfc\ubc95\uc740 \uac01 \uacbd\uc6b0\uc5d0 \ub300\ud574 \ud391\ud130 \ud074\ub798\uc2a4\uc758 \ud2b9\ubcc4\ud55c \ubc84\uc804(Functor0, Functor1, Functor2 \ub4f1)\uc744 \uc120\uc5b8\ud558\ub294 \uac83\uc774\ub2e4. \uadf8\ub7ec\uba74 \uc608\ub97c \ub4e4\uc5b4 \ub2e4\uc74c\uacfc \uac19\uc774 \uc4f8 \uc218 \uc788\ub2e4.\\n```haskell\\n> fmap2 (+) (Just 1) (Just 2)\\nJust 3\\n```\\n\ud558\uc9c0\ub9cc \uc774 \ubc29\ubc95\uc740 \uc5ec\ub7ec \uba74\uc5d0\uc11c \ub9cc\uc871\uc2a4\ub7fd\uc9c0 \uc54a\ub2e4.\\n- \ubaa8\ub4e0 \ud391\ud130 \ud074\ub798\uc2a4\ub4e4\uc774 \uc720\uc0ac\ud55c \ud328\ud134\uc744 \ub530\ub984\uc5d0\ub3c4 \ubd88\uad6c\ud558\uace0 \uac01 \ubc84\uc804\uc744 \uc218\ub3d9\uc73c\ub85c \uc120\uc5b8\ud574\uc57c \ud55c\ub2e4.\\n- \ubb34\ud55c\ud788 \ub9ce\uc740 \ud074\ub798\uc2a4\uac00 \uc788\uc9c0\ub9cc \uc6b0\ub9ac\ub294 \uc720\ud55c\ud55c \uc218\ub9cc \uc120\uc5b8\ud560 \uc218 \uc788\uc73c\ubbc0\ub85c, \uc5bc\ub9c8\ub098 \ub9ce\uc740 \ud074\ub798\uc2a4\ub97c \uc120\uc5b8\ud574\uc57c \ud560\uc9c0 \uba85\ud655\ud558\uc9c0 \uc54a\ub2e4.\\n\\n`(a -> b) -> f a -> f b` \ud0c0\uc785\uc758 `fmap`\uc744 `(a -> b) -> a -> b` \ud0c0\uc785\uc758 \ub0b4\uc7a5 \ud568\uc218 \uc801\uc6a9 \uc5f0\uc0b0\uc790\ub97c \uc77c\ubc18\ud654\ud55c \uac83\uc73c\ub85c \uac04\uc8fc\ud55c\ub2e4\uba74, \uc6d0\ud558\ub294 \ub3d9\uc791\uc744 \ub2ec\uc131\ud558\uae30 \uc704\ud574 \uc77c\uc885\uc758 **\ucee4\ub9c1(currying)** \uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub77c \uae30\ub300\ud560 \uc218 \uc788\ub2e4. \ud2b9\ud788, \uc6b0\ub9ac\ub294 `add x y = x + y`\uc640 \uac19\uc740 \uc815\uc758\uc5d0\uc11c \ucee4\ub9c1\uc5d0 \uc758\uc874\ud560 \ubfd0, \uc778\uc790 \uac1c\uc218\uac00 \ub2e4\ub978 \ud568\uc218\ub4e4\uc744 \uc704\ud574 \ud2b9\ubcc4\ud55c \ubc84\uc804\uc758 \uc801\uc6a9(application)\uc744 \ud544\uc694\ub85c \ud558\uc9c0 \uc54a\ub294\ub2e4.\\n\\n\\\\\\n\ucee4\ub9c1(currying)\uc758 \uc544\uc774\ub514\uc5b4\ub97c \uc0ac\uc6a9\ud558\uba74, \uc784\uc758\uc758 \uc778\uc790 \uac1c\uc218\ub97c \uac16\ub294 \ud568\uc218\ub97c \uc704\ud55c `fmap`\uc758 \ubc84\uc804\uc740 \ub2e4\uc74c \ub450 \uac00\uc9c0 \uae30\ubcf8 \ud568\uc218\uc758 \ud0c0\uc785\uc73c\ub85c \uad6c\uc131\ub420 \uc218 \uc788\ub2e4.\\n```haskell\\npure :: a -> f a\\n(<*>) :: f (a -> b) -> f a -> f b\\n```\\n\uc989, `pure`\ub294 `a` \ud0c0\uc785\uc758 \uac12\uc744 `f a` \ud0c0\uc785\uc758 \uad6c\uc870\ub85c \ubcc0\ud658\ud558\ub294 \ubc18\uba74, `<*>`\ub294 \uc778\uc790\ub85c \uc8fc\uc5b4\uc9c0\ub294 \ud568\uc218, \uc778\uc790 \uac12, \uadf8\ub9ac\uace0 \uacb0\uacfc \uac12\uc774 \ubaa8\ub450 `f` \uad6c\uc870 \uc548\uc5d0 \ud3ec\ud568\ub418\ub294, \uc77c\ubc18\ud654\ub41c \ud615\ud0dc\uc758 \ud568\uc218 \uc801\uc6a9\uc774\ub2e4. \uc77c\ubc18\uc801\uc778 \ud568\uc218 \uc801\uc6a9\uacfc \ub9c8\ucc2c\uac00\uc9c0\ub85c `<*>` \uc5f0\uc0b0\uc790\ub294 \ub450 \uc778\uc790 \uc0ac\uc774\uc5d0 \uc911\uc704(infix) \ud45c\uae30\ubc95\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 \uc67c\ucabd \uacb0\ud569(left-associative)\uc744 \ud55c\ub2e4\uace0 \uac00\uc815\ud55c\ub2e4.  \\n\uc608\ub97c \ub4e4\uc5b4, `g <*> x <*> y <*> z`\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \ud574\uc11d\ub41c\ub2e4.\\n```haskell\\n(((g <*> x) <*> y) <*> z)\\n```\\n`pure`\uc640 `<*>`\uc758 \uc804\ud615\uc801\uc778 \uc0ac\uc6a9 \ud615\ud0dc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\npure g <*> x1 <*> x2 <*> ... <*> xn\\n```\\n\uc774\ub7ec\ud55c \ud45c\ud604\uc2dd\uc740 **\uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c(applicative style)** \uc774\ub77c\uace0 \ud55c\ub2e4. \uc774\ub294 \uc77c\ubc18\uc801\uc778 \ud568\uc218 \uc801\uc6a9 \ud45c\uae30\ubc95\uc778 `g x1 x2 ... xn`\uacfc\uc758 \uc720\uc0ac\uc131 \ub54c\ubb38\uc774\ub2e4. \ub450 \uacbd\uc6b0 \ubaa8\ub450, `g`\ub294 `a1 ... an` \ud0c0\uc785\uc758 \uc778\uc790 n\uac1c\ub97c \ubc1b\uc544 `b` \ud0c0\uc785\uc758 \uacb0\uacfc\ub97c \uc0dd\uc131\ud558\ub294 \ucee4\ub9c1\ub41c \ud568\uc218\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc5d0\uc11c\ub294 \uac01 \uc778\uc790 `xi`\uac00 `ai`\uac00 \uc544\ub2cc `f ai` \ud0c0\uc785\uc744 \uac00\uc9c0\uba70, \uc804\uccb4 \uacb0\uacfc \ub610\ud55c `b`\uac00 \uc544\ub2cc `f b` \ud0c0\uc785\uc744 \uac16\ub294\ub2e4. \uc774 \uc544\uc774\ub514\uc5b4\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub9e4\ud551 \ud568\uc218\uc758 \uacc4\uce35\uc744 \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nfmap0 :: a -> f a\\nfmap0 = pure\\n\\nfmap1 :: (a -> b) -> f a -> f b\\nfmap1 g x = pure g <*> x\\n\\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\\nfmap2 g x y = pure g <*> x <*> y\\n\\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\\nfmap3 g x y z = pure g <*> x <*> y <*> z\\n\\n.\\n.\\n.\\n```\\n\uc774 \uc815\uc758\ub4e4\uc758 \ud0c0\uc785\uc744 \uc9c1\uc811 \ud655\uc778\ud574\ubcf4\ub294 \uac83\uc740 \uc88b\uc740 \uc5f0\uc2b5\uc774 \ub41c\ub2e4. \ud558\uc9c0\ub9cc \uc2e4\uc81c\ub85c\ub294 \ub2e4\uc74c \uc139\uc158\uc5d0\uc11c \ubcf4\uac8c \ub420 \uac83\ucc98\ub7fc \ud544\uc694\uc5d0 \ub530\ub77c \uad6c\uc131\ub420 \uc218 \uc788\uc73c\ubbc0\ub85c \uc774\ub7ec\ud55c \ub9e4\ud551 \ud568\uc218\ub4e4\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \uc815\uc758\ud560 \ud544\uc694\ub294 \uac70\uc758 \uc5c6\ub2e4.\\n\\n`pure`\uc640 `<*>` \uac1c\ub150\uc744 \uc9c0\uc6d0\ud558\ub294 \ud391\ud130\ub97c \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130(applicative functors), \uc904\uc5ec\uc11c **\uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c(applicatives)** \ub77c\uace0 \ubd80\ub978\ub2e4. \ud558\uc2a4\ucf08\uc5d0\uc11c \uc774 \uac1c\ub150\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \ub0b4\uc7a5 \ud074\ub798\uc2a4 \uc120\uc5b8\uc73c\ub85c \uad6c\ud604\ub41c\ub2e4.\\n```haskell\\nclass Functor f => Applicative f where\\n    pure  :: a -> f a\\n    (<*>) :: f (a -> b) -> f a -> f b\\n```\\n\\n### \uc608\uc2dc\\n`Maybe`\uac00 `fmap`\uc744 \uc9c0\uc6d0\ud558\ub294 \ud391\ud130\ub77c\ub294 \uc0ac\uc2e4\uc744 \uc774\uc6a9\ud558\uba74, \uc774 \ud0c0\uc785\uc744 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub85c \ub9cc\ub4dc\ub294 \uac83\uc740 \uac04\ub2e8\ud558\ub2e4.\\n```haskell\\ninstance Applicative Maybe where\\n    -- pure :: a -> Maybe a\\n    pure = Just\\n    \\n    -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\\n    Nothing <*> _ = Nothing\\n    (Just g) <*> mx = fmap g mx\\n```\\n\uc989, `pure` \ud568\uc218\ub294 \uac12\uc744 \uc131\uacf5\uc801\uc778 \uacb0\uacfc(`Just`)\ub85c \ubcc0\ud658\ud558\ub294 \ubc18\uba74, `<*>` \uc5f0\uc0b0\uc790\ub294 \uc2e4\ud328\ud560 \uc218\ub3c4 \uc788\ub294 \uc778\uc790\uc5d0 \uc2e4\ud328\ud560 \uc218\ub3c4 \uc788\ub294 \ud568\uc218\ub97c \uc801\uc6a9\ud558\uc5ec \uacb0\uacfc\ub97c \uc0dd\uc131\ud55c\ub2e4. \\n\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> pure (+1) <*> Just 1\\nJust 2\\n\\n> pure (+) <*> Just 1 <*> Just 2\\nJust 3\\n\\n> pure (+) <*> Nothing <*> Just 2\\nNothing\\n```\\n\uc774\ub7ec\ud55c \ubc29\uc2dd\uc73c\ub85c, `Maybe`\uc758 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc740 \uc2e4\ud328 \uc804\ud30c\ub97c \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc758 \uc790\ub3d9\ud654\ub41c \uba54\ucee4\ub2c8\uc998\uc774 \ucc98\ub9ac\ud574\uc8fc\ubbc0\ub85c, \uc6b0\ub9ac\uac00 \uc9c1\uc811 \uc2e4\ud328 \uac00\ub2a5\uc131\uc774 \uc788\ub294 \uc778\uc790\uc5d0 \uc21c\uc218 \ud568\uc218\ub97c \uc801\uc6a9\ud558\ub294 \uac83\uc744 \uad00\ub9ac\ud560 \ud544\uc694\uac00 \uc5c6\ub294 \ud615\ud0dc\uc758 \uc608\uc678 \ucc98\ub9ac \ud504\ub85c\uadf8\ub798\ubc0d\uc744 \uc9c0\uc6d0\ud55c\ub2e4.\\n\\n\\\\\\n\uc774\uc81c \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc73c\ub85c \ub118\uc5b4\uac00 \ubcf4\uc790. \ud45c\uc900\uc801\uc778 \uc778\uc2a4\ud134\uc2a4 \uc120\uc5b8\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\ninstance Applicative [] where\\n    -- pure :: a -> [a]\\n    pure x = [x]\\n    \\n    -- (<*>) :: [a -> b] -> [a] -> [b]\\n    gs <*> xs = [g x | g <- gs, x <- xs]\\n```\\n\uc989, `pure`\ub294 \uac12\uc744 \uc6d0\uc18c\uac00 \ud558\ub098\uc778 \ub9ac\uc2a4\ud2b8(singleton list)\ub85c \ubcc0\ud658\ud558\uace0, `<*>`\ub294 \ud568\uc218\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\uc640 \uc778\uc790\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\ub97c \ubc1b\uc544, \uac01 \ud568\uc218\ub97c \uac01 \uc778\uc790\uc5d0 \uc801\uc6a9\ud558\uc5ec \ubaa8\ub4e0 \uacb0\uacfc\ub97c \ub9ac\uc2a4\ud2b8\ub85c \ubc18\ud658\ud55c\ub2e4. \uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> pure (+1) <*> [1,2,3]\\n[2,3,4]\\n\\n> pure (+) <*> [1] <*> [2]\\n[3]\\n\\n> pure (*) <*> [1,2] <*> [3,4]\\n[3,4,6,8]\\n```\\n\uc774 \uc608\uc81c\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc774\ud574\ud574\uc57c \ud560\uae4c? \ud575\uc2ec\uc740 `[a]` \ud0c0\uc785\uc744 \uc131\uacf5 \uc2dc \uc5ec\ub7ec \uacb0\uacfc\ub97c \ud5c8\uc6a9\ud558\ub294 `Maybe a`\uc758 \uc77c\ubc18\ud654\ub85c \ubcf4\ub294 \uac83\uc774\ub2e4. \ub354 \uc815\ud655\ud788\ub294, \ube48 \ub9ac\uc2a4\ud2b8\ub294 \uc2e4\ud328\ub97c \ub098\ud0c0\ub0b4\uace0, \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \ub9ac\uc2a4\ud2b8\ub294 \uacb0\uacfc\uac00 \uc131\uacf5\ud560 \uc218 \uc788\ub294 \ubaa8\ub4e0 \uac00\ub2a5\ud55c \ubc29\uc2dd\uc744 \ub098\ud0c0\ub0b8\ub2e4\uace0 \uc0dd\uac01\ud560 \uc218 \uc788\ub2e4. \ub530\ub77c\uc11c \ub9c8\uc9c0\ub9c9 \uc608\uc81c\uc5d0\uc11c \uccab \ubc88\uc9f8 \uc778\uc790\ub294 \ub450 \uac1c\uc758 \uac00\ub2a5\ud55c \uac12(`1` \ub610\ub294 `2`)\uc744 \uac16\uace0, \ub450 \ubc88\uc9f8 \uc778\uc790\ub3c4 \ub450 \uac1c\uc758 \uac00\ub2a5\ud55c \uac12(`3` \ub610\ub294 `4`)\uc744 \uac00\uc9c0\ubbc0\ub85c, \uacf1\uc148\uc758 \uacb0\uacfc\ub85c \ub124 \uac1c\uc758 \uac00\ub2a5\ud55c \uacb0\uacfc(`3, 4, 6, 8`)\uac00 \ub098\uc624\ub294 \uac83\uc774\ub2e4.\\n\\n\ub354 \uc77c\ubc18\uc801\uc73c\ub85c, \ub9ac\uc2a4\ud2b8 \ucef4\ud504\ub9ac\ud5e8\uc158(list comprehension)\uc744 \uc0ac\uc6a9\ud558\uc5ec \ub450 \uc815\uc218 \ub9ac\uc2a4\ud2b8\ub97c \uacf1\ud558\ub294 \ubaa8\ub4e0 \uac00\ub2a5\ud55c \ubc29\ubc95\uc744 \ubc18\ud658\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uc790.\\n```haskell\\nprods :: [Int] -> [Int] -> [Int]\\nprods xs ys = [x*y | x <- xs, y <- ys]\\n```\\n\ub9ac\uc2a4\ud2b8\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\ub77c\ub294 \uc0ac\uc2e4\uc744 \uc774\uc6a9\ud558\uba74, \uc911\uac04 \uacb0\uacfc\uc5d0 \uc774\ub984\uc744 \ubd99\uc77c \ud544\uc694 \uc5c6\uc774 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc815\uc758\ub97c \ub0b4\ub193\uc744 \uc218 \uc788\ub2e4.\\n```haskell\\nprods :: [Int] -> [Int] -> [Int]\\nprods xs ys = pure (*) <*> xs <*> ys\\n```\\n\uc694\uc57d\ud558\uc790\uba74, \ub9ac\uc2a4\ud2b8\uc758 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc740 \uc77c\uc885\uc758 **\ube44\uacb0\uc815\uc801 \ud504\ub85c\uadf8\ub798\ubc0d(non-deterministic programming)** \uc744 \uc9c0\uc6d0\ud55c\ub2e4. \uc774\ub97c \ud1b5\ud574 \uac12\uc758 \uc120\ud0dd\uc774\ub098 \uc2e4\ud328 \uc804\ud30c\ub97c \uc9c1\uc811 \uad00\ub9ac\ud560 \ud544\uc694 \uc5c6\uc774, \uc21c\uc218 \ud568\uc218\ub97c \ub2e4\uc911-\uac12 \uc778\uc790\uc5d0 \uc801\uc6a9\ud560 \uc218 \uc788\uc73c\uba70, \uc774\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc758 \uc790\ub3d9\ud654\ub41c \uba54\ucee4\ub2c8\uc998\uc774 \ucc98\ub9ac\ud574\uc900\ub2e4.\\n\\n\uc774 \uc139\uc158\uc5d0\uc11c \ub2e4\ub8f0 \ub9c8\uc9c0\ub9c9 \ud0c0\uc785\uc740 `IO` \ud0c0\uc785\uc774\uba70, \ub2e4\uc74c \uc120\uc5b8\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Applicative IO where\\n    -- pure :: a -> IO a\\n    pure = return\\n    \\n    -- (<*>) :: IO (a -> b) -> IO a -> IO b\\n    mg <*> mx = do {g <- mg; x <- mx; return (g x)}\\n```\\n\uc774 \uacbd\uc6b0 `pure`\ub294 `IO` \ud0c0\uc785\uc744 \uc704\ud55c `return` \ud568\uc218\ub85c \uc815\uc758\ub418\uace0, `<*>`\ub294 \uc21c\uc218\ud558\uc9c0 \uc54a\uc740(impure) \uc778\uc790\uc5d0 \uc21c\uc218 \ud568\uc218\ub97c \uc801\uc6a9\ud558\uc5ec \uc21c\uc218\ud558\uc9c0 \uc54a\uc740 \uacb0\uacfc\ub97c \ub0b4\ub193\ub294\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \ud0a4\ubcf4\ub4dc\ub85c\ubd80\ud130 \uc8fc\uc5b4\uc9c4 \uac1c\uc218\uc758 \ubb38\uc790\ub97c \uc77d\ub294 \ud568\uc218\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\ub85c \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ub420 \uc218 \uc788\ub2e4.\\n```haskell\\ngetChars :: Int -> IO String\\ngetChars 0 = return []\\ngetChars n = pure (:) <*> getChar <*> getChars (n-1)\\n```\\n\uc989, \uae30\ubcf8 \ucf00\uc774\uc2a4(base case)\uc5d0\uc11c\ub294 \ub2e8\uc21c\ud788 \ube48 \ub9ac\uc2a4\ud2b8\ub97c \ubc18\ud658\ud558\uace0, \uc7ac\uadc0 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 \uccab \ubc88\uc9f8 \ubb38\uc790\ub97c \uc77d\uc740 \uacb0\uacfc\uc640 \ub098\uba38\uc9c0 \ubb38\uc790 \ub9ac\uc2a4\ud2b8\uc5d0 \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\uc790 (`:`)\ub97c \uc801\uc6a9\ud55c\ub2e4. \ud6c4\uc790\uc758 \uacbd\uc6b0, \ub9cc\uc57d \uc774 \ud568\uc218\uac00 `do` \ud45c\uae30\ubc95\uc73c\ub85c \uc815\uc758\ub418\uc5c8\ub2e4\uba74 \ud544\uc694\ud588\uc744 cons \ud568\uc218\uc5d0 \uacf5\uae09\ub418\ub294 \uc778\uc790\ub4e4\uc758 \uc774\ub984\uc744 \ubd99\uc77c \ud544\uc694\uac00 \uc5c6\ub2e4.\\n\\n\ub354 \uc77c\ubc18\uc801\uc73c\ub85c, `IO`\uc758 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc740 \uc77c\uc885\uc758 **interactive programming** \uc744 \uc9c0\uc6d0\ud55c\ub2e4. \uc774\ub97c \ud1b5\ud574 \uc561\uc158\uc758 \uc21c\uc11c\ub098 \uacb0\uacfc \uac12 \ucd94\ucd9c\uc744 \uc9c1\uc811 \uad00\ub9ac\ud560 \ud544\uc694 \uc5c6\uc774, \uc21c\uc218 \ud568\uc218\ub97c \uc21c\uc218\ud558\uc9c0 \uc54a\uc740 \uc778\uc790\uc5d0 \uc801\uc6a9\ud560 \uc218 \uc788\uc73c\uba70, \uc774\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc758 \uc790\ub3d9\ud654\ub41c \uba54\ucee4\ub2c8\uc998\uc774 \uc790\ub3d9\uc73c\ub85c \ucc98\ub9ac\ud574\uc900\ub2e4.\\n\\n### Effectful programming\\n\uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc5d0 \ub300\ud55c \uc6d0\ub798 \ub3d9\uae30\ub294 \ub2e4\uc911 \uc778\uc790 \ud568\uc218\uc5d0 \ub300\ud55c \ub9e4\ud551 \uc544\uc774\ub514\uc5b4\ub97c \uc77c\ubc18\ud654\ud558\ub824\ub294 \uac83\uc774\uc5c8\ub2e4. \uc774\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc758 \uac1c\ub150\uc5d0 \ub300\ud55c \ud55c\uac00\uc9c0 \uc720\ud6a8\ud55c \ud574\uc11d\uc774\uc9c0\ub9cc, \uc55e\uc11c \uc0b4\ud3b4\ubcf8 \uc138 \uac00\uc9c0 \uc778\uc2a4\ud134\uc2a4(`Maybe`, `List`, `IO`)\ub97c \ud1b5\ud574 \ub354 \ucd94\uc0c1\uc801\uc778 \ub610 \ub2e4\ub978 \uad00\uc810\uc774 \uc788\ub2e4\ub294 \uac83\uc774 \ubd84\uba85\ud574\uc9c4\ub2e4.\\n\\n\uc774 \uc778\uc2a4\ud134\uc2a4\ub4e4 \uc0ac\uc774\uc758 \uacf5\ud1b5\ub41c \uc8fc\uc81c\ub294 \ubaa8\ub450 **effects** \ub97c \uc0ac\uc6a9\ud55c \ud504\ub85c\uadf8\ub798\ubc0d\uacfc \uad00\ub828\uc774 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4. \uac01 \uacbd\uc6b0\uc5d0, \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uba54\ucee4\ub2c8\uc998\uc740 \uce5c\uc219\ud55c \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\ub85c \ud504\ub85c\uadf8\ub7a8\uc744 \uc791\uc131\ud558\uac8c \ud574\uc8fc\ub294 `<*>` \uc5f0\uc0b0\uc790\ub97c \uc81c\uacf5\ud55c\ub2e4. \uc774 \uc2a4\ud0c0\uc77c\uc5d0\uc11c\ub294 \ud568\uc218\uac00 \uc778\uc790\uc5d0 \uc801\uc6a9\ub418\ub294\ub370, \ud55c \uac00\uc9c0 \ud575\uc2ec\uc801\uc778 \ucc28\uc774\uc810\uc774 \uc788\ub2e4. \uc778\uc790\ub4e4\uc740 \ub354 \uc774\uc0c1 \ub2e8\uc21c\ud55c \uac12\uc774 \uc544\ub2c8\ub77c, \uc2e4\ud328 \uac00\ub2a5\uc131, \uc5ec\ub7ec \uc131\uacf5 \uacbd\ub85c, \ub610\ub294 \uc785\ucd9c\ub825 \uc561\uc158 \uc218\ud589\uacfc \uac19\uc740 effect\ub97c \uac00\uc9c8 \uc218 \uc788\ub2e4.\\n\\n\uc774\ub7ec\ud55c \ubc29\uc2dd\uc73c\ub85c, \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub294 \uc21c\uc218 \ud568\uc218\ub97c **effectful arguments**\uc5d0 \uc801\uc6a9\ud558\ub294 \uc544\uc774\ub514\uc5b4\ub97c \ucd94\uc0c1\ud654\ud55c \uac83\uc73c\ub85c\ub3c4 \ubcfc \uc218 \uc788\uc73c\uba70, \ud5c8\uc6a9\ub418\ub294 \ud6a8\uacfc\uc758 \uc815\ud655\ud55c \ud615\ud0dc\ub294 \uae30\ubc18\uc774 \ub418\ub294 \ud391\ud130\uc758 \uc131\uc9c8\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4.\\n\\neffectful programming\uc758 \ud55c \ud615\ud0dc\uc5d0 \ub300\ud55c \ud1b5\uc77c\ub41c \uc811\uadfc\ubc95\uc744 \uc81c\uacf5\ud558\ub294 \uac83 \uc678\uc5d0\ub3c4, \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc740 \uc5b4\ub5a4 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\uc640\ub3c4 \ud568\uaed8 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc77c\ubc18\ud654\ub41c \ud568\uc218\ub97c \uc815\uc758\ud560 \uc218 \uc788\ub2e4\ub294 \uc911\uc694\ud55c \uc774\uc810\ub3c4 \uc788\ub2e4. \\n\\n\ud55c \uc608\ub85c, \ud45c\uc900 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \ub2e4\uc74c \ud568\uc218\ub97c \uc81c\uacf5\ud55c\ub2e4.\\n```haskell\\nsequenceA :: Applicative f => [f a] -> f [a]\\nsequenceA [] = pure []\\nsequenceA (x:xs) = pure (:) <*> x <*> sequenceA xs\\n```\\n\uc774 \ud568\uc218\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc561\uc158\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\ub97c, \uacb0\uacfc \uac12\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\ub97c \ubc18\ud658\ud558\ub294 \ub2e8\uc77c \uc561\uc158\uc73c\ub85c \ubcc0\ud658\ud558\uba70, \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud504\ub85c\uadf8\ub798\ubc0d\uc758 \uacf5\ud1b5\ub41c \ud328\ud134\uc744 \ud3ec\ucc29\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, `getChars` \ud568\uc218\ub294 \uc774\uc81c \uae30\ubcf8 \uc561\uc158\uc778 `getChar`\ub97c \ud544\uc694\ud55c \ud69f\uc218\ub9cc\ud07c \ubcf5\uc81c\ud558\uace0 \uadf8 \uacb0\uacfc \uc2dc\ud000\uc2a4\ub97c \uc2e4\ud589\ud558\ub294 \ub354 \uac04\ub2e8\ud55c \ubc29\uc2dd\uc73c\ub85c \uc815\uc758\ub420 \uc218 \uc788\ub2e4.\\n```haskell\\ngetChars :: Int -> IO String\\ngetChars n = sequenceA (replicate n getChar)\\n```\\n\\n### Applicative laws\\n`pure`\uc640 `<*>` \ud568\uc218\ub97c \uc81c\uacf5\ud558\ub294 \uac83 \uc678\uc5d0\ub3c4, \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub294 \ub124 \uac00\uc9c0 \ub4f1\uc2dd \ubc95\uce59\uc744 \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4.\\n- `pure id <*> x` = `x`\\n    - **\ud56d\ub4f1(Identity)** : `pure`\uac00 \ud56d\ub4f1 \ud568\uc218\ub97c \ubcf4\uc874\ud55c\ub2e4\ub294 \uac83\uc744 \ub9d0\ud55c\ub2e4. \uc989, `pure id`\ub97c \uc801\uc6a9\ud558\ub294 \uac83\uc740 \uc544\ubb34\uac83\ub3c4 \ud558\uc9c0 \uc54a\ub294 \uac83\uacfc \uac19\ub2e4.\\n- `pure (g x)` = `pure g <*> pure x`\\n    - **\ub3d9\ud615\uc0ac\uc0c1(Homomorphism)** : `pure`\uac00 \ud568\uc218 \uc801\uc6a9 \ub610\ud55c \ubcf4\uc874\ud568\uc744 \ub9d0\ud55c\ub2e4. `pure`\ub294 \uc77c\ubc18\uc801\uc778 \ud568\uc218 \uc801\uc6a9\uc744 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud568\uc218 \uc801\uc6a9\uc73c\ub85c \ubd84\ubc30\ud560 \uc218 \uc788\ub2e4.\\n- `x <*> pure y` = `pure (\\\\g -> g y) <*> x`\\n    - **\uad50\ud658(Interchange)** : effectful \ud568\uc218\ub97c \uc21c\uc218\ud55c(pure) \uc778\uc790\uc5d0 \uc801\uc6a9\ud560 \ub54c, \ub450 \uad6c\uc131 \uc694\uc18c\uc758 \ud3c9\uac00 \uc21c\uc11c\ub294 \uc911\uc694\ud558\uc9c0 \uc54a\ub2e4\ub294 \uac83\uc744 \ub9d0\ud55c\ub2e4.\\n- `x <*> (y <*> z)` = `(pure (.) <*> x <*> y) <*> z`\\n    - **\uacb0\ud569(Composition)** : \uad00\ub828\ub41c \ud0c0\uc785\ub4e4\uc744 \uc81c\uc678\ud558\uba74 `<*>` \uc5f0\uc0b0\uc790\uac00 \uacb0\ud569 \ubc95\uce59\uc744 \ub9cc\uc871\ud55c\ub2e4\ub294 \uac83\uc744 \ub9d0\ud55c\ub2e4.\\n\\n\uc774 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ubc95\uce59\ub4e4\uc740 `pure :: a -> f a` \ud568\uc218\uc5d0 \ub300\ud55c \uc6b0\ub9ac\uc758 \uc9c1\uad00, \uc989 `a` \ud0c0\uc785\uc758 \uac12\uc744 `f` \ud0c0\uc785\uc758 \uc138\uc0c1\uc5d0 \uc2ec\ub294\ub2e4\ub294 \uac1c\ub150\uc744 \uacf5\uc2dd\ud654\ud55c\ub2e4. \ub610\ud55c \uc774 \ubc95\uce59\ub4e4\uc740 `pure` \ud568\uc218\uc640 `<*>` \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\uc5ec \uad6c\ucd95\ub41c \ubaa8\ub4e0 \ud0c0\uc785\uc774 \uc62c\ubc14\ub978 \ud45c\ud604\uc2dd\uc740 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\ub85c \ub2e4\uc2dc \uc791\uc131\ub420 \uc218 \uc788\uc74c\uc744 \ubcf4\uc7a5\ud55c\ub2e4. \uc989, \ub2e4\uc74c\uacfc \uac19\uc740 \ud615\ud0dc\uc774\ub2e4.\\n```\\npure g <*> x1 <*> x2 <*> ... <*> xn\\n```\\n\uc6b0\ub9ac\uac00 \uc608\uc81c\uc5d0\uc11c \uc815\uc758\ud588\ub358 \ubaa8\ub4e0 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub294 \uc704 \ubc95\uce59\ub4e4\uc744 \ub9cc\uc871\ud55c\ub2e4. \ub354\uc6b1\uc774, \uc774 \uc778\uc2a4\ud134\uc2a4\ub4e4\uc740 \uac01\uac01 `fmap g x = pure g <*> x` \ubc95\uce59 \ub610\ud55c \ub9cc\uc871\ud558\ub294\ub370, \uc774\ub294 `fmap`\uc774 \ub450 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uae30\ubcf8 \uc5f0\uc0b0(`pure`, `<*>`)\uc73c\ub85c \uc5b4\ub5bb\uac8c \uc815\uc758\ub420 \uc218 \uc788\ub294\uc9c0 \ubcf4\uc5ec\uc900\ub2e4. \uc0ac\uc2e4 \uc774 `fmap` \uad00\ub828 \ubc95\uce59\uc740 \uc774\uc804\uc5d0 \uc5b8\uae09\ub41c \uc0ac\uc2e4, \uc989 \uc8fc\uc5b4\uc9c4 \ub9e4\uac1c\ubcc0\uc218\ud654\ub41c \ud0c0\uc785\uc744 \ud391\ud130\ub85c \ub9cc\ub4dc\ub294 \ubc29\ubc95\uc740 \ub2e8 \ud558\ub098\ubfd0\uc774\ubbc0\ub85c `fmap`\uacfc \ub3d9\uc77c\ud574\uc57c \ud558\ub294 \ud568\uc218\ub294 \uc5b4\ub5a4 \uac83\uc774\ub4e0 \uc2e4\uc81c\ub85c `fmap`\uacfc \uac19\ub2e4\ub294 \uc0ac\uc2e4 \ub355\ubd84\uc5d0 \uacf5\uc9dc\ub85c \uc5bb\uc5b4\uc9c4\ub2e4.\\n\\n\ub9c8\uc9c0\ub9c9\uc73c\ub85c, \ud558\uc2a4\ucf08\uc740 `g <$> x = fmap g x`\ub85c \uc815\uc758\ub418\ub294 `fmap`\uc758 \uc911\uc704(infix) \ubc84\uc804\uc778 `<$>`\ub97c \uc81c\uacf5\ud55c\ub2e4. \uc774\ub97c \uc704 `fmap` \ubc95\uce59\uacfc \uacb0\ud569\ud558\uba74 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc758 \ub300\uc548\uc801\uc778 \ud615\ud0dc\ub97c \uc5bb\uc744 \uc218 \uc788\ub2e4.\\n```\\ng <$> x1 <*> x2 <*> ... <*> xn\\n```\\n\uc774 \ubc84\uc804\uc774 \uc57d\uac04 \ub354 \uac04\uacb0\ud558\uc9c0\ub9cc, \uc124\uba85 \ubaa9\uc801\uc73c\ub85c\ub294 \ud504\ub85c\uadf8\ub798\ubc0d\uc774 \uc21c\uc218 \ud568\uc218\ub97c \ud6a8\uacfc\uac00 \uc788\ub294 \uc778\uc790\uc5d0 \uc801\uc6a9\ud558\ub294 \uac83\uc784\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \uac15\uc870\ud558\ub294 `pure` \ubc84\uc804\uc744 \uc120\ud638\ud55c\ub2e4. \ud558\uc9c0\ub9cc `<$>`\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc84\uc804\uc740 \uc2e4\uc81c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc790\uc8fc \uc0ac\uc6a9\ub41c\ub2e4.\\n\\n## Monads\\n\uc774 \uc7a5\uc5d0 \ub098\uc62c \ub9c8\uc9c0\ub9c9 \uc0c8\ub85c\uc6b4 \uac1c\ub150\uc740 effectful programming\uc758 \ub610 \ub2e4\ub978 \ud328\ud134\uc744 \ud3ec\ucc29\ud55c\ub2e4. \uc608\uc2dc\ub85c, \uc815\uc218 \uac12\uacfc \ub098\ub217\uc148 \uc5f0\uc0b0\uc790\ub85c \uad6c\uc131\ub41c \ub2e4\uc74c \ud45c\ud604\uc2dd \ud0c0\uc785\uc744 \uc0dd\uac01\ud574\ubcf4\uc790.\\n```haskell\\ndata Expr = Val Int | Div Expr Expr\\n```\\n\uc774\ub7ec\ud55c \ud45c\ud604\uc2dd\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \ud3c9\uac00\ub420 \uc218 \uc788\ub2e4.\\n```haskell\\neval :: Expr -> Int\\neval (Val n) = n\\neval (Div x y) = eval x `div` eval y\\n```\\n\ud558\uc9c0\ub9cc \uc774 \ud568\uc218\ub294 0\uc73c\ub85c \ub098\ub204\ub294 \uac00\ub2a5\uc131\uc744 \uace0\ub824\ud558\uc9c0 \uc54a\uc73c\uba70, \uc774 \uacbd\uc6b0 \uc624\ub958\ub97c \ubc1c\uc0dd\uc2dc\ud0a8\ub2e4.\\n```haskell\\n> eval (Div (Val 1) (Val 0))\\n*** Exception: divide by zero\\n```\\n\uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574, \ub450 \ubc88\uc9f8 \uc778\uc790\uac00 `0`\uc77c \ub54c `Nothing`\uc744 \ubc18\ud658\ud558\ub294 \uc548\uc804\ud55c \ubc84\uc804\uc758 \ub098\ub217\uc148 \ud568\uc218\ub97c \uc815\uc758\ud558\uae30 \uc704\ud574 `Maybe` \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nsafediv :: Int -> Int -> Maybe Int\\nsafediv _ 0 = Nothing\\nsafediv n m = Just (n `div` m)\\n```\\n\uadf8\ub9ac\uace0 `eval` \ud568\uc218\ub97c \uc218\uc815\ud558\uc5ec \ub450 \uc778\uc790 \ud45c\ud604\uc2dd\uc5d0 \uc7ac\uadc0\uc801\uc73c\ub85c \ud638\ucd9c\ub420 \ub54c \uc2e4\ud328 \uac00\ub2a5\uc131\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \ucc98\ub9ac\ud558\ub3c4\ub85d \ud55c\ub2e4.\\n```haskell\\neval :: Expr -> Maybe Int\\neval (Val n) = Just n\\neval (Div x y) = case eval x of\\n                   Nothing -> Nothing\\n                   Just n  -> case eval y of\\n                                Nothing -> Nothing\\n                                Just m  -> safediv n m\\n```\\n\uc774\uc81c \uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> eval (Div (Val 1) (Val 0))\\nNothing\\n```\\n\uc774 \uc0c8\ub85c\uc6b4 \uc815\uc758\ub294 0\uc73c\ub85c \ub098\ub204\uae30 \uc774\uc288\ub97c \ud574\uacb0\ud558\uc9c0\ub9cc \ub2e4\uc18c \uc7a5\ud669\ud558\ub2e4. \uc815\uc758\ub97c \ub2e8\uc21c\ud654\ud558\uae30 \uc704\ud574 `Maybe`\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\ub77c\ub294 \uc0ac\uc2e4\uc744 \ud65c\uc6a9\ud558\uc5ec `eval`\uc744 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\ub85c \uc7ac\uc815\uc758\ud574\ubcfc \uc218 \uc788\ub2e4.\\n```haskell\\neval :: Expr -> Maybe Int\\neval (Val n) = pure n\\neval (Div x y) = pure safediv <*> eval x <*> eval y\\n```\\n\ud558\uc9c0\ub9cc \uc774 \uc815\uc758\ub294 \ud0c0\uc785\uc774 \uc62c\ubc14\ub974\uc9c0 \uc54a\ub2e4. \ud2b9\ud788, \uc704 \ucee8\ud14d\uc2a4\ud2b8\uc5d0\uc11c\ub294 `Int -> Int -> Int` \ud0c0\uc785\uc758 \ud568\uc218\uac00 \ud544\uc694\ud55c\ub370, `safediv` \ud568\uc218\ub294 `Int -> Int -> Maybe Int` \ud0c0\uc785\uc744 \uac16\ub294\ub2e4. `pure safediv`\ub97c `Maybe (Int -> Int -> Maybe Int)` \ud0c0\uc785\uc744 \uac16\ub294 \ucee4\uc2a4\ud140 \uc815\uc758 \ud568\uc218\ub85c \uad50\uccb4\ud574\ub3c4 \ub3c4\uc6c0\uc774 \ub418\uc9c0 \uc54a\ub294\ub370, \uc774\ub294 \ub450 \ubc88\uc9f8 \uc815\uc218\uac00 0\uc77c \ub54c \uc2e4\ud328\ub97c \ub098\ud0c0\ub0bc \ubc29\ubc95\uc774 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4.\\n\\n\uacb0\ub860\uc740 `eval` \ud568\uc218\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\uac00 \ud3ec\ucc29\ud558\ub294 effectful programming\uc758 \ud328\ud134\uc5d0 \ub9de\uc9c0 \uc54a\ub294\ub2e4\ub294 \uac83\uc774\ub2e4. \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\uc740 \uc21c\uc218 \ud568\uc218\ub97c \ud6a8\uacfc\uac00 \uc788\ub294 \uc778\uc790\uc5d0 \uc801\uc6a9\ud558\ub3c4\ub85d \uc81c\ud55c\ud55c\ub2e4. `eval`\uc740 \uc774 \ud328\ud134\uc5d0 \ub9de\uc9c0 \uc54a\ub294\ub370, `safediv`\ub97c \ucc98\ub9ac\ud558\ub294 \ub370 \uc0ac\uc6a9\ub418\ub294 \ud568\uc218\uac00 \uc21c\uc218 \ud568\uc218\uac00 \uc544\ub2c8\ub77c \uadf8 \uc790\uccb4\ub85c \uc2e4\ud328\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4.\\n\\n\uadf8\ub807\ub2e4\uba74 `eval :: Expr -> Maybe Int`\ub97c \uc5b4\ub5bb\uac8c \ub354 \uac04\ub2e8\ud55c \ubc29\uc2dd\uc73c\ub85c \ub2e4\uc2dc \uc791\uc131\ud560 \uc218 \uc788\uc744\uae4c? \ud575\uc2ec\uc740 `eval` \uc815\uc758\uc5d0 \ub450 \ubc88 \ub098\ud0c0\ub098\ub294 \uacf5\ud1b5 \ud328\ud134, \uc989 `Maybe` \uac12\uc5d0 \ub300\ud55c **\uacbd\uc6b0 \ubd84\uc11d(case analysis)**\uc744 \uc218\ud589\ud558\uc5ec `Nothing`\uc740 `Nothing`\uc73c\ub85c, `Just x`\ub294 \uc5b4\ub5a4 \uacb0\uacfc\ub85c \ub9e4\ud551\ud558\ub294 \uac83\uc744 \uad00\ucc30\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ud328\ud134\uc744 \ucd94\uc0c1\ud654\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ub418\ub294 \uc0c8\ub85c\uc6b4 \uc5f0\uc0b0\uc790 `>>=`\ub97c \uc5bb\uc744 \uc218 \uc788\ub2e4.\\n```haskell\\n(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\\nmx >>= f = case mx of\\n             Nothing -> Nothing\\n             Just x  -> f x\\n```\\n\uc989, `>>=`\ub294 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 `a` \ud0c0\uc785\uc758 \uc778\uc790\uc640, \uadf8 \uacb0\uacfc\uac00 \uc2e4\ud328\ud560 \uc218 \uc788\ub294 `a` \ud0c0\uc785\uc758 \ud568\uc218\ub97c \ubc1b\uc544, \uc2e4\ud328\ud560 \uc218 \uc788\ub294 `b` \ud0c0\uc785\uc758 \uacb0\uacfc\ub97c \ubc18\ud658\ud55c\ub2e4. \ub9cc\uc57d \uccab \ubc88\uc9f8 \uc778\uc790\uac00 \uc2e4\ud328\ud558\uba74 \uc2e4\ud328\ub97c \uc804\ud30c\ud558\uace0, \uadf8\ub807\uc9c0 \uc54a\uc73c\uba74 \ub450 \ubc88\uc9f8 \uc778\uc790\uc778 \ud568\uc218\ub97c \uccab \ubc88\uc9f8 \uc778\uc790\uc758 \uacb0\uacfc\uc5d0 \uc801\uc6a9\ud55c\ub2e4. \uc774\ub7f0 \uc2dd\uc73c\ub85c `>>=`\ub294 `Maybe` \uac12\uc758 \uc5f0\uc18d\uacfc \uadf8 \uacb0\uacfc \ucc98\ub9ac\ub97c \ud1b5\ud569\ud55c\ub2e4. `>>=` \uc5f0\uc0b0\uc790\ub294 \uc885\uc885 **\ubc14\uc778\ub4dc(bind)** \ub77c\uace0 \ubd88\ub9b0\ub2e4. \ub450 \ubc88\uc9f8 \uc778\uc790\ub97c \uccab \ubc88\uc9f8 \uc778\uc790\uc758 \uacb0\uacfc\uc5d0 \ubc14\uc778\ub529\ud558\uae30 \ub54c\ubb38\uc774\ub2e4.\\n\\n\ubc14\uc778\ub4dc \uc5f0\uc0b0\uc790\uc640 \ub78c\ub2e4 \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud558\uc5ec, \uc774\uc81c `eval` \ud568\uc218\ub97c \ub354 \uac04\uacb0\ud55c \ubc29\uc2dd\uc73c\ub85c \uc7ac\uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\neval :: Expr -> Maybe Int\\neval (Val n) = Just n\\neval (Div x y) = eval x >>= \\\\n ->\\n                 eval y >>= \\\\m ->\\n                 safediv n m\\n```\\n`Div`\uc758 \uacbd\uc6b0\ub294 \uba3c\uc800 `x`\ub97c \ud3c9\uac00\ud558\uc5ec \uadf8 \uacb0\uacfc\ub97c `n`\uc774\ub77c \ud558\uace0, \uadf8 \ub2e4\uc74c `y`\ub97c \ud3c9\uac00\ud558\uc5ec \uadf8 \uacb0\uacfc\ub97c `m`\uc774\ub77c \ud55c \ub4a4, `safediv`\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub450 \uacb0\uacfc\ub97c \uacb0\ud569\ud558\ub294 \uc0c1\ud0dc\ub97c \uba85\uc2dc\ud55c\ub2e4.\\n\\n\uc704 \uc608\uc81c\ub85c\ubd80\ud130 \uc77c\ubc18\ud654\ud558\uba74, `>>=` \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\uc5ec \uad6c\ucd95\ub41c \ud45c\ud604\uc2dd\uc740 \uc804\ud615\uc801\uc73c\ub85c \ub2e4\uc74c\uacfc \uac19\uc740 \uad6c\uc870\ub97c \uac00\uc9c4\ub2e4.\\n```haskell\\nm1 >>= \\\\x1 ->\\nm2 >>= \\\\x2 ->\\n...\\nmn >>= \\\\xn ->\\nf x1 x2 ... xn\\n```\\n\uc989, \uc6b0\ub9ac\ub294 `m1 ... mn` \uac01\uac01\uc758 \ud45c\ud604\uc2dd\uc744 \ucc28\ub840\ub85c \ud3c9\uac00\ud558\uace0, \uadf8 \uacb0\uacfc \uac12 `x1 ... xn`\uc744 \ud568\uc218 `f`\uc5d0 \uc801\uc6a9\ud558\uc5ec \uacb0\ud569\ud55c\ub2e4. `>>=` \uc5f0\uc0b0\uc790\uc758 \uc815\uc758\ub294 \uc2dc\ud000\uc2a4\uc758 \ubaa8\ub4e0 \uad6c\uc131\uc694\uc18c `mi`\uac00 \uc131\uacf5\ud560 \uacbd\uc6b0\uc5d0\ub9cc \uc774\ub7ec\ud55c \ud45c\ud604\uc2dd\uc774 \uc131\uacf5\ud558\ub3c4\ub85d \ubcf4\uc7a5\ud55c\ub2e4. \ub354 \ub098\uc544\uac00, `>>=` \uc5f0\uc0b0\uc790\uc758 \uc815\uc758\uc5d0 \uc758\ud574 \uc2dc\ud000\uc2a4\uc758 \uc5b4\ub290 \uc9c0\uc810\uc5d0\uc11c\ub4e0 \uc2e4\ud328\ub97c \ucc98\ub9ac\ud558\ub294 \ubb38\uc81c\uac00 \uc790\ub3d9\uc73c\ub85c \ucc98\ub9ac\ub418\ubbc0\ub85c \uc0ac\uc6a9\uc790\ub294 \uc774\uc5d0 \ub300\ud574 \uac71\uc815\ud560 \ud544\uc694\uac00 \uc5c6\ub2e4.\\n\\n\ud558\uc2a4\ucf08\uc740 \uc704\uc640 \uac19\uc740 \ud615\ud0dc\uc758 \ud45c\ud604\uc2dd\uc744 \ub2e4\uc74c\uacfc \uac19\uc774 \ub354 \uac04\ub2e8\ud55c \ubc29\uc2dd\uc73c\ub85c \uc791\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \ud2b9\ubcc4\ud55c \ud45c\uae30\ubc95\uc744 \uc81c\uacf5\ud55c\ub2e4.\\n```haskell\\ndo x1 <- m1\\n   x2 <- m2\\n   ...\\n   xn <- mn\\n   f x1 x2 ... xn\\n```\\n\uc774\ub294 \uc0c1\ud638\uc791\uc6a9 \ud504\ub85c\uadf8\ub798\ubc0d(interactive programming)\uc5d0\uc11c\ub3c4 \uc0ac\uc6a9\ub418\ub294 \uac83\uacfc \ub3d9\uc77c\ud55c \ud45c\uae30\ubc95\uc774\ub2e4. \uc5ec\uae30\uc5d0\uc11c\ub3c4 \uc2dc\ud000\uc2a4\uc758 \uac01 \ud56d\ubaa9\uc740 \ub3d9\uc77c\ud55c \uc5f4\uc5d0\uc11c \uc2dc\uc791\ud574\uc57c \ud558\uba70, \uacb0\uacfc \uac12 `xi`\uac00 \ud544\uc694\ud558\uc9c0 \uc54a\uc740 \uacbd\uc6b0 `xi <- mi`\ub294 `mi`\ub85c \ucd95\uc57d\ub420 \uc218 \uc788\ub2e4. \uc774 `do` \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud558\uba74 `eval`\uc740 \uc774\uc81c \ub2e4\uc74c\uacfc \uac19\uc774 \uac04\ub2e8\ud558\uac8c \uc7ac\uc815\uc758\ub420 \uc218 \uc788\ub2e4.\\n```haskell\\neval :: Expr -> Maybe Int\\neval (Val n) = Just n\\neval (Div x y) = do n <- eval x\\n                    m <- eval y\\n                    safediv n m\\n```\\n\ub354 \uc77c\ubc18\uc801\uc73c\ub85c, `do` \ud45c\uae30\ubc95\uc740 `IO`\ub098 `Maybe` \ud0c0\uc785\uc5d0\ub9cc \uad6d\ud55c\ub418\uc9c0 \uc54a\uace0, **\ubaa8\ub098\ub4dc(monad)** \ub97c \ud615\uc131\ud558\ub294 \ubaa8\ub4e0 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud0c0\uc785\uacfc \ud568\uaed8 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. \ud558\uc2a4\ucf08\uc5d0\uc11c \ubaa8\ub098\ub4dc\uc758 \uac1c\ub150\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \ub0b4\uc7a5 \uc120\uc5b8\uc73c\ub85c \uad6c\ud604\ub41c\ub2e4.\\n```haskell\\nclass Applicative m => Monad m where\\n    return :: a -> m a\\n    (>>=)  :: m a -> (a -> m b) -> m b\\n    \\n    return = pure\\n```\\n\uc989, \ubaa8\ub098\ub4dc\ub294 \uba85\uc2dc\ub41c \ud0c0\uc785\uc758 `return`\uacfc `>>=` \ud568\uc218\ub97c \uc9c0\uc6d0\ud558\ub294 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud0c0\uc785\uc774\ub2e4. \uae30\ubcf8 \uc815\uc758 `return = pure`\ub294 `return`\uc774 \uc77c\ubc18\uc801\uc73c\ub85c \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud568\uc218 `pure`\uc758 \ub2e4\ub978 \uc774\ub984\uc77c \ubfd0\uc774\uc9c0\ub9cc, \uc6d0\ud55c\ub2e4\uba74 \uc778\uc2a4\ud134\uc2a4 \uc120\uc5b8\uc5d0\uc11c \uc624\ubc84\ub77c\uc774\ub4dc(override)\ub420 \uc218 \uc788\uc74c\uc744 \uc758\ubbf8\ud55c\ub2e4.\\n\\n`return` \ud568\uc218\ub294 \uc5ed\uc0ac\uc801\uc778 \uc774\uc720\ub85c, \uadf8\ub9ac\uace0 `return`\uacfc `>>=` \ud568\uc218\ub97c \ubaa8\ub450 \ud3ec\ud568\ud55c\ub2e4\uace0 \uac00\uc815\ud558\ub294 \uae30\uc874 \ucf54\ub4dc, \ub17c\ubb38, \uad50\uacfc\uc11c\uc640\uc758 \ud558\uc704 \ud638\ud658\uc131\uc744 \ubcf4\uc7a5\ud558\uae30 \uc704\ud574 `Monad` \ud074\ub798\uc2a4\uc5d0 \ud3ec\ud568\ub418\uc5b4 \uc788\ub2e4. \ud558\uc9c0\ub9cc \ubbf8\ub798\uc758 \uc5b4\ub290 \uc2dc\uc810\uc5d0\ub294 `return`\uc774 `Monad` \ud074\ub798\uc2a4\uc5d0\uc11c \uc81c\uac70\ub418\uace0 \ub300\uc2e0 \ub2e4\uc74c\uacfc \uac19\uc740 \uc815\uc758\ub97c \uac16\ub294 \ub77c\uc774\ube0c\ub7ec\ub9ac \ud568\uc218\uac00 \ub420 \uc218\ub3c4 \uc788\ub2e4.\\n```haskell\\nreturn :: Applicative f => a -> f a\\nreturn = pure\\n```\\n\ub9cc\uc57d \uc774 \ubcc0\uacbd\uc774 \uad6c\ud604\ub418\uba74, \ub354 \uc774\uc0c1 \uc778\uc2a4\ud134\uc2a4 \uc120\uc5b8\uc5d0\uc11c `return`\uc744 \uc815\uc758\ud558\ub294 \uac83\uc774 \ubd88\uac00\ub2a5\ud574\uc9c0\uc9c0\ub9cc, \uc6b0\ub9ac\ub294 \uc77c\ubc18\uc801\uc73c\ub85c \uae30\ubcf8 \uc815\uc758\uc778 `return = pure`\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c \ub300\ubd80\ubd84\uc758 \uc608\uc81c\ub294 \uc601\ud5a5\uc744 \ubc1b\uc9c0 \uc54a\uc744 \uac83\uc774\ub2e4.\\n\\n### \uc608\uc2dc\\n\ud45c\uc900 \ub77c\uc774\ube0c\ub7ec\ub9ac(prelude)\uc5d0\uc11c, `Maybe` \ud0c0\uc785\uc758 \ubc14\uc778\ub4dc(bind) \uc5f0\uc0b0\uc790\ub294 \ub2e8\uc21c\uc131\uc744 \uc704\ud574 \ucf00\uc774\uc2a4 \ubd84\uc11d \ub300\uc2e0 \ud328\ud134 \ub9e4\uce6d\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc815\uc758\ub41c\ub2e4.\\n```haskell\\ninstance Monad Maybe where\\n    -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\\n    Nothing >>= _ = Nothing\\n    (Just x) >>= f = f x\\n```\\n\uc774 \uc120\uc5b8 \ub54c\ubb38\uc5d0 `do` \ud45c\uae30\ubc95\uc774 \uc774\uc804 \uc139\uc158\uc758 `eval` \ud568\uc218\uc5d0\uc11c\ucc98\ub7fc `Maybe` \uac12\uc744 \ud504\ub85c\uadf8\ub798\ubc0d\ud558\ub294 \ub370 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 \uac83\uc774\ub2e4.\\n\\n\\\\\\n\ub9ac\uc2a4\ud2b8 \ub610\ud55c \ub2e4\uc74c\uacfc \uac19\uc774 \ubaa8\ub098\ub4dc \ud0c0\uc785\uc73c\ub85c \ub9cc\ub4e4\uc5b4\uc9c8 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Monad [] where\\n    -- (>>=) :: [a] -> (a -> [b]) -> [b]\\n    xs >>= f = [y | x <- xs, y <- f x]\\n```\\n\uc989, `xs >>= f`\ub294 `xs`\uc758 \uac01 \uacb0\uacfc `x`\uc5d0 \ud568\uc218 `f`\ub97c \uc801\uc6a9\ud558\uace0, \uadf8 \uacb0\uacfc \uac12\ub4e4\uc744 \ubaa8\ub450 \ub9ac\uc2a4\ud2b8\uc5d0 \ubaa8\uc740\ub2e4. \uc774\ub7f0 \uc2dd\uc73c\ub85c \ub9ac\uc2a4\ud2b8\uc758 \ubc14\uc778\ub4dc \uc5f0\uc0b0\uc790\ub294 \uc5ec\ub7ec \uacb0\uacfc\ub97c \uc0dd\uc131\ud560 \uc218 \uc788\ub294 \ud45c\ud604\uc2dd\uc744 \uc2dc\ud000\uc2f1\ud558\ub294 \uc218\ub2e8\uc744 \uc81c\uacf5\ud55c\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \ub450 \ub9ac\uc2a4\ud2b8\uc758 \uc6d0\uc18c\ub97c \uc9dd\uc9d3\ub294 \ubaa8\ub4e0 \uac00\ub2a5\ud55c \ubc29\ubc95\uc744 \ubc18\ud658\ud558\ub294 \ud568\uc218\ub294 \uc774\uc81c `do` \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\npairs :: [a] -> [b] -> [(a,b)]\\npairs xs ys = do x <- xs\\n                 y <- ys\\n                 return (x,y)\\n```\\n\uc608\ub97c \ub4e4\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4.\\n```haskell\\n> pairs [1,2] [3,4]\\n[(1,3),(1,4),(2,3),(2,4)]\\n```\\n`pairs`\uc758 \ub9c8\uc9c0\ub9c9 \uc904\uc5d0\uc11c \uae30\ubcf8 \uc815\uc758\uc778 `return = pure` \ub54c\ubb38\uc5d0 `pure (x,y)`\ub97c \uc4f8 \uc218\ub3c4 \uc788\uc5c8\uc9c0\ub9cc, \ubaa8\ub098\ub4dc \ud504\ub85c\uadf8\ub798\ubc0d\uc5d0\uc11c\ub294 `return` \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774 \uad00\ub840\ub77c\ub294 \uc810\uc5d0 \uc720\uc758\ud558\uc790. \ub610\ud55c \uc774 \uc815\uc758\uac00 \ub9ac\uc2a4\ud2b8 \ucef4\ud504\ub9ac\ud5e8\uc158 \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud55c \uc815\uc758\uc640 \uc720\uc0ac\ud558\ub2e4\ub294 \uc810\ub3c4 \ud765\ubbf8\ub86d\ub2e4.\\n```haskell\\npairs xs ys = [(x,y) | x <- xs, y <- ys]\\n```\\n\ud558\uc9c0\ub9cc \ucef4\ud504\ub9ac\ud5e8\uc158 \ud45c\uae30\ubc95\uc740 \ub9ac\uc2a4\ud2b8 \ud0c0\uc785\uc5d0\ub9cc \ud2b9\uc815\ub418\uc9c0\ub9cc, `do` \ud45c\uae30\ubc95\uc740 \uc784\uc758\uc758 \ubaa8\ub098\ub4dc\uc640 \ud568\uaed8 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4.\\n\\n\\\\\\n\ud45c\uc900 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \ub610\ud55c `IO` \ud0c0\uc785\uc5d0 \ub300\ud55c \uc778\uc2a4\ud134\uc2a4\ub3c4 \ud3ec\ud568\ud558\uba70, \uc774\ub294 \uc0c1\ud638\uc791\uc6a9 \ud504\ub85c\uadf8\ub798\ubc0d\uc744 \uc704\ud55c `do` \ud45c\uae30\ubc95 \uc0ac\uc6a9\uc744 \uc9c0\uc6d0\ud55c\ub2e4. \uc704\uc758 \ub2e4\ub978 \uc608\uc81c\ub4e4\uacfc \ub2ec\ub9ac, \uc774 \uacbd\uc6b0 `return`\uacfc `>>=`\uc758 \uc815\uc758\ub294 \ud558\uc2a4\ucf08 \uc790\uccb4 \ub0b4\uc5d0\uc11c \uc815\uc758\ub418\uae30\ubcf4\ub2e4\ub294 \uc5b8\uc5b4\uc5d0 \ub0b4\uc7a5\ub418\uc5b4 \uc788\ub2e4.\\n```haskell\\ninstance Monad IO where\\n    -- return :: a -> IO a\\n    return x = ...\\n    \\n    -- (>>=) :: IO a -> (a -> IO b) -> IO b\\n    mx >>= f = ...\\n```\\n\\n### The state monad\\n\uc774\uc81c \uc2dc\uac04\uc5d0 \ub530\ub77c \ubcc0\ud560 \uc218 \uc788\ub294 \uc5b4\ub5a4 \ud615\ud0dc\uc758 **\uc0c1\ud0dc(state)** \ub97c \uc870\uc791\ud558\ub294 \ud568\uc218\ub97c \uc791\uc131\ud558\ub294 \ubb38\uc81c\ub97c \uc0dd\uac01\ud574 \ubcf4\uc790. \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud558\uac8c \uc0c1\ud0dc\ub294 \ub2e8\uc9c0 \uc815\uc218 \uac12\uc774\ub77c\uace0 \uac00\uc815\ud558\uc9c0\ub9cc, \ud544\uc694\uc5d0 \ub530\ub77c \uc218\uc815\ub420 \uc218 \uc788\ub2e4:\\n```haskell\\ntype State = Int\\n```\\n\uc774 \ud0c0\uc785\uc5d0 \ub300\ud55c \uac00\uc7a5 \uae30\ubcf8\uc801\uc778 \ud615\ud0dc\uc758 \ud568\uc218\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790(state transformer), \uc57d\uc790\ub85c ST\uc774\ub2e4. \uc774\uac83\uc740 \uc785\ub825 \uc0c1\ud0dc\ub97c \uc778\uc790\ub85c \ubc1b\uc544\uc11c \uacb0\uacfc\ub85c \ucd9c\ub825 \uc0c1\ud0dc\ub97c \ub9cc\ub4e4\uc5b4\ub0b4\uba70, \uc774\ub54c \ucd9c\ub825 \uc0c1\ud0dc\ub294 \ud568\uc218 \uc2e4\ud589 \uc911\uc5d0 \uc0c1\ud0dc\uc5d0 \uac00\ud574\uc9c4 \ubaa8\ub4e0 \ubcc0\uacbd \uc0ac\ud56d\uc744 \ubc18\uc601\ud55c\ub2e4:\\n```haskell\\ntype ST = State -> State\\n```\\n\ud558\uc9c0\ub9cc \uc77c\ubc18\uc801\uc73c\ub85c, \uc0c1\ud0dc\ub97c \uac31\uc2e0\ud558\ub294 \uac83 \uc678\uc5d0\ub3c4 \uacb0\uacfc \uac12\uc744 \ubc18\ud658\ud558\uace0 \uc2f6\uc744 \uc218 \uc788\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \uc0c1\ud0dc\uac00 \uce74\uc6b4\ud130\ub97c \ub098\ud0c0\ub0b8\ub2e4\uba74, \uce74\uc6b4\ud130\ub97c \uc99d\uac00\uc2dc\ud0a4\ub294 \ud568\uc218\ub294 \uadf8\uac83\uc758 \ud604\uc7ac \uac12\uc744 \ubc18\ud658\ud558\uace0 \uc2f6\uc744 \uc218\ub3c4 \uc788\ub2e4. \uc774\ub7ec\ud55c \uc774\uc720\ub85c, \uc0c1\ud0dc \ubcc0\ud658\uc790\uc758 \ud0c0\uc785\uc744 \uc77c\ubc18\ud654\ud558\uc5ec \uacb0\uacfc \uac12\ub3c4 \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uba70, \uc774\ub7ec\ud55c \uac12\uc758 \ud0c0\uc785\uc740 ST \ud0c0\uc785\uc758 \ud30c\ub77c\ubbf8\ud130\uac00 \ub41c\ub2e4:\\n```haskell\\ntype ST a = State -> (a, State)\\n```\\n\\\\\\n\uc774\ub7ec\ud55c \ud568\uc218\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \uadf8\ub9bc \ud615\ud0dc\ub85c \ud45c\uc2dc\ub420 \uc218 \uc788\ub2e4. \uc5ec\uae30\uc11c **s** \ub294 \uc785\ub825 \uc0c1\ud0dc, **s\'** \ub294 \ucd9c\ub825 \uc0c1\ud0dc, **v** \ub294 \uacb0\uacfc \uac12\uc774\ub2e4:\\n\\n![img1](image-1.png)\\n\\n\ubc18\ub300\ub85c, \uc0c1\ud0dc \ubcc0\ud658\uc790\ub294 \uc778\uc790 \uac12\uc744 \ubc1b\uace0 \uc2f6\uc744 \uc218\ub3c4 \uc788\ub2e4. \ud558\uc9c0\ub9cc \uc774\ub97c \uace0\ub824\ud558\uae30 \uc704\ud574 ST \ud0c0\uc785\uc744 \ub354 \uc77c\ubc18\ud654\ud560 \ud544\uc694\ub294 \uc5c6\ub294\ub370, \uc65c\ub0d0\ud558\uba74 \uc774\ub7ec\ud55c \ub3d9\uc791\uc740 \uc774\ubbf8 **\ucee4\ub9c1(currying)** \uc744 \ud65c\uc6a9\ud558\uc5ec \ub2ec\uc131\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \uc608\ub97c \ub4e4\uc5b4, \ubb38\uc790\ub97c \ubc1b\uc544\uc11c \uc815\uc218\ub97c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub294 `Char -> ST Int` \ud0c0\uc785\uc744 \uac00\uc9c8 \uac83\uc774\uba70, \uc774\ub294 \uc544\ub798 \uadf8\ub9bc\uacfc \uac19\uc774 \ucee4\ub9c1\ub41c \ud568\uc218 \ud0c0\uc785\uc778 `Char -> State -> (Int, State)`\ub97c \ucd95\uc57d\ud55c \uac83\uc774\ub2e4:\\n\\n![img2](image-2.png)\\n\\nST\uac00 \ud30c\ub77c\ubbf8\ud130\ud654\ub41c \ud0c0\uc785\uc774\ub77c\ub294 \uc810\uc744 \uac10\uc548\ud560 \ub54c, \uc774\ub97c **\ubaa8\ub098\ub4dc(monad)** \ub85c \ub9cc\ub4e4\uc5b4\uc11c \uc0c1\ud0dc\uac00 \uc788\ub294(stateful) \ud504\ub85c\uadf8\ub7a8\uc744 \uc791\uc131\ud558\ub294 \ub370 `do` \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \uc2dc\ub3c4\ud558\ub294 \uac83\uc740 \uc790\uc5f0\uc2a4\ub7fd\ub2e4. \ud558\uc9c0\ub9cc, `type` \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud574 \uc120\uc5b8\ub41c \ud0c0\uc785\uc740 \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub420 \uc218 \uc5c6\ub2e4. \ub530\ub77c\uc11c, \uba3c\uc800 newtype \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec `ST` \ud0c0\uc785\uc744 \uc7ac\uc815\uc758\ud558\ub294\ub370, \uc5ec\uae30\uc5d0\ub294 **S** \ub77c\uace0 \ubd80\ub974\ub294 **\ub354\ubbf8 \uc0dd\uc131\uc790(dummy constructor)** \ub97c \ub3c4\uc785\ud574\uc57c \ud55c\ub2e4:\\n```haskell\\nnewtype ST a = S (State -> (a, State))\\n```\\n\\n\ub610\ud55c \uc774 \ud0c0\uc785\uc744 \uc704\ud574 \ub354\ubbf8 \uc0dd\uc131\uc790\ub97c \ub2e8\uc21c\ud788 \uc81c\uac70\ud558\ub294 \ud2b9\uc218 \ubaa9\uc801\uc758 \uc801\uc6a9 \ud568\uc218(application function)\ub97c \uc815\uc758\ud558\ub294 \uac83\uc774 \ud3b8\ub9ac\ud558\ub2e4:\\n```haskell\\napp :: ST a -> State -> (a, State)\\napp (S st) x = st x\\n```\\n\\n\ud30c\ub77c\ubbf8\ud130\ud654\ub41c ST \ud0c0\uc785\uc744 \ubaa8\ub098\ub4dc\ub85c \ub9cc\ub4e4\uae30 \uc704\ud55c \uccab \ub2e8\uacc4\ub85c\uc11c, \uc774 \ud0c0\uc785\uc744 \uac04\ub2e8\ud788 **\ud391\ud130(functor)** \ub85c \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\\n```haskell\\ninstance Functor ST where\\n    -- fmap :: (a -> b) -> ST a -> ST b\\n    fmap g st = S (\\\\s -> let (x,s\') = app st s in (g x, s\'))\\n```\\n\uc989, `fmap`\uc740 \ub2e4\uc74c \uadf8\ub9bc\uc5d0\uc11c\ucc98\ub7fc \uc0c1\ud0dc \ubcc0\ud658\uc790\uc758 \uacb0\uacfc \uac12\uc5d0 \ud568\uc218\ub97c \uc801\uc6a9\ud558\uac8c \ud574\uc900\ub2e4.\\n\\n![img3](image-3.png)\\n\\n\uc704 \uc815\uc758\uc5d0 \uc0ac\uc6a9\ub41c \ud558\uc2a4\ucf08\uc758 `let` \uba54\ucee4\ub2c8\uc998\uc740 `where` \uba54\ucee4\ub2c8\uc998\uacfc \uc720\uc0ac\ud558\uc9c0\ub9cc, \ud568\uc218 \uc815\uc758 \uc218\uc900\uc774 \uc544\ub2cc \ud45c\ud604\uc2dd \uc218\uc900\uc5d0\uc11c local definition\uc744 \ud560 \uc218 \uc788\uac8c \ud574\uc900\ub2e4\ub294 \uc810\uc774 \ub2e4\ub974\ub2e4. \\n\uacb0\uacfc\uc801\uc73c\ub85c, `ST` \ud0c0\uc785\uc740 **\uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130(applicative functor)** \ub85c \ub9cc\ub4e4\uc5b4\uc9c8 \uc218 \uc788\ub2e4.\\n\\n```haskell\\ninstance Applicative ST where\\n    -- pure :: a -> ST a\\n    pure x = S (\\\\s -> (x,s))\\n    \\n    -- (<*>) :: ST (a -> b) -> ST a -> ST b\\n    stf <*> stx = S (\\\\s ->\\n    let (f,s\')   = app stf s\\n        (x,s\'\')  = app stx s\' in (f x, s\'\'))\\n```\\n\uc774 \uacbd\uc6b0, `pure` \ud568\uc218\ub294 \uc5b4\ub5a4 \uac12\uc744 \uc0c1\ud0dc \ubcc0\uacbd \uc5c6\uc774 \uadf8\ub300\ub85c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub85c \ubcc0\ud658\ud55c\ub2e4.\\n\\n![img4](image-4.png)\\n\\n\ud55c\ud3b8, `<*>` \uc5f0\uc0b0\uc790\ub294 \ud568\uc218\ub97c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub97c \uc778\uc790\ub97c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\uc5d0 \uc801\uc6a9\ud558\uc5ec, \uadf8 \ud568\uc218\ub97c \uc778\uc790\uc5d0 \uc801\uc6a9\ud55c \uacb0\uacfc\ub97c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub97c \ub9cc\ub4e4\uc5b4\ub0b8\ub2e4.\\n\\n![img5](image-5.png)\\n\\n\uae30\ud638 `$`\ub294 \uc77c\ubc18\uc801\uc778 \ud568\uc218 \uc801\uc6a9\uc744 \ub098\ud0c0\ub0b4\uba70, `f $ x` = `f x`\ub85c \uc815\uc758\ub41c\ub2e4.\\n\\n\ub9c8\uc9c0\ub9c9\uc73c\ub85c, `ST`\uc5d0 \ub300\ud55c \ubaa8\ub098\ub4dc \uc778\uc2a4\ud134\uc2a4\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \uc120\uc5b8\ub41c\ub2e4.\\n```haskell\\ninstance Monad ST where\\n    -- (>>=) :: ST a -> (a -> ST b) -> ST b\\n    st >>= f = S (\\\\s -> let (x,s\') = app st s in app (f x) s\')\\n```\\n\uc989, `st >>= f`\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790 `st`\ub97c \ucd08\uae30 \uc0c1\ud0dc `s`\uc5d0 \uc801\uc6a9\ud55c \ub2e4\uc74c, \uadf8 \uacb0\uacfc \uac12 `x`\uc5d0 \ud568\uc218 `f`\ub97c \uc801\uc6a9\ud558\uc5ec \uc0c8\ub85c\uc6b4 \uc0c1\ud0dc \ubcc0\ud658\uc790 `f x`\ub97c \uc5bb\ub294\ub2e4. \uadf8\ub9ac\uace0 \uc774 `f x`\ub97c \uc0c8\ub85c\uc6b4 \uc0c1\ud0dc `s\'`\uc5d0 \uc801\uc6a9\ud558\uc5ec \ucd5c\uc885 \uacb0\uacfc\ub97c \uc5bb\ub294\ub2e4.\\n\\n![img6](image-6.png)\\n\\n\uc774\ub7f0 \ubc29\uc2dd\uc73c\ub85c, \uc0c1\ud0dc \ubaa8\ub098\ub4dc\uc758 **\ubc14\uc778\ub4dc(bind) \uc5f0\uc0b0\uc790(>>=)** \ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub4e4\uc758 \uc21c\ucc28\uc801 \uc2e4\ud589\uacfc \uadf8 \uacb0\uacfc \uac12\uc758 \ucc98\ub9ac\ub97c \ud1b5\ud569\ud55c\ub2e4. `>>=`\uc758 \uc815\uc758 \ub0b4\uc5d0\uc11c\ub294 \uccab \ubc88\uc9f8 \uc778\uc790\uc758 \uacb0\uacfc \uac12 `x`\uc5d0 \ub530\ub77c \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c8 \uc218 \uc788\ub294 \uc0c8\ub85c\uc6b4 \uc0c1\ud0dc \ubcc0\ud658\uc790 `f x`\ub97c \ub9cc\ub4e4\uc5b4\ub0b4\ub294 \ubc18\uba74, `<*>`\uc5d0\uc11c\ub294 \uc778\uc790\ub85c \uba85\uc2dc\uc801\uc73c\ub85c \uc81c\uacf5\ub41c \uc0c1\ud0dc \ubcc0\ud658\uc790\ub9cc \uc0ac\uc6a9\ud558\ub3c4\ub85d \uc81c\ud55c\ub41c\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud574\uc57c \ud55c\ub2e4. \ub530\ub77c\uc11c `>>=` \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\uba74 \ub354 \ud070 \uc720\uc5f0\uc131\uc744 \uc5bb\uc744 \uc218 \uc788\ub2e4.\\n\\n### Relabelling trees\\nstateful programming\uc758 \ud55c \uc608\uc2dc\ub85c\uc11c, \ud2b8\ub9ac\uc758 \ub77c\ubca8\uc744 \ub2e4\uc2dc \ubd99\uc774\ub294 \ud568\uc218\ub97c \uac1c\ubc1c\ud574 \ubcf4\uc790.  \\n\uc774\ub97c \uc704\ud574 \ub2e4\uc74c \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\\n```haskell\\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\\n    deriving Show\\n```\\n\\n\uc608\ub97c \ub4e4\uc5b4, \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\ntree :: Tree Char\\ntree = Node (Node (Leaf \'a\') (Leaf \'b\')) (Leaf \'c\')\\n```\\n\uc774\uc81c \uc774\ub7f0 \ud2b8\ub9ac \ub0b4\uc758 \uac01 \ub9ac\ud504(leaf)\ub97c \uace0\uc720\ud55c, \uc989 \uc0c8\ub85c\uc6b4(fresh) \uc815\uc218\ub85c \uc7ac\ub77c\ubca8\ub9c1\ud558\ub294 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \ubb38\uc81c\ub97c \uc0dd\uac01\ud574 \ubcf4\uc790. \ud558\uc2a4\ucf08\uacfc \uac19\uc740 \uc21c\uc218 \uc5b8\uc5b4\uc5d0\uc11c\ub294 \ub2e4\uc74c\uc5d0 \uc0ac\uc6a9\ud560 \uc0c8 \uc815\uc218\ub97c \ucd94\uac00 \uc778\uc790\ub85c \ubc1b\uace0, \uadf8 \ub2e4\uc74c \uc0ac\uc6a9\ud560 \uc815\uc218\ub97c \ucd94\uac00 \uacb0\uacfc\ub85c \ubc18\ud658\ud558\ub294 \ubc29\uc2dd\uc73c\ub85c \uc774\ub97c \uad6c\ud604\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nrlabel :: Tree a -> Int -> (Tree Int, Int)\\nrlabel (Leaf _) n = (Leaf n, n+1)\\nrlabel (Node l r) n = (Node l\' r\', n\'\')\\n    where\\n        (l\',n\')   = rlabel l n\\n        (r\',n\'\')  = rlabel r n\'\\n```\\n\uadf8\ub7ec\uba74, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \uacb0\uacfc\ub97c \uc5bb\ub294\ub2e4.\\n```haskell\\n> fst (rlabel tree 0)\\nNode (Node (Leaf 0) (Leaf 1)) (Leaf 2)\\n```\\n\ud558\uc9c0\ub9cc `rlabel`\uc758 \uc815\uc758\ub294 \uc815\uc218 \uc0c1\ud0dc\ub97c \uacc4\uc0b0 \uacfc\uc815 \uc804\uccb4\uc5d0 \uac78\uccd0 \uba85\uc2dc\uc801\uc73c\ub85c \uc804\ub2ec\ud574\uc57c \ud560 \ud544\uc694\uc131 \ub54c\ubb38\uc5d0 \ubcf5\uc7a1\ud558\ub2e4. \ub354 \uac04\ub2e8\ud55c \uc815\uc758\ub97c \uc5bb\uae30 \uc704\ud574, \uba3c\uc800 `Tree a -> Int -> (Tree Int, Int)` \ud0c0\uc785\uc774 \uc0c1\ud0dc \ubcc0\ud658\uc790 \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud558\uc5ec `Tree a -> ST (Tree Int)`\ub85c \ub2e4\uc2dc \uc791\uc131\ub420 \uc218 \uc788\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc0c1\ud0dc\ub294 \ub2e4\uc74c\uc5d0 \uc0ac\uc6a9\ud560 \uc0c8 \uc815\uc218\uc774\ub2e4. \uc774\ub7ec\ud55c \ub2e4\uc74c \uc815\uc218\ub294 \ud604\uc7ac \uc0c1\ud0dc\ub97c \uacb0\uacfc\ub85c, \uadf8\ub9ac\uace0 \ub2e4\uc74c \uc815\uc218\ub97c \uc0c8\ub85c\uc6b4 \uc0c1\ud0dc\ub85c \ubc18\ud658\ud558\ub294 \uc0c1\ud0dc \ubcc0\ud658\uc790\ub97c \uc815\uc758\ud568\uc73c\ub85c\uc368 \uc0dd\uc131\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nfresh :: ST Int\\nfresh = S (\\\\n -> (n, n+1))\\n```\\n`ST`\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ud391\ud130\ub77c\ub294 \uc0ac\uc2e4\uc744 \uc774\uc6a9\ud558\uc5ec, \uc774\uc81c \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uc2a4\ud0c0\uc77c\ub85c \uc791\uc131\ub41c \uc0c8\ub85c\uc6b4 \ubc84\uc804\uc758 \uc7ac\ub77c\ubca8\ub9c1 \ud568\uc218\ub97c \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nalabel :: Tree a -> ST (Tree Int)\\nalabel (Leaf _) = Leaf <$> fresh\\nalabel (Node l r) = Node <$> alabel l <*> alabel r\\n```\\n(\ucc38\uace0: `g <$> x <*> y`\ub294 `pure g <*> x <*> y`\uc640 \ub3d9\uc77c\ud558\uac8c \ub3d9\uc791\ud55c\ub2e4.)  \\n\uc774 \uc0c8\ub85c\uc6b4 \ubc84\uc804\uc740 \uc774\uc804\uacfc \ub3d9\uc77c\ud55c \uacb0\uacfc\ub97c \uc900\ub2e4.\\n```haskell\\n> fst (app (alabel tree) 0)\\nNode (Node (Leaf 0) (Leaf 1)) (Leaf 2)\\n```\\n\ud558\uc9c0\ub9cc \uadf8 \uc815\uc758\ub294 \ud6e8\uc52c \ub354 \uac04\ub2e8\ud558\ub2e4. \uae30\ubcf8 \ucf00\uc774\uc2a4(base case)\uc5d0\uc11c\ub294 \uc774\uc81c `Leaf` \uc0dd\uc131\uc790\ub97c \ub2e4\uc74c \uc0c8 \uc815\uc218\uc5d0 \uc801\uc6a9\ud558\uae30\ub9cc \ud558\uba74 \ub418\uace0, \uc7ac\uadc0 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 \ub450 \uc11c\ube0c\ud2b8\ub9ac\ub97c \ub77c\ubca8\ub9c1\ud55c \uacb0\uacfc\uc5d0 `Node` \uc0dd\uc131\uc790\ub97c \uc801\uc6a9\ud55c\ub2e4. \ud2b9\ud788, \ud504\ub85c\uadf8\ub798\uba38\ub294 \ub354 \uc774\uc0c1 \uc815\uc218 \uc0c1\ud0dc\ub97c \uacc4\uc0b0 \uacfc\uc815\uc5d0 \uc77c\uc77c\uc774 \uc804\ub2ec\ud558\ub294 \uc9c0\ub8e8\ud558\uace0 \uc624\ub958\uac00 \ubc1c\uc0dd\ud558\uae30 \uc26c\uc6b4 \uc791\uc5c5\uc5d0 \ub300\ud574 \uac71\uc815\ud560 \ud544\uc694\uac00 \uc5c6\ub2e4. \uc774 \uc791\uc5c5\uc740 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \uba54\ucee4\ub2c8\uc998\uc5d0 \uc758\ud574 \uc790\ub3d9\uc73c\ub85c \ucc98\ub9ac\ub418\uae30 \ub54c\ubb38\uc774\ub2e4.\\n\\n`ST`\uac00 \ubaa8\ub098\ub4dc\uc774\uae30\ub3c4 \ud558\ub2e4\ub294 \uc0ac\uc2e4\uc744 \uc774\uc6a9\ud558\uc5ec, `do` \ud45c\uae30\ubc95\uc744 \uc0ac\uc6a9\ud574 \uc774\uc640 \ub3d9\uc77c\ud55c \uae30\ub2a5\uc758 \ubaa8\ub098\ub4dc \ubc84\uc804 \uc7ac\ub77c\ubca8\ub9c1 \ud568\uc218\ub97c \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nmlabel :: Tree a -> ST (Tree Int)\\nmlabel (Leaf _) = do n <- fresh\\n                     return (Leaf n)\\n\\nmlabel (Node l r) = do l\' <- mlabel l\\n                       r\' <- mlabel r\\n                       return (Node l\' r\')\\n```\\n\uc774 \uc815\uc758\ub294 \uc911\uac04 \uacb0\uacfc\uc5d0 \uc774\ub984\uc744 \ubd99\uc5ec\uc918\uc57c \ud55c\ub2e4\ub294 \uc810\uc744 \uc81c\uc678\ud558\uba74 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c \ubc84\uc804\uacfc \uc720\uc0ac\ud558\ub2e4. `rlabel`\uacfc \uac19\uc740 \ube44-\uc81c\ub124\ub9ad(non-generic) \ud568\uc218\uac00 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc640 \ubaa8\ub098\ub4dc \uc2a4\ud0c0\uc77c \ubaa8\ub450\ub85c \uc815\uc758\ub420 \uc218 \uc788\uc744 \ub54c, \uc5b4\ub5a4 \uc815\uc758\ub97c \uc120\ud638\ud560\uc9c0\ub294 \ub300\uccb4\ub85c \ucde8\ud5a5\uc758 \ubb38\uc81c\uc774\ub2e4.\\n\\n### Generic functions\\n\ubaa8\ub098\ub4dc\ub77c\ub294 \uac1c\ub150\uc744 \ucd94\uc0c1\ud654\ud568\uc73c\ub85c\uc368 \uc5bb\ub294 \uc911\uc694\ud55c \uc774\uc810\uc740 \uc5b4\ub5a4 \ubaa8\ub098\ub4dc\uc5d0\ub4e0 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 **\uc81c\ub124\ub9ad \ud568\uc218(generic function)** \ub97c \uc815\uc758\ud560 \uc218 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. `Control.Monad` \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0\ub294 \ub2e4\uc218\uc758 \uadf8\ub7f0 \ud568\uc218\ub4e4\uc774 \uc81c\uacf5\ub41c\ub2e4.  \\n\uc608\ub97c \ub4e4\uc5b4, \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c `map` \ud568\uc218\uc758 \ubaa8\ub098\ub4dc \ubc84\uc804\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ud560 \uc218 \uc788\ub2e4.\\n```haskell\\nmapM :: Monad m => (a -> m b) -> [a] -> m [b]\\nmapM f []     = return []\\nmapM f (x:xs) = do y  <- f x\\n                   ys <- mapM f xs\\n                   return (y:ys)\\n```\\n`mapM`\uc740 \uc778\uc790\ub85c \ubc1b\ub294 \ud568\uc218\uc640 \ud568\uc218 \uc790\uccb4\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \uc774\uc81c \ubaa8\ub098\ub4dc \ud0c0\uc785\uc774\ub77c\ub294 \uc810\uc744 \uc81c\uc678\ud558\uba74 `map`\uacfc \ub3d9\uc77c\ud55c \ud0c0\uc785\uc744 \uac16\ub294\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\uc790. \uc774\uac83\uc774 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294\uc9c0 \uc124\uba85\ud558\uae30 \uc704\ud574, \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uac00 \uc22b\uc790\uc77c \uacbd\uc6b0\uc5d0\ub9cc \uadf8 \ubb38\uc790\ub97c \ud574\ub2f9\ud558\ub294 \uc22b\uc790 \uac12\uc73c\ub85c \ubcc0\ud658\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574 \ubcf4\uc790.\\n```haskell\\nconv :: Char -> Maybe Int\\nconv c | isDigit c = Just (digitToInt c)\\n       | otherwise = Nothing\\n```\\n(`isDigit`\uc640 `digitToInt` \ud568\uc218\ub294 `Data.Char`\uc5d0\uc11c \uc81c\uacf5\ub41c\ub2e4.) `mapM`\uc744 `conv` \ud568\uc218\uc5d0 \uc801\uc6a9\ud558\uba74 \uc22b\uc790 \ubb38\uc790\uc5f4\uc744 \ud574\ub2f9\ud558\ub294 \uc22b\uc790 \uac12\uc758 \ub9ac\uc2a4\ud2b8\ub85c \ubcc0\ud658\ud558\ub294 \uc218\ub2e8\uc744 \uc5bb\uac8c \ub41c\ub2e4. \uc774 \ubcc0\ud658\uc740 \ubb38\uc790\uc5f4\uc758 \ubaa8\ub4e0 \ubb38\uc790\uac00 \uc22b\uc790\uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc131\uacf5\ud558\uace0, \uadf8\ub807\uc9c0 \uc54a\uc73c\uba74 \uc2e4\ud328\ud55c\ub2e4.\\n```haskell\\n> mapM conv \\"1234\\"\\nJust [1,2,3,4]\\n\\n> mapM conv \\"123a\\"\\nNothing\\n```\\n\ub2e4\uc74c\uc73c\ub85c, \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c `filter` \ud568\uc218\uc758 \ubaa8\ub098\ub4dc \ubc84\uc804\uc740 `mapM`\uacfc \uc720\uc0ac\ud55c \ubc29\uc2dd\uc73c\ub85c \ud0c0\uc785\uacfc \uc815\uc758\ub97c \uc77c\ubc18\ud654\ud558\uc5ec \uc815\uc758\ub41c\ub2e4.\\n```haskell\\nfilterM :: Monad m => (a -> m Bool) -> [a] -> m [a]\\nfilterM p []     = return []\\nfilterM p (x:xs) = do b  <- p x\\n                      ys <- filterM p xs\\n                      return (if b then x:ys else ys)\\n```\\n\uc608\ub97c \ub4e4\uc5b4, \ub9ac\uc2a4\ud2b8 \ubaa8\ub098\ub4dc\uc758 \uacbd\uc6b0 `filterM`\uc744 \uc0ac\uc6a9\ud558\uba74 \ub9ac\uc2a4\ud2b8\uc758 **\uba71\uc9d1\ud569(powerset)** \uc744 \ud2b9\ud788 \uac04\uacb0\ud558\uac8c \uacc4\uc0b0\ud558\ub294 \uc218\ub2e8\uc744 \uc5bb\uc744 \uc218 \uc788\ub2e4. \uba71\uc9d1\ud569\uc740 \ub9ac\uc2a4\ud2b8\uc758 \uac01 \uc6d0\uc18c\ub97c \ud3ec\ud568\ud558\uac70\ub098 \uc81c\uc678\ud558\ub294 \ubaa8\ub4e0 \uac00\ub2a5\ud55c \uacbd\uc6b0\uc758 \uc218\ub85c \uc8fc\uc5b4\uc9c4\ub2e4.\\n```haskell\\n> filterM (\\\\x -> [True,False]) [1,2,3]\\n[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]\\n```\\n\ub9c8\uc9c0\ub9c9 \uc608\ub85c, \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c `prelude` \ud568\uc218 `concat :: [[a]] -> [a]`\ub294 \uc784\uc758\uc758 \ubaa8\ub098\ub4dc\uc5d0 \ub300\ud574 \ub2e4\uc74c\uacfc \uac19\uc774 `join` \ud568\uc218\ub85c \uc77c\ubc18\ud654\ub41c\ub2e4.\\n```haskell\\njoin :: Monad m => m (m a) -> m a\\njoin mmx = do mx <- mmx\\n              x  <- mx\\n              return x\\n```\\n\uc774 \ud568\uc218\ub294 \uc911\ucca9\ub41c \ubaa8\ub098\ub4dc \uac12\uc744 \uc77c\ubc18 \ubaa8\ub098\ub4dc \uac12\uc73c\ub85c \ud3c9\ud0c4\ud654(flatten)\ud55c\ub2e4. \ub9ac\uc2a4\ud2b8 \ubaa8\ub098\ub4dc\uc5d0 \ub300\ud574\uc11c\ub294 `concat`\uacfc \ub3d9\uc77c\ud55c \ubc29\uc2dd\uc73c\ub85c \ub3d9\uc791\ud558\ub294 \ud55c\ud3b8, `Maybe` \ubaa8\ub098\ub4dc\uc5d0 \ub300\ud574\uc11c\ub294 \ubc14\uae65\ucabd\uacfc \uc548\ucabd \uac12 \ubaa8\ub450 \uc131\uacf5(`Just`)\uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc131\uacf5\ud55c\ub2e4.\\n```haskell\\n> join [[1,2],[3,4],[5,6]]\\n[1,2,3,4,5,6]\\n\\n> join (Just (Just 1))\\nJust 1\\n\\n> join (Just Nothing)\\nNothing\\n\\n> join Nothing\\nNothing\\n```\\n\\n### Monad laws\\n\ud391\ud130\ub098 \uc5b4\ud50c\ub9ac\ucee4\ud2f0\ube0c\uc640 \ube44\uc2b7\ud55c \ubc29\uc2dd\uc73c\ub85c, \ub450 \ubaa8\ub098\ub4dc \uae30\ubcf8 \uc5f0\uc0b0(primitive)\uc740 \uba87 \uac00\uc9c0 \ub4f1\uc2dd \ubc95\uce59\uc744 \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4.\\n- `return x >>= f` = `f x`\\n- `mx >>= return` = `mx`\\n- `(mx >>= f) >>= g` = `mx >>= (\\\\x -> (f x >>= g))`\\n\\n\uccab \ub450 \ub4f1\uc2dd\uc740 `return`\uacfc `>>=` \uc0ac\uc774\uc758 \uad00\uacc4\uc5d0 \ub300\ud55c \uac83\uc774\ub2e4.\\n\\n**\uccab \ubc88\uc9f8 \ub4f1\uc2dd(\uc88c\ud56d\ub4f1\uc6d0, Left identity)** \uc740, \uc5b4\ub5a4 \uac12\uc744 `return`\ud55c \ub4a4 \uadf8 \uacb0\uacfc\ub97c \ubaa8\ub098\ub4dc \ud568\uc218\uc5d0 \ub118\uae30\ub294 \uac83\uc740 \ub2e8\uc21c\ud788 \uadf8 \ud568\uc218\ub97c \uac12\uc5d0 \uc801\uc6a9\ud558\ub294 \uac83\uacfc \uac19\uc740 \uacb0\uacfc\ub97c \uc8fc\uc5b4\uc57c \ud55c\ub2e4\ub294 \uac83\uc744 \ub098\ud0c0\ub0b8\ub2e4.\\n\\n**\ub450 \ubc88\uc9f8 \ub4f1\uc2dd(\uc6b0\ud56d\ub4f1\uc6d0, Right identity)** \uc740, \ubaa8\ub098\ub4dc \uacc4\uc0b0\uc758 \uacb0\uacfc\ub97c `return` \ud568\uc218\uc5d0 \ub118\uae30\ub294 \uac83\uc740 \ub2e8\uc21c\ud788 \uadf8 \uacc4\uc0b0\uc744 \uc218\ud589\ud558\ub294 \uac83\uacfc \uac19\uc740 \uacb0\uacfc\ub97c \uc8fc\uc5b4\uc57c \ud55c\ub2e4\ub294 \uac83\uc744 \ub098\ud0c0\ub0b8\ub2e4.\\n\\n\uc885\ud569\ud558\uba74, \uc774 \ub450 \ub4f1\uc2dd\uc740 (`>>=`\uc758 \ub450 \ubc88\uc9f8 \uc778\uc790\uac00 \ubc14\uc778\ub529 \uc5f0\uc0b0\uc744 \ud3ec\ud568\ud55c\ub2e4\ub294 \uc810\uc744 \uac10\uc548\ud558\uba74) `return`\uc774 `>>=` \uc5f0\uc0b0\uc790\uc5d0 \ub300\ud55c \ud56d\ub4f1\uc6d0(identity)\uc774\ub77c\ub294 \uac83\uc744 \ub9d0\ud574\uc900\ub2e4.\\n\\n**\uc138 \ubc88\uc9f8 \ub4f1\uc2dd(\uacb0\ud569\ubc95\uce59, Associativity)** \uc740 `>>=`\uc640 \uc790\uc2e0 \uc0ac\uc774\uc758 \uad00\uacc4\uc5d0 \ub300\ud55c \uac83\uc73c\ub85c, (`>>=`\uac00 \ubc14\uc778\ub529\uc744 \ud3ec\ud568\ud55c\ub2e4\ub294 \uc810\uc744 \ub2e4\uc2dc \uac10\uc548\ud558\uba74) `>>=`\uac00 \uacb0\ud569\ubc95\uce59\uc744 \ub9cc\uc871\ud568\uc744 \ud45c\ud604\ud55c\ub2e4. \uc774 \ub4f1\uc2dd\uc758 \uc6b0\ubcc0\uc744 \ub2e8\uc21c\ud788 `mx >>= (f >>= g)`\ub85c \uc4f8 \uc218\ub294 \uc5c6\ub2e4\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud574\uc57c \ud558\ub294\ub370, \uc774\ub294 \ud0c0\uc785 \uac80\uc0ac\ub97c \ud1b5\uacfc\ud558\uc9c0 \ubabb\ud560 \uac83\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc6b0\ub9ac\uac00 \uc9c0\uae08\uae4c\uc9c0 \ubd10\uc628 \ubaa8\ub4e0 \ubaa8\ub098\ub4dc\ub294 \uc704\uc758 \ubc95\uce59\ub4e4\uc744 \ub9cc\uc871\ud55c\ub2e4."}]}}')}}]);