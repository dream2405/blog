"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[840],{3791:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>o});var a=s(9844),i=s(4848),c=s(8453);const t={slug:"calculating-compilers",title:"Calculating compilers",authors:["dream2405"],tags:["haskell","functional_programming"]},l=void 0,r={authorsImageUrls:[void 0]},o=[{value:"Introduction",id:"introduction",level:2},{value:"Syntax and semantics",id:"syntax-and-semantics",level:2},{value:"Adding a stack",id:"adding-a-stack",level:2},{value:"Adding a continuation",id:"adding-a-continuation",level:2},{value:"Defunctionalising",id:"defunctionalising",level:2},{value:"Combining the steps",id:"combining-the-steps",level:2}];function h(e){const n={admonition:"admonition",annotation:"annotation",code:"code",h2:"h2",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In this final chapter we show how the reasoning techniques introduced in the previous chapter can be used to calculate compilers. We start by showing how a semantics for a language can be transformed into a compiler in a series of steps, and then show how the steps can be combined to allow a compiler to be calculated directly from a statement of its correctness."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"The ability to calculate compilers has been a key objective in the field of program transformation since its earliest days. Starting from a high-level semantics for a source language, the aim is to transform the semantics into a compiler that translates source programs into a lower-level target language, together with a virtual machine that executes the resulting target programs."}),"\n",(0,i.jsxs)(n.p,{children:["There are two main advantages of such an approach. Firstly, the compiler, target language and virtual machine are ",(0,i.jsx)(n.strong,{children:"systematically derived"})," during the transformation process, rather than having to be manually defined by the user. And secondly, the resulting compiler and virtual machine do not usually require subsequent proofs of correctness, as they are ",(0,i.jsx)(n.strong,{children:"correct by construction"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In chapter 16 we presented a compiler for arithmetic expressions, and proved its correctness. In this chapter we show how the compiler can be calculated directly from a statement of its correctness. We develop our approach in two stages, first introducing the basic ideas using a series of transformation steps, and then showing how the separate steps can be combined into a single step. For simplicity, we restrict our attention to arithmetic expressions, but the same techniques can also be used to calculate compilers for more sophisticated languages."}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"\uc774\ub7f0 \ubc29\uc2dd\uc758 \uc811\uadfc\ubc95\uc740 \uc124\uacc4\ub3c4\ub85c \uac74\ubb3c\uc744 \ub9cc\ub4dc\ub294 \uac83\uacfc \ube44\uc2b7\ud558\ub2e4."}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'\uc124\uacc4\ub3c4 \uc900\ube44 - \uc5b8\uc5b4\uc758 \uc758\ubbf8\ub860\uc801 \uc815\uc758(Semantics), \uc989 "\uc774 \uc5b8\uc5b4\uc758 \uac01 \uad6c\ubb38\uc740 \uc5b4\ub5a4 \uc758\ubbf8\ub97c \uac00\uc9c0\uba70 \uc5b4\ub5bb\uac8c \ub3d9\uc791\ud574\uc57c \ud558\ub294\uac00"\ub77c\ub294 \ucd5c\uc0c1\uc704 \uba85\uc138\uc11c\ub97c \ub9cc\ub4e6'}),"\n",(0,i.jsx)(n.li,{children:"\uac74\uc124 - \uc774 \uba85\uc138\uc11c\uc5d0 \uc218\ud559\uc801\uc774\uace0 \ub17c\ub9ac\uc801\uc778 \ubcc0\ud658 \uaddc\uce59\uc744 \uc801\uc6a9"}),"\n",(0,i.jsx)(n.li,{children:"\uc644\uacf5 - \uc774 \uacfc\uc815\uc744 \ud1b5\ud574 \uc18c\uc2a4 \ucf54\ub4dc\ub97c Target Code\ub85c \ubcc0\ud658\ud558\ub294 \ud504\ub85c\uadf8\ub7a8, \uc989 \ucef4\ud30c\uc77c\ub7ec \uc790\uccb4\uac00 \uc790\ub3d9\uc73c\ub85c \uc0dd\uc131(\uc720\ub3c4)"}),"\n"]}),(0,i.jsx)(n.p,{children:"\ub9cc\uc57d \uc0ac\uc6a9\uc790\uac00 \uc9c1\uc811 \ucef4\ud30c\uc77c\ub7ec\ub97c \ub9cc\ub4e4\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \ub300\ud574 \uc62c\ubc14\ub974\uac8c \ub3d9\uc791\ud558\ub294\uc9c0 \uc218\ub9ce\uc740 \ud14c\uc2a4\ud2b8\uc640 \uc99d\uba85\uc744 \uac70\uccd0\uc57c \ud558\uc9c0\ub9cc, \uc774\ub7f0 \ubc29\uc2dd\uc740 \uc218\ud559\uc801 \uc99d\uba85\uacfc \uac19\uc740 \ub17c\ub9ac\uc801 \ub2e8\uacc4\ub97c \ud1b5\ud574 \ucef4\ud30c\uc77c\ub7ec\ub97c \uc790\ub3d9\uc73c\ub85c \uc720\ub3c4\ud574\ub0b8\ub2e4."}),(0,i.jsx)(n.p,{children:"\uc2dc\uc791\uc810(\uc5b8\uc5b4\uc758 \uc815\uc758)\uc774 \uc62c\ubc14\ub974\uace0 \ubcc0\ud658 \uacfc\uc815(\ub17c\ub9ac \uaddc\uce59)\uc5d0 \uacb0\ud568\uc774 \uc5c6\ub2e4\uba74, \uadf8 \uacb0\uacfc\ubb3c\uc778 \ucef4\ud30c\uc77c\ub7ec\ub294 \ud0dc\uc0dd\uc801\uc73c\ub85c \uc815\ud655\ud560 \uc218\ubc16\uc5d0 \uc5c6\ub2e4.\n\uc774\uac83\uc774 \ucef4\ud30c\uc77c\ub7ec \uc720\ub3c4\uc758 \ud575\uc2ec\uc774\ub2e4."})]}),"\n",(0,i.jsx)(n.h2,{id:"syntax-and-semantics",children:"Syntax and semantics"}),"\n",(0,i.jsx)(n.p,{children:"We start in the same manner as the compiler correctness example from the previous chapter, with two definitions that respectively capture the syntax (form) and semantics (meaning) of a simple language of arithmetic expressions built up from integer values using an addition operator:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Expr = Val Int | Add Expr Expr\n\neval :: Expr -> Int\neval (Val n) = n\neval (Add x y) = eval x + eval y\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, the expression ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1 + 2"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"})]})]})]})," can be evaluated as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval (Add (Val 1) (Val 2))\n= { applying eval }\n  eval (Val 1) + eval (Val 2)\n= { applying the first eval }\n  1 + eval (Val 2)\n= { applying eval }\n  1 + 2\n= { applying + }\n  3\n"})}),"\n",(0,i.jsx)(n.p,{children:"We now show how to calculate a compiler based on this semantics using a series of three transformation steps. The first two steps generalise the evaluation function, and the final step simplifies the resulting definitions."}),"\n",(0,i.jsx)(n.h2,{id:"adding-a-stack",children:"Adding a stack"}),"\n",(0,i.jsxs)(n.p,{children:["The first step is to transform the evaluation function ",(0,i.jsx)(n.code,{children:"eval"})," into a version that utilises a stack, in order to make the manipulation of argument values explicit. In particular, rather than returning a single value of type ",(0,i.jsx)(n.code,{children:"Int"}),", we seek to define a more general evaluation function, ",(0,i.jsx)(n.code,{children:"eval'"}),", that takes a stack of integers as an additional argument, and returns a modified stack given by pushing the value of the expression onto the top of the stack. More precisely, if we represent a stack as a list of integers (where the head is the top element)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"type Stack = [Int]\n"})}),"\n",(0,i.jsx)(n.p,{children:"then we seek to define a function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' :: Expr -> Stack -> Stack\n"})}),"\n",(0,i.jsx)(n.p,{children:"with the following property:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' e s = eval e : s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Rather than first defining ",(0,i.jsx)(n.code,{children:"eval'"})," and then proving by induction on the expression ",(0,i.jsx)(n.code,{children:"e"})," that it satisfies the above equation, we use the technique introduced in the previous chapter and calculate a definition for ",(0,i.jsx)(n.code,{children:"eval'"})," that satisfies this equation, using the desire to apply the induction hypotheses as the driving force for the calculation process. In the base case, ",(0,i.jsx)(n.code,{children:"Val n"}),", the calculation is easy:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval' (Val n) s\n= { specification of eval' }\n  eval (Val n) : s\n= { applying eval }\n  n : s\n= { define: push n s = n : s }\n  push n s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that in the final step we defined an auxiliary function, ",(0,i.jsx)(n.code,{children:"push"}),", that captures the idea of pushing a number onto the stack. With the above calculation, we have discovered the definition of ",(0,i.jsx)(n.code,{children:"eval'"})," for expressions of the form ",(0,i.jsx)(n.code,{children:"Val n"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' (Val n) s = push n s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the inductive case, ",(0,i.jsx)(n.code,{children:"Add x y"}),", we proceed as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval' (Add x y) s\n= { specification of eval' }\n  eval (Add x y) : s\n= { applying eval }\n  (eval x + eval y) : s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we appear to be stuck, as no further definitions can be applied. However, as we are performing an inductive calculation, we can make use of the induction hypotheses for the two argument expressions ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"}),", namely:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"eval' x s'"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval x : s'"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"eval' y s'"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval y : s'"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to use these hypotheses, it is clear that we must push the values ",(0,i.jsx)(n.code,{children:"eval x"})," and ",(0,i.jsx)(n.code,{children:"eval y"})," onto the stack, which can readily be achieved by introducing another auxiliary function, ",(0,i.jsx)(n.code,{children:"add"}),", that captures the idea of adding the top two numbers on the stack. The remainder of the calculation is then straightforward:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  (eval x + eval y) : s\n= { define: add (m : n : s) = n+m : s }\n  add (eval y : eval x : s)\n= { induction hypothesis for x }\n  add (eval y : eval' x s)\n= { induction hypothesis for y }\n  add (eval' y (eval' x s))\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u25a1"}),"\n",(0,i.jsxs)(n.p,{children:["Note that pushing ",(0,i.jsx)(n.code,{children:"eval x"})," onto the stack before ",(0,i.jsx)(n.code,{children:"eval y"})," above corresponds to addition evaluating its arguments from left-to-right. It would be perfectly valid to push the values in the opposite order, which would correspond to right-to-left evaluation."]}),"\n",(0,i.jsx)(n.p,{children:"In conclusion, we have calculated the following definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' :: Expr -> Stack -> Stack\neval' (Val n)   s = push n s\neval' (Add x y) s = add (eval' y (eval' x s))\n"})}),"\n",(0,i.jsx)(n.p,{children:"where:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"push :: Int -> Stack -> Stack\npush n s = n : s\n\nadd :: Stack -> Stack\nadd (m : n : s) = n+m : s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, our original evaluation function ",(0,i.jsx)(n.code,{children:"eval"})," can now be recovered from our new function by substituting the empty stack ",(0,i.jsx)(n.code,{children:"s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"[]"})," into the equation ",(0,i.jsx)(n.code,{children:"eval' e s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval e : s"})," from which ",(0,i.jsx)(n.code,{children:"eval'"})," was constructed, and selecting the unique value in the resulting singleton stack using the function ",(0,i.jsx)(n.code,{children:"head"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval :: Expr -> Int\neval e = head (eval' e [])\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, using this new definition evaluation of ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1+2"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"})]})]})]})," now proceeds by pushing the two values onto the stack prior adding them together:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval (Add (Val 1) (Val 2))\n= { applying eval }\n  head (eval' (Add (Val 1) (Val 2)) [])\n= { applying eval' }\n  head (add (eval' (Val 2) (eval' (Val 1) [])))\n= { applying the inner eval' }\n  head (add (eval' (Val 2) (push 1 [])))\n= { applying eval' }\n  head (add (push 2 (push 1 [])))\n= { applying push }\n  head (add (2 : 1 : []))\n= { applying add }\n  head (3 : [])\n= { applying head }\n  3\n"})}),"\n",(0,i.jsx)(n.h2,{id:"adding-a-continuation",children:"Adding a continuation"}),"\n",(0,i.jsxs)(n.p,{children:["The next step is to transform the stack-based evaluation function ",(0,i.jsx)(n.code,{children:"eval'"})," into ",(0,i.jsx)(n.strong,{children:"continuation-passing style"}),", in order to make the flow of control explicit. In particular, we seek to define a more general evaluation function, ",(0,i.jsx)(n.code,{children:"eval''"}),", that takes a function from stacks to stacks (the continuation) as an additional argument, which is used to process the stack that results from evaluating the expression."]}),"\n",(0,i.jsx)(n.p,{children:"More precisely, if we define a type for continuations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"type Cont = Stack -> Stack\n"})}),"\n",(0,i.jsx)(n.p,{children:"then we seek to define a function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval'' :: Expr -> Cont -> Cont\n"})}),"\n",(0,i.jsx)(n.p,{children:"such that:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval'' e c s = c (eval' e s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We calculate the definition for ",(0,i.jsx)(n.code,{children:"eval''"})," directly from this equation by induction on the expression ",(0,i.jsx)(n.code,{children:"e"}),". The base case is once again easy,"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval'' (Val n) c s\n= { specification of eval'' }\n  c (eval' (Val n) s)\n= { applying eval' }\n  c (push n s)\n"})}),"\n",(0,i.jsx)(n.p,{children:"while for the inductive case we calculate as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval'' (Add x y) c s\n= { specification of eval'' }\n  c (eval' (Add x y) s)\n= { applying eval' }\n  c (add (eval' y (eval' x s)))\n= { unapplying . }\n  (c . add) (eval' y (eval' x s))\n= { induction hypothesis for y }\n  eval'' y (c . add) (eval' x s)\n= { induction hypothesis for x }\n  eval'' x (eval'' y (c . add)) s\n"})}),"\n",(0,i.jsx)(n.p,{children:"In conclusion, we have calculated the following definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval'' :: Expr -> Cont -> Cont\neval'' (Val n)   c s = c (push n s)\neval'' (Add x y) c s = eval'' x (eval'' y (c . add)) s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Our previous evaluation function ",(0,i.jsx)(n.code,{children:"eval'"})," can now be recovered by substituting the identity continuation ",(0,i.jsx)(n.code,{children:"c"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"id"})," into the equation ",(0,i.jsx)(n.code,{children:"eval'' e c s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"c (eval' e s)"})," from which the function ",(0,i.jsx)(n.code,{children:"eval''"})," was constructed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' :: Expr -> Cont\neval' e s = eval'' e id s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, evaluation of ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1 + 2"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"})]})]})]})," now proceeds by transferring control to evaluation of the second argument once evaluation of the first has completed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  eval' (Add (Val 1) (Val 2)) []\n= { applying eval' }\n  eval'' (Add (Val 1) (Val 2)) id []\n= { applying eval'' }\n  eval'' (Val 1) (eval'' (Val 2) (id . add)) []\n= { applying the outer eval'' }\n  eval'' (Val 2) (id . add) (push 1 [])\n= { applying eval'' }\n  (id . add) (push 2 (push 1 []))\n= { applying . }\n  id (add (push 2 (push 1 [])))\n= { applying push }\n  id (add (2 : 1 : []))\n= { applying add }\n  id [3]\n= { applying id }\n  [3]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"defunctionalising",children:"Defunctionalising"}),"\n",(0,i.jsxs)(n.p,{children:["The third and final step is to transform the evaluation function back into first-order style, using ",(0,i.jsx)(n.strong,{children:"defunctionalisation"}),". In particular, rather than using functions of type ",(0,i.jsx)(n.code,{children:"Cont"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"Stack -> Stack"})," for continuations passed as arguments and returned as results, we define a new type that represents the specific forms of continuations that we actually need for our evaluation function."]}),"\n",(0,i.jsxs)(n.p,{children:["Within the definitions for ",(0,i.jsx)(n.code,{children:"eval'"})," and ",(0,i.jsx)(n.code,{children:"eval''"}),", there are only three forms of continuations that are used, namely one to halt the evaluation process, one to push a number onto the top of the stack, and one to add the top two numbers on the stack. We begin by separating out these three forms, by giving them names and passing their variables as parameters. That is, we define three ",(0,i.jsx)(n.strong,{children:"combinators"})," for constructing the required forms of continuations:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"haltC :: Cont\nhaltC = id\n\npushC :: Int -> Cont -> Cont\npushC n c = c . push n\n\naddC :: Cont -> Cont\naddC c = c . add\n"})}),"\n",(0,i.jsx)(n.p,{children:"Using these combinators, our evaluators can now be rewritten as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"eval' :: Expr -> Cont\neval' e = eval'' e haltC\n\neval'' :: Expr -> Cont -> Cont\neval'' (Val n)   c = pushC n c\neval'' (Add x y) c = eval'' x (eval'' y (addC c))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is easy to check by expanding definitions that these are equivalent to the previous versions. The next stage in applying defunctionalisation is to define a new type, ",(0,i.jsx)(n.code,{children:"Code"}),", whose constructors represent the three combinators:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Code = HALT | PUSH Int Code | ADD Code\n    deriving Show\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The constructors of this type have the same types as the corresponding combinators, except that the new type ",(0,i.jsx)(n.code,{children:"Code"})," now plays the role of ",(0,i.jsx)(n.code,{children:"Cont"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"HALT :: Code\nPUSH :: Int -> Code -> Code\nADD  :: Code -> Code\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The name ",(0,i.jsx)(n.code,{children:"Code"})," for the type reflects the fact that its values represent code for a virtual machine that evaluates expressions using a stack. For example, the code ",(0,i.jsx)(n.code,{children:"PUSH 1 (PUSH 2 (ADD HALT))"})," corresponds to the expression ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1 + 2"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"})]})]})]}),". The fact that values of type ",(0,i.jsx)(n.code,{children:"Code"})," represent continuations of type ",(0,i.jsx)(n.code,{children:"Cont"})," is formalised by defining a function that maps from one to the other:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"exec :: Code -> Cont\nexec HALT       = haltC\nexec (PUSH n c) = pushC n (exec c)\nexec (ADD c)    = addC (exec c)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In turn, we then simplify the definition for ",(0,i.jsx)(n.code,{children:"exec"})," by expanding out the definitions for the type ",(0,i.jsx)(n.code,{children:"Cont"})," and its three combinators."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"HALT"})," case:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec HALT s\n= { applying exec }\n  haltC s\n= { applying haltC }\n  id s\n= { applying id }\n  s\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PUSH"})," case:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec (PUSH n c) s\n= { applying exec }\n  pushC n (exec c) s\n= { applying pushC }\n  (exec c . push n) s\n= { applying . }\n  exec c (push n s)\n= { applying push }\n  exec c (n : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ADD"})," case:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec (ADD c) s\n= { applying exec }\n  addC (exec c) s\n= { applying addC }\n  (exec c . add) s\n= { applying . }\n  exec c (add s)\n= { assume s of the form m : n : s' }\n  exec c (add (m : n : s'))\n= { applying add }\n  exec c (n+m : s')\n"})}),"\n",(0,i.jsx)(n.p,{children:"In conclusion, we have calculated the following definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"exec :: Code -> Stack -> Stack\nexec HALT s = s\nexec (PUSH n c) s = exec c (n : s)\nexec (ADD c) (m : n : s) = exec c (n+m : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That is, ",(0,i.jsx)(n.code,{children:"exec"})," is a function that executes code using an initial stack to give a final stack. In other words, ",(0,i.jsx)(n.code,{children:"exec"})," is a virtual machine for executing code."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, defunctionalisation itself now proceeds by simply replacing occurrences of the combinations ",(0,i.jsx)(n.code,{children:"haltC"}),", ",(0,i.jsx)(n.code,{children:"pushC"})," and ",(0,i.jsx)(n.code,{children:"addC"})," in the evaluation functions ",(0,i.jsx)(n.code,{children:"eval'"})," and ",(0,i.jsx)(n.code,{children:"eval''"})," by their respective counterparts ",(0,i.jsx)(n.code,{children:"HALT"}),", ",(0,i.jsx)(n.code,{children:"PUSH"})," and ",(0,i.jsx)(n.code,{children:"ADD"})," from the type ",(0,i.jsx)(n.code,{children:"Code"}),", which results in the following two new definitions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"comp :: Expr -> Code\ncomp e = comp' e HALT\n\ncomp' :: Expr -> Code -> Code\ncomp' (Val n)   c = PUSH n c\ncomp' (Add x y) c = comp' x (comp' y (ADD c))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That is, we have now derived a function ",(0,i.jsx)(n.code,{children:"comp"})," that compiles an expression to code, which is itself defined in terms of an auxiliary function ",(0,i.jsx)(n.code,{children:"comp'"})," that takes additional code as an extra argument. This is essentially the same compiler that we developed in the previous chapter, except that all the required compilation machinery \u2014 compiler, target language and virtual machine \u2014 has now been systematically derived from a semantics for the source language using equational reasoning."]}),"\n",(0,i.jsxs)(n.p,{children:["The only difference is that rather than representing code as a list, we now have a dedicated recursive type for code. For example, ",(0,i.jsx)(n.code,{children:"[PUSH 1, PUSH 2, ADD]"})," is now written as ",(0,i.jsx)(n.code,{children:"PUSH 1 (PUSH 2 (ADD HALT))"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The correctness of the compilation functions ",(0,i.jsx)(n.code,{children:"comp"})," and ",(0,i.jsx)(n.code,{children:"comp'"})," is captured by the following two equations, which are consequences of defunctionalisation, or can be verified by simple inductive proofs on the expression argument:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp e) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval' e s"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp' e c) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval'' e (exec c) s"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Expanding the right-hand sides of these equations using the original specifications for the functions ",(0,i.jsx)(n.code,{children:"eval'"})," and ",(0,i.jsx)(n.code,{children:"eval''"}),", we obtain the same compiler correctness equations that were used in the previous chapter:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp e) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval e : s"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp' e c) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c (eval e : s)"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"combining-the-steps",children:"Combining the steps"}),"\n",(0,i.jsx)(n.p,{children:"We have now shown how an evaluation function for arithmetic expressions can be transformed into a compiler using a systematic three-step process:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"calculate a generalised evaluation function that uses a stack;"}),"\n",(0,i.jsx)(n.li,{children:"calculate a further generalised version that uses a continuation;"}),"\n",(0,i.jsx)(n.li,{children:"defunctionalise to produce a compiler and a virtual machine."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["However, there appear to be some opportunities for simplifying this process. In particular, steps 1 and 2 both calculate generalised versions of the original evaluation function. Could these steps be combined to avoid the need for separate generalisation steps? In turn, step 2 introduces the use of continuations, which are then immediately removed in step 3. Could these steps be combined the avoid the need for continuations? In fact, it turns out that ",(0,i.jsx)(n.strong,{children:"all"})," the transformation steps can be combined together. This section shows how this can be achieved, and explains the benefits that result from doing so."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to simplify the above stepwise process, let us first consider the types and functions that are involved in the process in more detail. We started off by defining a type ",(0,i.jsx)(n.code,{children:"Expr"})," that represents the syntax of the source language, together with an evaluation function ",(0,i.jsx)(n.code,{children:"eval :: Expr -> Int"})," that provides a semantics for the language, and a type ",(0,i.jsx)(n.code,{children:"Stack"})," that represents a stack of integer values."]}),"\n",(0,i.jsx)(n.p,{children:"Then we derived four additional components:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["a type ",(0,i.jsx)(n.code,{children:"Code"})," that represents code for the virtual machine;"]}),"\n",(0,i.jsxs)(n.li,{children:["a function ",(0,i.jsx)(n.code,{children:"comp :: Expr -> Code"})," that compiles expressions to code;"]}),"\n",(0,i.jsxs)(n.li,{children:["a function ",(0,i.jsx)(n.code,{children:"comp' :: Expr -> Code -> Code"})," with a code argument;"]}),"\n",(0,i.jsxs)(n.li,{children:["a function ",(0,i.jsx)(n.code,{children:"exec :: Code -> Stack -> Stack"})," that executes code."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Moreover, the relationships between the semantics, compilers and virtual machine were captured by the following two correctness equations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp e) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval e : s"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp' e c) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c (eval e : s)"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The key to combining the transformation steps is to use these two equations directly as a ",(0,i.jsx)(n.strong,{children:"specification"})," for the four additional components, from which we then aim to calculate definitions that satisfy the specification. Given that the equations involve three known definitions (",(0,i.jsx)(n.code,{children:"Expr"}),", ",(0,i.jsx)(n.code,{children:"eval"})," and ",(0,i.jsx)(n.code,{children:"Stack"}),") and four unknown definitions (",(0,i.jsx)(n.code,{children:"Code"}),", ",(0,i.jsx)(n.code,{children:"comp"}),", ",(0,i.jsx)(n.code,{children:"comp'"})," and ",(0,i.jsx)(n.code,{children:"exec"}),"), this may seem like an impossible task. However, with the benefit of the experience gained from our earlier calculations in the previous sections, it turns out to be straightforward."]}),"\n",(0,i.jsxs)(n.p,{children:["We begin with the correctness equation for ",(0,i.jsx)(n.code,{children:"comp'"}),", and proceed by induction on the expression ",(0,i.jsx)(n.code,{children:"e"}),". In each case, we aim to rewrite the left-hand side ",(0,i.jsx)(n.code,{children:"exec (comp' e c) s"})," of the equation into the form ",(0,i.jsx)(n.code,{children:"exec c' s"})," for some code ",(0,i.jsx)(n.code,{children:"c'"}),", from which we can then conclude that the definition ",(0,i.jsx)(n.code,{children:"comp' e c = c'"})," satisfies the specification in this case. In order to do this we will find that we need to introduce new constructors into the ",(0,i.jsx)(n.code,{children:"Code"})," type, along with their interpretation by the function ",(0,i.jsx)(n.code,{children:"exec"}),". In the base case, ",(0,i.jsx)(n.code,{children:"Val n"}),", we proceed as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec (comp' (Val n) c) s\n= { specification of comp' }\n  exec c (eval (Val n) : s)\n= { applying eval }\n  exec c (n : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we appear to be stuck, as no further definitions can be applied. However, recall that we are aiming to end up with a term of the form ",(0,i.jsx)(n.code,{children:"exec c' s"})," for some code ",(0,i.jsx)(n.code,{children:"c'"}),". Hence, to complete the calculation we need to solve the equation:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec c' s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c (n : s)"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that we can\u2019t simply use this equation as a definition for ",(0,i.jsx)(n.code,{children:"exec"}),", because the variables ",(0,i.jsx)(n.code,{children:"n"})," and ",(0,i.jsx)(n.code,{children:"c"})," would be unbound in the body of the definition. The solution is to package these two variables up in the code argument ",(0,i.jsx)(n.code,{children:"c'"})," by means of a new constructor in the ",(0,i.jsx)(n.code,{children:"Code"})," type that takes these variables as arguments,"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"PUSH :: Int -> Code -> Code\n"})}),"\n",(0,i.jsxs)(n.p,{children:["and define a new equation for ",(0,i.jsx)(n.code,{children:"exec"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"exec (PUSH n c) s = exec c (n : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That is, executing the code ",(0,i.jsx)(n.code,{children:"PUSH n c"})," proceeds by pushing the value ",(0,i.jsx)(n.code,{children:"n"})," onto the stack and then executing the code ",(0,i.jsx)(n.code,{children:"c"}),", hence the choice of the name for the new constructor."]}),"\n",(0,i.jsx)(n.p,{children:"Using these ideas, it is now easy to complete the calculation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec c (n : s)\n= { unapplying exec }\n  exec (PUSH n c) s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The final term now has the form ",(0,i.jsx)(n.code,{children:"exec c' s"}),", where ",(0,i.jsx)(n.code,{children:"c'"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"PUSH n c"}),", from which we conclude that the specification is satisfied in the base case by defining:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"comp' (Val n) c = PUSH n c\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For the inductive case, ",(0,i.jsx)(n.code,{children:"Add x y"}),", we begin in the same way as above by first applying the specification and the definition of the evaluation function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec (comp' (Add x y) c) s\n= { specification of comp' }\n  exec c (eval (Add x y) : s)\n= { applying eval }\n  exec c (eval x + eval y : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Once again we appear to be stuck, as no further definitions can be applied. However, as we are performing an inductive calculation, we can make use of the induction hypotheses for the two argument expressions ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"}),", namely"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp' x c') s'"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c' (eval x : s')"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec (comp' y c') s'"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c' (eval y : s')"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to use these hypotheses, it is clear that we must push the values ",(0,i.jsx)(n.code,{children:"eval x"})," and ",(0,i.jsx)(n.code,{children:"eval y"})," onto the stack, by transforming the term that we are manipulating into the form ",(0,i.jsx)(n.code,{children:"exec c' (eval y : eval x : s)"})," for some code ",(0,i.jsx)(n.code,{children:"c'"}),". That is, we need to solve the following equation:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec c' (eval y : eval x : s)"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c (eval x + eval y : s)"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["First of all, we generalise from specific values ",(0,i.jsx)(n.code,{children:"eval x"})," and ",(0,i.jsx)(n.code,{children:"eval y"})," to give:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exec c' (m : n : s)"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"exec c (n+m : s)"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Once again, however, we can't use this equation as a definition for ",(0,i.jsx)(n.code,{children:"exec"}),", this time because the variable ",(0,i.jsx)(n.code,{children:"c"})," is unbound. The solution is to package this variable up in the code argument ",(0,i.jsx)(n.code,{children:"c'"})," by means of a new constructor in the ",(0,i.jsx)(n.code,{children:"Code"})," type"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"ADD :: Code -> Code\n"})}),"\n",(0,i.jsxs)(n.p,{children:["and define a new equation for ",(0,i.jsx)(n.code,{children:"exec"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"exec (ADD c) (m : n : s) = exec c (n+m : s)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That is, executing the code ",(0,i.jsx)(n.code,{children:"ADD c"})," proceeds by adding the top two values on the stack and then executing the code ",(0,i.jsx)(n.code,{children:"c"}),", hence the choice of the name for the new constructor. Using these ideas, it is now easy to complete the calculation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec c (eval x + eval y : s)\n= { unapplying exec }\n  exec (ADD c) (eval y : eval x : s)\n= { induction hypothesis for y }\n  exec (comp' y (ADD c)) (eval x : s)\n= { induction hypothesis for x }\n  exec (comp' x (comp' y (ADD c))) s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The final term now has the form ",(0,i.jsx)(n.code,{children:"exec c' s"}),", from which we conclude that the specification is satisfied in the inductive case by defining:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"comp' (Add x y) c = comp' x (comp' y (ADD c))\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u25a1"}),"\n",(0,i.jsxs)(n.p,{children:["Note that as in our earlier calculation of the stack-based evaluator, we chose to transform the stack into the form ",(0,i.jsx)(n.code,{children:"eval y : eval x : s"}),". We could equally well have chosen the opposite order, ",(0,i.jsx)(n.code,{children:"eval x : eval y : s"}),", which would have resulted in right-to-left evaluation for ",(0,i.jsx)(n.code,{children:"Add"}),". We have this freedom in the calculation because the semantics defined by ",(0,i.jsx)(n.code,{children:"eval"})," does not specify an evaluation order."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we complete the development of our compiler by considering the function ",(0,i.jsx)(n.code,{children:"comp :: Expr -> Code"})," specified by the equation ",(0,i.jsx)(n.code,{children:"exec (comp e) s"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"="})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="})]})})]})," ",(0,i.jsx)(n.code,{children:"eval e : s"}),". In a similar manner to above, we aim to rewrite the left-hand side ",(0,i.jsx)(n.code,{children:"exec (comp e) s"})," of the equation into the form ",(0,i.jsx)(n.code,{children:"exec c s"})," for some code ",(0,i.jsx)(n.code,{children:"c"}),", from which we can then conclude that the definition ",(0,i.jsx)(n.code,{children:"comp e = c"})," satisfies the specification. In this case there is no need to use induction as simple calculation suffices, during which we introduce a new constructor ",(0,i.jsx)(n.code,{children:"HALT :: Code"})," in order to transform the term being manipulated into the required form:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"  exec (comp e) s\n= { specification of comp }\n  eval e : s\n= { define: exec HALT s = s }\n  exec HALT (eval e : s)\n= { specification of comp' }\n  exec (comp' e HALT) s\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u25a1"}),"\n",(0,i.jsx)(n.p,{children:"In conclusion, we have calculated the following definitions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Code = HALT | PUSH Int Code | ADD Code\n\ncomp :: Expr -> Code\ncomp e = comp' e HALT\n\ncomp' :: Expr -> Code -> Code\ncomp' (Val n)   c = PUSH n c\ncomp' (Add x y) c = comp' x (comp' y (ADD c))\n\nexec :: Code -> Stack -> Stack\nexec HALT         s       = s\nexec (PUSH n c)   s       = exec c (n : s)\nexec (ADD c)      (m:n:s) = exec c (n+m : s)\n"})}),"\n",(0,i.jsx)(n.p,{children:"These are precisely the same definitions as we produced in the previous section, except that they have now been calculated directly from a specification of compiler correctness, rather than indirectly by means of a series of separate transformation steps. Moreover, the combined approach also has the advantage that it only uses simple equational reasoning techniques. In particular, the use of continuations and defunctionalisation is no longer required!"})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var a=s(6540);const i={},c=a.createContext(i);function t(e){const n=a.useContext(c);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(c.Provider,{value:n},e.children)}},9844:e=>{e.exports=JSON.parse('{"permalink":"/blog/calculating-compilers","editUrl":"https://github.com/dream2405/blog/tree/main/blog/2025-09--10-hs-ch17/index.md","source":"@site/blog/2025-09--10-hs-ch17/index.md","title":"Calculating compilers","description":"In this final chapter we show how the reasoning techniques introduced in the previous chapter can be used to calculate compilers. We start by showing how a semantics for a language can be transformed into a compiler in a series of steps, and then show how the steps can be combined to allow a compiler to be calculated directly from a statement of its correctness.","date":"2025-09-10T08:31:08.000Z","tags":[{"inline":false,"label":"Haskell","permalink":"/blog/tags/haskell","description":"Haskell tag description"},{"inline":false,"label":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d","permalink":"/blog/tags/functional-programming","description":"\ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \ud328\ub7ec\ub2e4\uc784\uc5d0 \ub300\ud55c \uae00"}],"readingTime":19.5,"hasTruncateMarker":true,"authors":[{"name":"dream2405","title":"\uac8c\uc73c\ub978 \ub300\ud559\uc0dd","socials":{"github":"https://github.com/dream2405"},"imageURL":"https://github.com/dream2405.png","key":"dream2405","page":null}],"frontMatter":{"slug":"calculating-compilers","title":"Calculating compilers","authors":["dream2405"],"tags":["haskell","functional_programming"]},"unlisted":false,"nextItem":{"title":"Reasoning about programs","permalink":"/blog/reasoning-about-programs"}}')}}]);